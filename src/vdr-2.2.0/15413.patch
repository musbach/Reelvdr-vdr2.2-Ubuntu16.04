Index: menu.c
===================================================================
--- menu.c	(revision 15412)
+++ menu.c	(revision 15413)
@@ -8,6 +8,9 @@
  */
 
 #include "menu.h"
+#ifdef USE_WAREAGLEICON
+#include "iconpatch.h"
+#endif /* WAREAGLEICON */
 #include <ctype.h>
 #include <limits.h>
 #include <math.h>
@@ -31,6 +34,9 @@
 #include "timers.h"
 #include "transfer.h"
 #include "videodir.h"
+#ifdef USE_MENUORG
+#include "menuorgpatch.h"
+#endif /* MENUORG */
 
 #define MAXWAIT4EPGINFO   3 // seconds
 #define MODETIMEOUT       3 // seconds
@@ -203,6 +209,9 @@
 public:
   cMenuEditChannel(cChannel *Channel, bool New = false);
   virtual eOSState ProcessKey(eKeys Key);
+#ifdef USE_GRAPHTFT
+  virtual const char* MenuKind() { return "MenuEditChannel"; }
+#endif /* GRAPHTFT */
   };
 
 cMenuEditChannel::cMenuEditChannel(cChannel *Channel, bool New)
@@ -250,6 +259,9 @@
   Add(new cMenuEditIntItem( tr("Tid"),          &data.tid, 0));
   Add(new cMenuEditIntItem( tr("Rid"),          &data.rid, 0));
   XXX*/
+#ifdef USE_CHANNELBIND
+  Add(new cMenuEditIntItem( tr("Rid"),          &data.rid, 0)); // channel binding patch
+#endif /* CHANNELBIND */
   // Parameters for specific types of sources:
   sourceParam = SourceParams.Get(**cSource::ToString(data.source));
   if (sourceParam) {
@@ -350,6 +362,16 @@
   if (!channel->GroupSep()) {
      if (sortMode == csmProvider)
         buffer = cString::sprintf("%d\t%s - %s", channel->Number(), channel->Provider(), channel->Name());
+#ifdef USE_WAREAGLEICON
+     else if (Setup.WarEagleIcons) {
+        if (channel->Vpid() == 1 || channel->Vpid() == 0)
+           buffer = cString::sprintf("%d\t%s %-30s", channel->Number(), IsLangUtf8() ? ICON_RADIO_UTF8 : ICON_RADIO, channel->Name());
+        else if (channel->Ca() == 0)
+           buffer = cString::sprintf("%d\t%s %-30s", channel->Number(), IsLangUtf8() ? ICON_TV_UTF8 : ICON_TV, channel->Name());
+        else
+           buffer = cString::sprintf("%d\t%s %-30s", channel->Number(), IsLangUtf8() ? ICON_TV_CRYPTED_UTF8 : ICON_TV_CRYPTED, channel->Name());
+        }
+#endif /* WAREAGLEICON */
      else
         buffer = cString::sprintf("%d\t%s", channel->Number(), channel->Name());
      }
@@ -380,6 +402,9 @@
   cMenuChannels(void);
   ~cMenuChannels();
   virtual eOSState ProcessKey(eKeys Key);
+#ifdef USE_GRAPHTFT
+  virtual const char* MenuKind() { return "MenuChannels"; }
+#endif /* GRAPHTFT */
   };
 
 cMenuChannels::cMenuChannels(void)
@@ -918,6 +943,17 @@
      Add(new cMenuEditBitItem( tr("VPS"),          &data.flags, tfVps));
      Add(new cMenuEditIntItem( tr("Priority"),     &data.priority, 0, MAXPRIORITY));
      Add(new cMenuEditIntItem( tr("Lifetime"),     &data.lifetime, 0, MAXLIFETIME));
+#ifdef USE_PINPLUGIN
+     if (cOsd::pinValid || !data.fskProtection) Add(new cMenuEditBoolItem(tr("Childlock"),&data.fskProtection));
+     else {
+        char* buf = 0;
+        if (asprintf(&buf, "%s\t%s", tr("Childlock"), data.fskProtection ? tr("yes") : tr("no")) > 0) {
+           Add(new cOsdItem(buf));
+           free(buf);
+           }
+        }
+
+#endif /* PINPLUGIN */
      Add(file = new cMenuEditStrItem( tr("File"),   data.file, sizeof(data.file)));
      SetFirstDayItem();
      }
@@ -1018,8 +1054,14 @@
 class cMenuTimerItem : public cOsdItem {
 private:
   cTimer *timer;
+#ifdef USE_TIMERINFO
+  char diskStatus;
+#endif /* TIMERINFO */
 public:
   cMenuTimerItem(cTimer *Timer);
+#ifdef USE_TIMERINFO
+  void SetDiskStatus(char DiskStatus);
+#endif /* TIMERINFO */
   virtual int Compare(const cListObject &ListObject) const;
   virtual void Set(void);
   cTimer *Timer(void) { return timer; }
@@ -1028,6 +1070,9 @@
 cMenuTimerItem::cMenuTimerItem(cTimer *Timer)
 {
   timer = Timer;
+#ifdef USE_TIMERINFO
+  diskStatus = ' ';
+#endif /* TIMERINFO */
   Set();
 }
 
@@ -1058,8 +1103,31 @@
      File++;
   else
      File = timer->File();
+#ifdef USE_WAREAGLEICON
+#ifdef USE_TIMERINFO
+  cCharSetConv csc("ISO-8859-1", cCharSetConv::SystemCharacterTable());
+  char diskStatusString[2] = { diskStatus, 0 };
+  SetText(cString::sprintf("%s%s\t%d\t%s%s%s\t%02d:%02d\t%02d:%02d\t%s",
+                    csc.Convert(diskStatusString),
+#else
+  SetText(cString::sprintf("%s\t%d\t%s%s%s\t%02d:%02d\t%02d:%02d\t%s",
+#endif /* TIMERINFO */
+#else
+#ifdef USE_TIMERINFO
+  cCharSetConv csc("ISO-8859-1", cCharSetConv::SystemCharacterTable());
+  char diskStatusString[2] = { diskStatus, 0 };
+  SetText(cString::sprintf("%s%c\t%d\t%s%s%s\t%02d:%02d\t%02d:%02d\t%s",
+                    csc.Convert(diskStatusString),
+#else
   SetText(cString::sprintf("%c\t%d\t%s%s%s\t%02d:%02d\t%02d:%02d\t%s",
+#endif /* TIMERINFO */
+#endif /* WAREAGLEICON */
+#ifdef USE_WAREAGLEICON
+                    !(timer->HasFlags(tfActive)) ? " " : timer->FirstDay() ? Setup.WarEagleIcons ? IsLangUtf8() ? ICON_ARROW_UTF8 : ICON_ARROW : "!" : timer->Recording() ? Setup.WarEagleIcons ? IsLangUtf8() ? ICON_REC_UTF8 : ICON_REC : "#" : Setup.WarEagleIcons ? IsLangUtf8() ? ICON_CLOCK_UTF8 : ICON_CLOCK : ">",
+
+#else
                     !(timer->HasFlags(tfActive)) ? ' ' : timer->FirstDay() ? '!' : timer->Recording() ? '#' : '>',
+#endif /* WAREAGLEICON */
                     timer->Channel()->Number(),
                     *name,
                     *name && **name ? " " : "",
@@ -1071,6 +1139,58 @@
                     File));
 }
 
+#ifdef USE_TIMERINFO
+void cMenuTimerItem::SetDiskStatus(char DiskStatus)
+{
+  diskStatus = DiskStatus;
+  Set();
+}
+
+// --- cTimerEntry -----------------------------------------------------------
+
+class cTimerEntry : public cListObject {
+private:
+  cMenuTimerItem *item;
+  const cTimer *timer;
+  time_t start;
+public:
+  cTimerEntry(cMenuTimerItem *item) : item(item), timer(item->Timer()), start(timer->StartTime()) {}
+  cTimerEntry(const cTimer *timer, time_t start) : item(NULL), timer(timer), start(start) {}
+  virtual int Compare(const cListObject &ListObject) const;
+  bool active(void) const { return timer->HasFlags(tfActive); }
+  time_t startTime(void) const { return start; }
+  int priority(void) const { return timer->Priority(); }
+  int duration(void) const;
+  bool repTimer(void) const { return !timer->IsSingleEvent(); }
+  bool isDummy(void) const { return item == NULL; }
+  const cTimer *Timer(void) const { return timer; }
+  void SetDiskStatus(char DiskStatus);
+  };
+
+int cTimerEntry::Compare(const cListObject &ListObject) const
+{
+  cTimerEntry *entry = (cTimerEntry *)&ListObject;
+  int r = startTime() - entry->startTime();
+  if (r == 0)
+     r = entry->priority() - priority();
+  return r;
+}
+
+int cTimerEntry::duration(void) const
+{
+  int dur = (timer->Stop()  / 100 * 60 + timer->Stop()  % 100) -
+            (timer->Start() / 100 * 60 + timer->Start() % 100);
+  if (dur < 0)
+     dur += 24 * 60;
+  return dur;
+}
+
+void cTimerEntry::SetDiskStatus(char DiskStatus)
+{
+  if (item)
+     item->SetDiskStatus(DiskStatus);
+}
+#endif /* TIMERINFO */
 // --- cMenuTimers -----------------------------------------------------------
 
 class cMenuTimers : public cOsdMenu {
@@ -1083,14 +1203,25 @@
   eOSState Info(void);
   cTimer *CurrentTimer(void);
   void SetHelpKeys(void);
+#ifdef USE_TIMERINFO
+  void ActualiseDiskStatus(void);
+  bool actualiseDiskStatus;
+#endif /* TIMERINFO */
 public:
   cMenuTimers(void);
   virtual ~cMenuTimers();
+#ifdef USE_TIMERINFO
+  virtual void Display(void);
+#endif /* TIMERINFO */
   virtual eOSState ProcessKey(eKeys Key);
   };
 
 cMenuTimers::cMenuTimers(void)
+#ifdef USE_TIMERINFO
+:cOsdMenu(tr("Timers"), 3, CHNUMWIDTH, 10, 6, 6)
+#else
 :cOsdMenu(tr("Timers"), 2, CHNUMWIDTH, 10, 6, 6)
+#endif /* TIMERINFO */
 {
   helpKeys = -1;
   for (cTimer *timer = Timers.First(); timer; timer = Timers.Next(timer)) {
@@ -1101,6 +1232,9 @@
   SetCurrent(First());
   SetHelpKeys();
   Timers.IncBeingEdited();
+#ifdef USE_TIMERINFO
+  actualiseDiskStatus = true;
+#endif /* TIMERINFO */
 }
 
 cMenuTimers::~cMenuTimers()
@@ -1139,7 +1273,11 @@
      timer->OnOff();
      timer->SetEventFromSchedule();
      RefreshCurrent();
+#ifdef USE_TIMERINFO
+     Display();
+#else
      DisplayCurrent(true);
+#endif /* TIMERINFO */
      if (timer->FirstDay())
         isyslog("timer %s first day set to %s", *timer->ToDescr(), *timer->PrintFirstDay());
      else
@@ -1198,6 +1336,68 @@
   return osContinue;
 }
 
+#ifdef USE_TIMERINFO
+void cMenuTimers::ActualiseDiskStatus(void)
+{
+  if (!actualiseDiskStatus || !Count())
+     return;
+
+  // compute free disk space
+  int freeMB, freeMinutes, runshortMinutes;
+  VideoDiskSpace(&freeMB);
+  freeMinutes = int(double(freeMB) * 1.1 / MB_PER_MINUTE); // overestimate by 10 percent
+  runshortMinutes = freeMinutes / 5; // 20 Percent
+
+  // fill entries list
+  cTimerEntry *entry;
+  cList<cTimerEntry> entries;
+  for (cOsdItem *item = First(); item; item = Next(item))
+     entries.Add(new cTimerEntry((cMenuTimerItem *)item));
+
+  // search last start time
+  time_t last = 0;
+  for (entry = entries.First(); entry; entry = entries.Next(entry))
+     last = max(entry->startTime(), last);
+
+  // add entries for repeating timers
+  for (entry = entries.First(); entry; entry = entries.Next(entry))
+     if (entry->repTimer() && !entry->isDummy())
+        for (time_t start = cTimer::IncDay(entry->startTime(), 1);
+             start <= last;
+             start = cTimer::IncDay(start, 1))
+           if (entry->Timer()->DayMatches(start))
+              entries.Add(new cTimerEntry(entry->Timer(), start));
+
+  // set the disk-status
+  entries.Sort();
+  for (entry = entries.First(); entry; entry = entries.Next(entry)) {
+     char status = ' ';
+     if (entry->active()) {
+        freeMinutes -= entry->duration();
+        status = freeMinutes > runshortMinutes ? '+' : freeMinutes > 0 ? 177 /* +/- */ : '-';
+        }
+     entry->SetDiskStatus(status);
+#ifdef DEBUG_TIMER_INFO
+     dsyslog("timer-info: %c | %d | %s | %s | %3d | %+5d -> %+5d",
+             status,
+             entry->startTime(),
+             entry->active() ? "aktiv " : "n.akt.",
+             entry->repTimer() ? entry->isDummy() ? "  dummy  " : "mehrmalig" : "einmalig ",
+             entry->duration(),
+             entry->active() ? freeMinutes + entry->duration() : freeMinutes,
+             freeMinutes);
+#endif
+     }
+
+  actualiseDiskStatus = false;
+}
+
+void cMenuTimers::Display(void)
+{
+  ActualiseDiskStatus();
+  cOsdMenu::Display();
+}
+#endif /* TIMERINFO */
 eOSState cMenuTimers::ProcessKey(eKeys Key)
 {
   int TimerNumber = HasSubMenu() ? Count() : -1;
@@ -1206,18 +1406,36 @@
   if (state == osUnknown) {
      switch (Key) {
        case kOk:     return Edit();
+#ifdef USE_TIMERINFO
+       case kRed:    actualiseDiskStatus = true;
+                     state = OnOff(); break; // must go through SetHelpKeys()!
+#else
        case kRed:    state = OnOff(); break; // must go through SetHelpKeys()!
+#endif /* TIMERINFO */
        case kGreen:  return New();
+#ifdef USE_TIMERINFO
+       case kYellow: actualiseDiskStatus = true;
+                     state = Delete(); break;
+#else
        case kYellow: state = Delete(); break;
+#endif /* TIMERINFO */
        case kInfo:
        case kBlue:   return Info();
                      break;
        default: break;
        }
      }
+#ifdef USE_TIMERINFO
+  if (TimerNumber >= 0 && !HasSubMenu()) {
+     if (Timers.Get(TimerNumber)) // a newly created timer was confirmed with Ok
+        Add(new cMenuTimerItem(Timers.Get(TimerNumber)), true);
+     Sort();
+     actualiseDiskStatus = true;
+#else
   if (TimerNumber >= 0 && !HasSubMenu() && Timers.Get(TimerNumber)) {
      // a newly created timer was confirmed with Ok
      Add(new cMenuTimerItem(Timers.Get(TimerNumber)), true);
+#endif /* TIMERINFO */
      Display();
      }
   if (Key != kNone)
@@ -1247,6 +1465,9 @@
 {
   cOsdMenu::Display();
   DisplayMenu()->SetEvent(event);
+#ifdef USE_GRAPHTFT
+  cStatus::MsgOsdSetEvent(event);
+#endif /* GRAPHTFT */
   if (event->Description())
      cStatus::MsgOsdTextItem(event->Description());
 }
@@ -1294,7 +1515,12 @@
   const cChannel *channel;
   bool withDate;
   int timerMatch;
+#ifdef USE_LIEMIEXT
+  bool withBar;
+  cMenuScheduleItem(const cEvent *Event, cChannel *Channel = NULL, bool WithDate = false, bool WithBar = false);
+#else
   cMenuScheduleItem(const cEvent *Event, cChannel *Channel = NULL, bool WithDate = false);
+#endif /* LIEMIEXT */
   static void SetSortMode(eScheduleSortMode SortMode) { sortMode = SortMode; }
   static void IncSortMode(void) { sortMode = eScheduleSortMode((sortMode == ssmAllAll) ? ssmAllThis : sortMode + 1); }
   static eScheduleSortMode SortMode(void) { return sortMode; }
@@ -1304,12 +1530,19 @@
 
 cMenuScheduleItem::eScheduleSortMode cMenuScheduleItem::sortMode = ssmAllThis;
 
+#ifdef USE_LIEMIEXT
+cMenuScheduleItem::cMenuScheduleItem(const cEvent *Event, cChannel *Channel, bool WithDate, bool WithBar)
+#else
 cMenuScheduleItem::cMenuScheduleItem(const cEvent *Event, cChannel *Channel, bool WithDate)
+#endif /* LIEMIEXT */
 {
   event = Event;
   channel = Channel;
   withDate = WithDate;
   timerMatch = tmNone;
+#ifdef USE_LIEMIEXT
+  withBar = WithBar;
+#endif /* LIEMIEXT */
   Update(true);
 }
 
@@ -1324,8 +1557,31 @@
   return r;
 }
 
+#ifdef USE_WAREAGLEICON
+static const char *TimerMatchChars[9] =
+{
+  " ", "t", "T",
+  ICON_BLANK, ICON_CLOCK_UH, ICON_CLOCK,
+  ICON_BLANK_UTF8, ICON_CLOCK_UH_UTF8, ICON_CLOCK_UTF8
+};
+#else
 static const char *TimerMatchChars = " tT";
+#endif /* WAREAGLEICON */
 
+#ifdef USE_LIEMIEXT
+static const char * const ProgressBar[7] =
+{
+  "[      ]",
+  "[|     ]",
+  "[||    ]",
+  "[|||   ]",
+  "[||||  ]",
+  "[||||| ]",
+  "[||||||]"
+};
+
+#endif /* LIEMIEXT */
+
 bool cMenuScheduleItem::Update(bool Force)
 {
   bool result = false;
@@ -1333,17 +1589,54 @@
   Timers.GetMatch(event, &timerMatch);
   if (Force || timerMatch != OldTimerMatch) {
      cString buffer;
+#ifdef USE_WAREAGLEICON
+     const char *t = Setup.WarEagleIcons ? IsLangUtf8() ? TimerMatchChars[timerMatch+6] : TimerMatchChars[timerMatch+3] : TimerMatchChars[timerMatch];
+     const char *v = event->Vps() && (event->Vps() - event->StartTime()) ? Setup.WarEagleIcons ? IsLangUtf8() ? ICON_VPS_UTF8 : ICON_VPS : "V" : " ";
+     const char *r = event->SeenWithin(30) && event->IsRunning() ? Setup.WarEagleIcons ? IsLangUtf8() ? ICON_RUNNING_UTF8 : ICON_RUNNING : "*" : " ";
+#else
      char t = TimerMatchChars[timerMatch];
      char v = event->Vps() && (event->Vps() - event->StartTime()) ? 'V' : ' ';
      char r = event->SeenWithin(30) && event->IsRunning() ? '*' : ' ';
+#endif /* WAREAGLEICON */
      const char *csn = channel ? channel->ShortName(true) : NULL;
      cString eds = event->GetDateString();
      if (channel && withDate)
+#ifdef USE_WAREAGLEICON
+        buffer = cString::sprintf("%d\t%.*s\t%.*s\t%s\t%s%s%s\t%s", channel->Number(), Utf8SymChars(csn, 6), csn, Utf8SymChars(eds, 6), *eds, *event->GetTimeString(), t, v, r, event->Title());
+#else
         buffer = cString::sprintf("%d\t%.*s\t%.*s\t%s\t%c%c%c\t%s", channel->Number(), Utf8SymChars(csn, 6), csn, Utf8SymChars(eds, 6), *eds, *event->GetTimeString(), t, v, r, event->Title());
+#endif /* WAREAGLEICON */
      else if (channel)
+#ifdef USE_LIEMIEXT
+        if (Setup.ShowProgressBar && withBar) {
+           int progress = (int)roundf( (float)(time(NULL) - event->StartTime()) / (float)(event->Duration()) * 6.0 );
+           if (progress < 0) progress = 0;
+           else if (progress > 6) progress = 6;
+#ifdef USE_WAREAGLEICON
+           buffer = cString::sprintf("%d\t%.*s\t%s\t%s\t%s%s%s\t%s", channel->Number(), Utf8SymChars(csn, 6), csn, *event->GetTimeString(), ProgressBar[progress], t, v, r, event->Title());
+#else
+           buffer = cString::sprintf("%d\t%.*s\t%s\t%s\t%c%c%c\t%s", channel->Number(), Utf8SymChars(csn, 6), csn, *event->GetTimeString(), ProgressBar[progress], t, v, r, event->Title());
+#endif /* WAREAGLEICON */
+           }
+        else
+#ifdef USE_WAREAGLEICON
+        buffer = cString::sprintf("%d\t%.*s\t%s\t%s%s%s\t%s", channel->Number(), Utf8SymChars(csn, 6), csn, *event->GetTimeString(), t, v, r, event->Title());
+#else
         buffer = cString::sprintf("%d\t%.*s\t%s\t%c%c%c\t%s", channel->Number(), Utf8SymChars(csn, 6), csn, *event->GetTimeString(), t, v, r, event->Title());
+#endif /* WAREAGLEICON */
+#else
+#ifdef USE_WAREAGLEICON
+        buffer = cString::sprintf("%d\t%.*s\t%s\t%s%s%s\t%s", channel->Number(), Utf8SymChars(csn, 6), csn, *event->GetTimeString(), t, v, r, event->Title());
+#else
+        buffer = cString::sprintf("%d\t%.*s\t%s\t%c%c%c\t%s", channel->Number(), Utf8SymChars(csn, 6), csn, *event->GetTimeString(), t, v, r, event->Title());
+#endif /* WAREAGLEICON */
+#endif /* LIEMIEXT */
      else
+#ifdef USE_WAREAGLEICON
+        buffer = cString::sprintf("%.*s\t%s\t%s%s%s\t%s", Utf8SymChars(eds, 6), *eds, *event->GetTimeString(), t, v, r, event->Title());
+#else
         buffer = cString::sprintf("%.*s\t%s\t%c%c%c\t%s", Utf8SymChars(eds, 6), *eds, *event->GetTimeString(), t, v, r, event->Title());
+#endif /* WAREAGLEICON */
      SetText(buffer);
      result = true;
      }
@@ -1369,13 +1662,21 @@
   static void SetCurrentChannel(int ChannelNr) { currentChannel = ChannelNr; }
   static const cEvent *ScheduleEvent(void);
   virtual eOSState ProcessKey(eKeys Key);
+#ifdef USE_GRAPHTFT
+  virtual const char* MenuKind() { return now ? "MenuWhatsOnNow" : "MenuWhatsOnNext"; }
+  virtual void Display(void);
+#endif /* GRAPHTFT */
   };
 
 int cMenuWhatsOn::currentChannel = 0;
 const cEvent *cMenuWhatsOn::scheduleEvent = NULL;
 
 cMenuWhatsOn::cMenuWhatsOn(const cSchedules *Schedules, bool Now, int CurrentChannelNr)
+#ifdef USE_LIEMIEXT
+:cOsdMenu(Now ? tr("What's on now?") : tr("What's on next?"), CHNUMWIDTH, 7, 6, 4, 4)
+#else
 :cOsdMenu(Now ? tr("What's on now?") : tr("What's on next?"), CHNUMWIDTH, 7, 6, 4)
+#endif /* LIEMIEXT */
 {
   now = Now;
   helpKeys = -1;
@@ -1387,7 +1688,11 @@
          if (Schedule) {
             const cEvent *Event = Now ? Schedule->GetPresentEvent() : Schedule->GetFollowingEvent();
             if (Event)
+#ifdef USE_LIEMIEXT
+               Add(new cMenuScheduleItem(Event, Channel, false, Now), Channel->Number() == CurrentChannelNr);
+#else
                Add(new cMenuScheduleItem(Event, Channel), Channel->Number() == CurrentChannelNr);
+#endif /* LIEMIEXT */
             }
          }
       }
@@ -1396,6 +1701,20 @@
   SetHelpKeys();
 }
 
+#ifdef USE_GRAPHTFT
+void cMenuWhatsOn::Display(void)
+{
+   cOsdMenu::Display();
+
+   if (Count() > 0) {
+      int ni = 0;
+      for (cOsdItem *item = First(); item; item = Next(item)) {
+         cStatus::MsgOsdEventItem(((cMenuScheduleItem*)item)->event, item->Text(), ni++, Count());
+      }
+   }
+}
+#endif /* GRAPHTFT */
+
 bool cMenuWhatsOn::Update(void)
 {
   bool result = false;
@@ -1536,6 +1855,10 @@
   cMenuSchedule(void);
   virtual ~cMenuSchedule();
   virtual eOSState ProcessKey(eKeys Key);
+#ifdef USE_GRAPHTFT
+  virtual const char* MenuKind() { return "MenuSchedule"; }
+  virtual void Display(void);
+#endif /* GRAPHTFT */
   };
 
 cMenuSchedule::cMenuSchedule(void)
@@ -1561,6 +1884,20 @@
   cMenuWhatsOn::ScheduleEvent(); // makes sure any posted data is cleared
 }
 
+#ifdef USE_GRAPHTFT
+void cMenuSchedule::Display(void)
+{
+   cOsdMenu::Display();
+
+   if (Count() > 0) {
+      int ni = 0;
+      for (cOsdItem *item = First(); item; item = Next(item)) {
+         cStatus::MsgOsdEventItem(((cMenuScheduleItem*)item)->event, item->Text(), ni++, Count());
+      }
+   }
+}
+#endif /* GRAPHTFT */
+
 void cMenuSchedule::PrepareScheduleAllThis(const cEvent *Event, const cChannel *Channel)
 {
   Clear();
@@ -1916,6 +2253,9 @@
   cMenuCam(cCamSlot *CamSlot);
   virtual ~cMenuCam();
   virtual eOSState ProcessKey(eKeys Key);
+#ifdef USE_GRAPHTFT
+  virtual const char* MenuKind() { return "MenuCam"; }
+#endif /* GRAPHTFT */
   };
 
 cMenuCam::cMenuCam(cCamSlot *CamSlot)
@@ -2095,6 +2435,9 @@
   cMenuRecording(const cRecording *Recording, bool WithButtons = false);
   virtual void Display(void);
   virtual eOSState ProcessKey(eKeys Key);
+#ifdef USE_GRAPHTFT
+  virtual const char* MenuKind() { return "MenuRecording"; }
+#endif /* GRAPHTFT */
 };
 
 cMenuRecording::cMenuRecording(const cRecording *Recording, bool WithButtons)
@@ -2110,6 +2453,9 @@
 {
   cOsdMenu::Display();
   DisplayMenu()->SetRecording(recording);
+#ifdef USE_GRAPHTFT
+  cStatus::MsgOsdSetRecording(recording);
+#endif /* GRAPHTFT */
   if (recording->Info()->Description())
      cStatus::MsgOsdTextItem(recording->Info()->Description());
 }
@@ -2170,7 +2516,11 @@
   fileName = strdup(Recording->FileName());
   name = NULL;
   totalEntries = newEntries = 0;
+#ifdef USE_LIEMIEXT
+  SetText(Recording->Title('\t', true, Level, false));
+#else
   SetText(Recording->Title('\t', true, Level));
+#endif /* LIEMIEXT */
   if (*Text() == '\t')
      name = strdup(Text() + 2); // 'Text() + 2' to skip the two '\t'
 }
@@ -2186,13 +2536,183 @@
   totalEntries++;
   if (New)
      newEntries++;
+#ifdef USE_LIEMIEXT
+  switch (Setup.ShowRecTime + Setup.ShowRecDate + Setup.ShowRecLength) {
+     case 0:
+          SetText(cString::sprintf("%s", name));
+          break;
+     case 1:
+          SetText(cString::sprintf("%d\t%s", totalEntries, name));
+          break;
+     case 2:
+     default:
+          SetText(cString::sprintf("%d\t%d\t%s", totalEntries, newEntries, name));
+          break;
+     case 3:
+          SetText(cString::sprintf("%d\t%d\t\t%s", totalEntries, newEntries, name));
+          break;
+     }
+}
+
+// --- cMenuRenameRecording --------------------------------------------------
+
+class cMenuRenameRecording : public cOsdMenu {
+private:
+  char name[MaxFileName];
+  cMenuEditStrItem *file;
+  cOsdItem *marksItem, *resumeItem;
+  bool isResume, isMarks;
+  cRecording *recording;
+  void SetHelpKeys(void);
+  eOSState SetFolder(void);
+public:
+  cMenuRenameRecording(cRecording *Recording);
+  virtual eOSState ProcessKey(eKeys Key);
+};
+
+cMenuRenameRecording::cMenuRenameRecording(cRecording *Recording)
+:cOsdMenu(tr("Rename recording"), 12)
+{
+  cMarks marks;
+
+  file = NULL;
+  recording = Recording;
+  
+  if (recording) {
+     Utf8Strn0Cpy(name, recording->Name(), sizeof(name));
+     Add(file = new cMenuEditStrItem(tr("File"), name, sizeof(name)));
+
+     Add(new cOsdItem("", osUnknown, false));
+
+     Add(new cOsdItem(cString::sprintf("%s:\t%s", tr("Date"), *DayDateTime(recording->start)), osUnknown, false));
+
+     cChannel *channel = Channels.GetByChannelID(((cRecordingInfo *)recording->Info())->ChannelID());
+     if (channel)
+        Add(new cOsdItem(cString::sprintf("%s:\t%s", tr("Channel"), *ChannelString(channel, 0)), osUnknown, false));
+
+     int recLen = cIndexFile::Length(recording->FileName(), recording->IsPesRecording());
+     if (recLen >= 0)
+        Add(new cOsdItem(cString::sprintf("%s:\t%s", tr("Length"), *IndexToHMSF(recLen, false, recording->FramesPerSecond())), osUnknown, false));
+     else
+        recLen = 0;
+
+     int dirSize = DirSizeMB(recording->FileName());
+     double seconds = recLen / recording->FramesPerSecond();
+     cString bitRate = seconds ? cString::sprintf(" (%.2f MBit/s)", 8.0 * dirSize / seconds) : cString("");
+     Add(new cOsdItem(cString::sprintf("%s:\t%s", tr("Format"), recording->IsPesRecording() ? tr("PES") : tr("TS")), osUnknown, false));
+     Add(new cOsdItem((dirSize > 9999) ? cString::sprintf("%s:\t%.2f GB%s", tr("Size"), dirSize / 1024.0, *bitRate) : cString::sprintf("%s:\t%d MB%s", tr("Size"), dirSize, *bitRate), osUnknown, false));
+
+     Add(new cOsdItem("", osUnknown, false));
+
+     isMarks = marks.Load(recording->FileName(), recording->FramesPerSecond(), recording->IsPesRecording()) && marks.Count();
+     marksItem = new cOsdItem(tr("Delete marks information?"), osUser1, isMarks);
+     Add(marksItem);
+
+     cResumeFile ResumeFile(recording->FileName(), recording->IsPesRecording());
+     isResume = (ResumeFile.Read() != -1);
+     resumeItem = new cOsdItem(tr("Delete resume information?"), osUser2, isResume);
+     Add(resumeItem);
+     }
+
+  SetHelpKeys();
+}
+
+void cMenuRenameRecording::SetHelpKeys(void)
+{
+  SetHelp(tr("Button$Folder"));
+}
+
+eOSState cMenuRenameRecording::SetFolder(void)
+{
+  cMenuFolder *mf = (cMenuFolder *)SubMenu();
+  if (mf) {
+     cString Folder = mf->GetFolder();
+     char *p = strrchr(name, FOLDERDELIMCHAR);
+     if (p)
+        p++;
+     else
+        p = name;
+     if (!isempty(*Folder))
+        strn0cpy(name, cString::sprintf("%s%c%s", *Folder, FOLDERDELIMCHAR, p), sizeof(name));
+     else if (p != name)
+        memmove(name, p, strlen(p) + 1);
+     SetCurrent(file);
+     Display();
+     }
+  return CloseSubMenu();
+}
+
+eOSState cMenuRenameRecording::ProcessKey(eKeys Key)
+{
+  eOSState state = cOsdMenu::ProcessKey(Key);
+
+  if (state == osUnknown) {
+     switch (Key) {
+       case kOk:
+            if (recording->Rename(name)) {
+               Recordings.ChangeState();
+               Recordings.TouchUpdate();
+               return osRecordings;
+               }
+            else
+               Skins.Message(mtError, tr("Error while accessing recording!"));
+            break;
+       case kRed:
+            return AddSubMenu(new cMenuFolder(tr("Select folder"), &Folders, name));
+            break;
+       default:
+            break;
+       }
+     if (Key != kNone)
+        SetHelpKeys();
+     return osContinue;
+     }
+  else if (state == osEnd && HasSubMenu())
+     state = SetFolder();
+  else if (state == osUser1) {
+     if (isMarks && Interface->Confirm(tr("Delete marks information?"))) {
+        cMarks marks;
+        marks.Load(recording->FileName(), recording->FramesPerSecond(), recording->IsPesRecording());
+        cMark *mark = marks.First();
+        while (mark) {
+          cMark *nextmark = marks.Next(mark);
+          marks.Del(mark);
+          mark = nextmark;
+          }
+        marks.Save();
+        isMarks = false;
+        marksItem->SetSelectable(isMarks);
+        SetCurrent(First());
+        Display();
+        }
+     return osContinue;
+     }
+  else if (state == osUser2) {
+     if (isResume && Interface->Confirm(tr("Delete resume information?"))) {
+        cResumeFile ResumeFile(recording->FileName(), recording->IsPesRecording());
+        ResumeFile.Delete();
+        isResume = false;
+        resumeItem->SetSelectable(isResume);
+        SetCurrent(First());
+        Display();
+        }
+     return osContinue;
+     }
+
+  return state;
+#else
   SetText(cString::sprintf("%d\t%d\t%s", totalEntries, newEntries, name));
+#endif /* LIEMIEXT */
 }
 
 // --- cMenuRecordings -------------------------------------------------------
 
 cMenuRecordings::cMenuRecordings(const char *Base, int Level, bool OpenSubMenus)
+#ifdef USE_LIEMIEXT
+:cOsdMenu(Base ? Base : tr("Recordings"), 9, 7, 7)
+#else
 :cOsdMenu(Base ? Base : tr("Recordings"), 9, 7)
+#endif /* LIEMIEXT */
 {
   base = Base ? strdup(Base) : NULL;
   level = Setup.RecordingDirs ? Level : -1;
@@ -2270,7 +2790,13 @@
   for (cRecording *recording = Recordings.First(); recording; recording = Recordings.Next(recording)) {
       if (!base || (strstr(recording->Name(), base) == recording->Name() && recording->Name()[strlen(base)] == FOLDERDELIMCHAR)) {
          cMenuRecordingItem *Item = new cMenuRecordingItem(recording, level);
+#ifdef USE_PINPLUGIN
+         if ((*Item->Text() && (!LastItem || strcmp(Item->Text(), LastItemText) != 0))
+            && (!cStatus::MsgReplayProtected(GetRecording(Item), Item->Name(), base,
+                                             Item->IsDirectory(), true))) {
+#else
          if (*Item->Text() && (!LastItem || strcmp(Item->Text(), LastItemText) != 0)) {
+#endif /* PINPLUGIN */
             Add(Item);
             LastItem = Item;
             free(LastItemText);
@@ -2320,6 +2846,11 @@
 {
   cMenuRecordingItem *ri = (cMenuRecordingItem *)Get(Current());
   if (ri) {
+#ifdef USE_PINPLUGIN
+     if (cStatus::MsgReplayProtected(GetRecording(ri), ri->Name(), base,
+                                     ri->IsDirectory()) == true)
+        return osContinue;
+#endif /* PINPLUGIN */
      if (ri->IsDirectory())
         Open();
      else {
@@ -2427,6 +2958,21 @@
   return osContinue;
 }
 
+#ifdef USE_LIEMIEXT
+eOSState cMenuRecordings::Rename(void)
+{
+  if (HasSubMenu() || Count() == 0)
+     return osContinue;
+  cMenuRecordingItem *ri = (cMenuRecordingItem *)Get(Current());
+  if (ri && !ri->IsDirectory()) {
+     cRecording *recording = GetRecording(ri);
+     if (recording)
+        return AddSubMenu(new cMenuRenameRecording(recording));
+     }
+  return osContinue;
+}
+#endif /* LIEMIEXT */
+
 eOSState cMenuRecordings::ProcessKey(eKeys Key)
 {
   bool HadSubMenu = HasSubMenu();
@@ -2441,7 +2987,16 @@
        case kYellow: return Delete();
        case kInfo:
        case kBlue:   return Info();
+#ifdef USE_LIEMIEXT
+       case k0:      DirOrderState = !DirOrderState;
+                     Set(true);
+                     return osContinue;
+       case k8:      return Rename();
+       case k9:
+       case k1...k7: return Commands(Key);
+#else
        case k1...k9: return Commands(Key);
+#endif /* LIEMIEXT */
        case kNone:   if (Recordings.StateChanged(recordingsState))
                         Set(true);
                      break;
@@ -2506,6 +3061,9 @@
   cMenuSetupOSD(void);
   virtual ~cMenuSetupOSD();
   virtual eOSState ProcessKey(eKeys Key);
+#ifdef USE_GRAPHTFT
+  virtual const char* MenuKind() { return "MenuSetupOsd"; }
+#endif /* GRAPHTFT */
   };
 
 cMenuSetupOSD::cMenuSetupOSD(void)
@@ -2547,6 +3105,9 @@
   Add(new cMenuEditStraItem(tr("Setup.OSD$Skin"),                   &skinIndex, numSkins, skinDescriptions));
   if (themes.NumThemes())
   Add(new cMenuEditStraItem(tr("Setup.OSD$Theme"),                  &themeIndex, themes.NumThemes(), themes.Descriptions()));
+#ifdef USE_WAREAGLEICON
+  Add(new cMenuEditBoolItem(tr("Setup.OSD$WarEagle icons"),         &data.WarEagleIcons));
+#endif /* WAREAGLEICON */
   Add(new cMenuEditPrcItem( tr("Setup.OSD$Left (%)"),               &data.OSDLeftP, 0.0, 0.5));
   Add(new cMenuEditPrcItem( tr("Setup.OSD$Top (%)"),                &data.OSDTopP, 0.0, 0.5));
   Add(new cMenuEditPrcItem( tr("Setup.OSD$Width (%)"),              &data.OSDWidthP, 0.5, 1.0));
@@ -2570,6 +3131,12 @@
   Add(new cMenuEditBoolItem(tr("Setup.OSD$Recording directories"),  &data.RecordingDirs));
   Add(new cMenuEditBoolItem(tr("Setup.OSD$Folders in timer menu"),  &data.FoldersInTimerMenu));
   Add(new cMenuEditBoolItem(tr("Setup.OSD$Number keys for characters"), &data.NumberKeysForChars));
+#ifdef USE_LIEMIEXT
+  Add(new cMenuEditBoolItem(tr("Setup.OSD$Main menu command position"), &data.MenuCmdPosition, tr("bottom"), tr("top")));
+#endif /* LIEMIEXT */
+#ifdef USE_VALIDINPUT
+  Add(new cMenuEditBoolItem(tr("Setup.OSD$Show valid input"),       &data.ShowValidInput));
+#endif /* VALIDINPUT */
   SetCurrent(Get(current));
   Display();
 }
@@ -2643,13 +3210,16 @@
 private:
 #ifdef USE_NOEPG
   const char *noEPGModes[2];
-#endif /* USE_NOEPG */
+#endif /* NOEPG */
   int originalNumLanguages;
   int numLanguages;
   void Setup(void);
 public:
   cMenuSetupEPG(void);
   virtual eOSState ProcessKey(eKeys Key);
+#ifdef USE_GRAPHTFT
+  virtual const char* MenuKind() { return "MenuSetupEpg"; }
+#endif /* GRAPHTFT */
   };
 
 cMenuSetupEPG::cMenuSetupEPG(void)
@@ -2669,13 +3239,16 @@
 #ifdef USE_NOEPG
   noEPGModes[0] = tr("blacklist");
   noEPGModes[1] = tr("whitelist");
-#endif /* USE_NOEPG */
+#endif /* NOEPG */
 
   Clear();
 
   Add(new cMenuEditIntItem( tr("Setup.EPG$EPG scan timeout (h)"),      &data.EPGScanTimeout));
   Add(new cMenuEditIntItem( tr("Setup.EPG$EPG bugfix level"),          &data.EPGBugfixLevel, 0, MAXEPGBUGFIXLEVEL));
   Add(new cMenuEditIntItem( tr("Setup.EPG$EPG linger time (min)"),     &data.EPGLinger, 0));
+#ifdef USE_LIEMIEXT
+  Add(new cMenuEditBoolItem(tr("Setup.EPG$Show progress bar"),         &data.ShowProgressBar));
+#endif /* LIEMIEXT */
   Add(new cMenuEditBoolItem(tr("Setup.EPG$Set system time"),           &data.SetSystemTime));
   if (data.SetSystemTime)
      Add(new cMenuEditTranItem(tr("Setup.EPG$Use time from transponder"), &data.TimeTransponder, &data.TimeSource));
@@ -2684,9 +3257,15 @@
   for (int i = 0; i < numLanguages; i++)
       // TRANSLATORS: note the singular!
       Add(new cMenuEditStraItem(tr("Setup.EPG$Preferred language"),    &data.EPGLanguages[i], I18nLanguages()->Size(), &I18nLanguages()->At(0)));
+#ifdef USE_DDEPGENTRY
+  Add(new cMenuEditIntItem(tr("Setup.EPG$Period for double EPG search(min)"), &data.DoubleEpgTimeDelta));
+  Add(new cMenuEditBoolItem(tr("Setup.EPG$extern double Epg entry"),   &data.DoubleEpgAction, "adjust", "delete"));
+  Add(new cMenuEditBoolItem(tr("Setup.EPG$Mix intern and extern EPG"), &data.MixEpgAction));
+  Add(new cMenuEditBoolItem(tr("Setup.EPG$Disable running VPS event"), &data.DisableVPS));
+#endif /* DDEPGENTRY */
 #ifdef USE_NOEPG
   Add(new cMenuEditStraItem(tr("Setup.EPG$Mode of noEPG-Patch"),       &data.noEPGMode, 2, noEPGModes));
-#endif /* USE_NOEPG */
+#endif /* NOEPG */
 
   SetCurrent(Get(current));
   Display();
@@ -2753,6 +3332,9 @@
 public:
   cMenuSetupDVB(void);
   virtual eOSState ProcessKey(eKeys Key);
+#ifdef USE_GRAPHTFT
+  virtual const char* MenuKind() { return "MenuSetupDvb"; }
+#endif /* GRAPHTFT */
   };
 
 cMenuSetupDVB::cMenuSetupDVB(void)
@@ -2783,12 +3365,18 @@
 
   Clear();
 
+#ifdef USE_CHANNELPROVIDE
+  Add(new cMenuEditBoolItem(tr("Setup.DVB$Use DVB receivers"),      &data.LocalChannelProvide));
+#endif /* CHANNELPROVIDE */
   Add(new cMenuEditIntItem( tr("Setup.DVB$Primary DVB interface"), &data.PrimaryDVB, 1, cDevice::NumDevices()));
   Add(new cMenuEditBoolItem(tr("Setup.DVB$Video format"),          &data.VideoFormat, "4:3", "16:9"));
   if (data.VideoFormat == 0)
      Add(new cMenuEditStraItem(tr("Setup.DVB$Video display format"), &data.VideoDisplayFormat, 3, videoDisplayFormatTexts));
   Add(new cMenuEditBoolItem(tr("Setup.DVB$Use Dolby Digital"),     &data.UseDolbyDigital));
   Add(new cMenuEditStraItem(tr("Setup.DVB$Update channels"),       &data.UpdateChannels, 6, updateChannelsTexts));
+#ifdef USE_CHANNELBIND
+  Add(new cMenuEditBoolItem(tr("Setup.DVB$channel binding by Rid"),&data.ChannelBindingByRid));
+#endif /* CHANNELBIND */
   Add(new cMenuEditIntItem( tr("Setup.DVB$Audio languages"),       &numAudioLanguages, 0, I18nLanguages()->Size()));
   for (int i = 0; i < numAudioLanguages; i++)
       Add(new cMenuEditStraItem(tr("Setup.DVB$Audio language"),    &data.AudioLanguages[i], I18nLanguages()->Size(), &I18nLanguages()->At(0)));
@@ -2801,6 +3389,9 @@
      Add(new cMenuEditIntItem( tr("Setup.DVB$Subtitle foreground transparency"), &data.SubtitleFgTransparency, 0, 9));
      Add(new cMenuEditIntItem( tr("Setup.DVB$Subtitle background transparency"), &data.SubtitleBgTransparency, 0, 10));
      }
+#ifdef USE_TTXTSUBS
+  Add(new cMenuEditBoolItem(tr("Setup.DVB$Enable teletext support"), &data.SupportTeletext));
+#endif /* TTXTSUBS */
 
   SetCurrent(Get(current));
   Display();
@@ -2882,6 +3473,9 @@
 public:
   cMenuSetupLNB(void);
   virtual eOSState ProcessKey(eKeys Key);
+#ifdef USE_GRAPHTFT
+  virtual const char* MenuKind() { return "MenuSetupLnb"; }
+#endif /* GRAPHTFT */
   };
 
 cMenuSetupLNB::cMenuSetupLNB(void)
@@ -2896,6 +3490,23 @@
 
   Clear();
 
+#ifdef USE_LNBSHARE
+  int numSatDevices = 0;
+  for (int i = 0; i < cDevice::NumDevices(); i++) {
+     	if (cDevice::GetDevice(i)->ProvidesSource(cSource::stSat)) numSatDevices++;
+  }     		
+  if (numSatDevices > 1) {
+  	 char tmp[40];
+     for (int i = 1; i <= cDevice::NumDevices(); i++) {
+     	if (cDevice::GetDevice(i - 1)->ProvidesSource(cSource::stSat)) {
+        	snprintf( tmp, 40, tr("Setup.LNB$DVB device %d uses LNB No."), i);
+        	Add(new cMenuEditIntItem( tmp, &data.CardUsesLnbNr[i - 1], 1, numSatDevices ));
+        }
+     }
+   }
+  Add(new cMenuEditBoolItem(tr("Setup.LNB$Log LNB usage"), &data.VerboseLNBlog));
+#endif /* LNBSHARE */
+  
   Add(new cMenuEditBoolItem(tr("Setup.LNB$Use DiSEqC"),               &data.DiSEqC));
   if (!data.DiSEqC) {
      Add(new cMenuEditIntItem( tr("Setup.LNB$SLOF (MHz)"),               &data.LnbSLOF));
@@ -2912,6 +3523,10 @@
   int oldDiSEqC = data.DiSEqC;
   eOSState state = cMenuSetupBase::ProcessKey(Key);
 
+#ifdef USE_LNBSHARE
+  if (Key == kOk) cDevice::SetLnbNr();
+#endif /* LNBSHARE */
+  
   if (Key != kNone && data.DiSEqC != oldDiSEqC)
      Setup();
   return state;
@@ -2962,6 +3577,9 @@
 public:
   cMenuSetupCAM(void);
   virtual eOSState ProcessKey(eKeys Key);
+#ifdef USE_GRAPHTFT
+  virtual const char* MenuKind() { return "MenuSetupCam"; }
+#endif /* GRAPHTFT */
   };
 
 cMenuSetupCAM::cMenuSetupCAM(void)
@@ -3038,12 +3656,49 @@
 private:
   const char *pauseKeyHandlingTexts[3];
   const char *delTimeshiftRecTexts[3];
+#ifdef USE_DVLVIDPREFER
+  void Set(void);
+  int tmpNVidPrefer,
+      tmpUseVidPrefer;
+#endif /* DVLVIDPREFER */
 public:
   cMenuSetupRecord(void);
+#ifdef USE_DVLVIDPREFER
+  eOSState ProcessKey(eKeys key);
+#endif /* DVLVIDPREFER */
   };
 
 cMenuSetupRecord::cMenuSetupRecord(void)
 {
+#ifdef USE_DVLVIDPREFER
+  Set();
+}
+
+eOSState cMenuSetupRecord::ProcessKey(eKeys key)
+{
+  eOSState s = cMenuSetupBase::ProcessKey(key);;
+
+  if (key != kNone) {
+    if (tmpNVidPrefer != data.nVidPrefer || tmpUseVidPrefer != data.UseVidPrefer) {
+      int cur = Current();
+
+      tmpNVidPrefer = data.nVidPrefer;
+      tmpUseVidPrefer = data.UseVidPrefer;
+
+      Clear();
+      Set();
+      SetCurrent(Get(cur));
+      Display();
+      cMenuSetupBase::ProcessKey(kNone);
+      return osContinue;
+      }
+   }
+   return s;
+}
+
+void cMenuSetupRecord::Set(void)
+{
+#endif /* DVLVIDPREFER */
   pauseKeyHandlingTexts[0] = tr("do not pause live video");
   pauseKeyHandlingTexts[1] = tr("confirm pause live video");
   pauseKeyHandlingTexts[2] = tr("pause live video");
@@ -3059,6 +3714,22 @@
   Add(new cMenuEditStraItem(tr("Setup.Recording$Pause key handling"),        &data.PauseKeyHandling, 3, pauseKeyHandlingTexts));
   Add(new cMenuEditIntItem( tr("Setup.Recording$Pause priority"),            &data.PausePriority, 0, MAXPRIORITY));
   Add(new cMenuEditIntItem( tr("Setup.Recording$Pause lifetime (d)"),        &data.PauseLifetime, 0, MAXLIFETIME));
+#ifdef USE_DVLVIDPREFER
+  tmpNVidPrefer = data.nVidPrefer;
+  tmpUseVidPrefer = data.UseVidPrefer;
+
+  Add(new cMenuEditBoolItem(tr("Setup.Recording$Video directory policy"),    &data.UseVidPrefer));
+  if (data.UseVidPrefer != 0) {
+     char tmp[ 64 ];
+     Add(new cMenuEditIntItem(tr("Setup.Recording$Number of video directories"), &data.nVidPrefer, 1, DVLVIDPREFER_MAX));
+     for (int zz = 0; zz < data.nVidPrefer; zz++) {
+         sprintf(tmp, tr("Setup.Recording$Video %d priority"), zz);
+         Add(new cMenuEditIntItem(tmp, &data.VidPreferPrio[ zz ], 0, 99));
+         sprintf(tmp, tr("Setup.Recording$Video %d min. free MB"), zz);
+         Add(new cMenuEditIntItem(tmp, &data.VidPreferSize[ zz ], -1, 99999));
+         }
+     }
+#endif /* DVLVIDPREFER */
   Add(new cMenuEditBoolItem(tr("Setup.Recording$Use episode name"),          &data.UseSubtitle));
   Add(new cMenuEditBoolItem(tr("Setup.Recording$Use VPS"),                   &data.UseVps));
   Add(new cMenuEditIntItem( tr("Setup.Recording$VPS margin (s)"),            &data.VpsMargin, 0));
@@ -3066,7 +3737,16 @@
   Add(new cMenuEditStrItem( tr("Setup.Recording$Name instant recording"),     data.NameInstantRecord, sizeof(data.NameInstantRecord)));
   Add(new cMenuEditIntItem( tr("Setup.Recording$Instant rec. time (min)"),   &data.InstantRecordTime, 1, MAXINSTANTRECTIME));
   Add(new cMenuEditIntItem( tr("Setup.Recording$Max. video file size (MB)"), &data.MaxVideoFileSize, MINVIDEOFILESIZE, MAXVIDEOFILESIZETS));
+#ifdef USE_HARDLINKCUTTER
+  Add(new cMenuEditIntItem( tr("Setup.Recording$Max. recording size (GB)"),  &data.MaxRecordingSize, MINRECORDINGSIZE, MAXRECORDINGSIZE));
+  Add(new cMenuEditBoolItem(tr("Setup.Recording$Hard Link Cutter"),          &data.HardLinkCutter));
+#endif /* HARDLINKCUTTER */
   Add(new cMenuEditBoolItem(tr("Setup.Recording$Split edited files"),        &data.SplitEditedFiles));
+#ifdef USE_LIEMIEXT
+  Add(new cMenuEditBoolItem(tr("Setup.Recording$Show date"),                 &data.ShowRecDate));
+  Add(new cMenuEditBoolItem(tr("Setup.Recording$Show time"),                 &data.ShowRecTime));
+  Add(new cMenuEditBoolItem(tr("Setup.Recording$Show length"),               &data.ShowRecLength));
+#endif /* LIEMIEXT */
   Add(new cMenuEditStraItem(tr("Setup.Recording$Delete timeshift recording"),&data.DelTimeshiftRec, 3, delTimeshiftRecTexts));
 }
 
@@ -3085,6 +3765,17 @@
   Add(new cMenuEditBoolItem(tr("Setup.Replay$Multi speed mode"), &data.MultiSpeedMode));
   Add(new cMenuEditBoolItem(tr("Setup.Replay$Show replay mode"), &data.ShowReplayMode));
   Add(new cMenuEditIntItem(tr("Setup.Replay$Resume ID"), &data.ResumeID, 0, 99));
+#ifdef USE_JUMPINGSECONDS
+  Add(new cMenuEditIntItem( tr("Setup.Recording$Jump Seconds"),              &data.JumpSeconds));
+  Add(new cMenuEditIntItem( tr("Setup.Recording$Jump Seconds Slow"),         &data.JumpSecondsSlow));
+  Add(new cMenuEditIntItem( tr("Setup.Recording$Jump Seconds (Repeat)"),     &data.JumpSecondsRepeat));
+#endif /* JUMPINGSECONDS */
+#ifdef USE_JUMPPLAY
+  Add(new cMenuEditBoolItem(tr("Setup.Replay$Jump&Play"), &data.JumpPlay));
+  Add(new cMenuEditBoolItem(tr("Setup.Replay$Play&Jump"), &data.PlayJump));
+  Add(new cMenuEditBoolItem(tr("Setup.Replay$Pause at last mark"), &data.PauseLastMark));
+  Add(new cMenuEditBoolItem(tr("Setup.Replay$Reload marks"), &data.ReloadMarks));
+#endif /* JUMPPLAY */
 }
 
 void cMenuSetupReplay::Store(void)
@@ -3097,13 +3788,48 @@
 // --- cMenuSetupMisc --------------------------------------------------------
 
 class cMenuSetupMisc : public cMenuSetupBase {
+#ifdef USE_VOLCTRL
+private:
+  const char *lrChannelGroupsTexts[3];
+  const char *lrForwardRewindTexts[3];
+  void Setup(void);
+#endif /* VOLCTRL */
 public:
   cMenuSetupMisc(void);
+#ifdef USE_VOLCTRL
+  virtual eOSState ProcessKey(eKeys Key);
+#endif /* VOLCTRL */
   };
 
 cMenuSetupMisc::cMenuSetupMisc(void)
 {
+#ifdef USE_VOLCTRL
+  lrChannelGroupsTexts[0] = tr("no");
+  lrChannelGroupsTexts[1] = tr("Setup.Miscellaneous$only in channelinfo");
+  lrChannelGroupsTexts[2] = tr("yes");
+  lrForwardRewindTexts[0] = tr("no");
+  lrForwardRewindTexts[1] = tr("Setup.Miscellaneous$only in progress display");
+  lrForwardRewindTexts[2] = tr("yes");
+#endif /* VOLCTRL */
   SetSection(tr("Miscellaneous"));
+#ifdef USE_VOLCTRL
+  Setup();
+}
+
+eOSState cMenuSetupMisc::ProcessKey(eKeys Key)
+{
+  int newLRVolumeControl = data.LRVolumeControl;
+  eOSState state = cMenuSetupBase::ProcessKey(Key);
+  if (Key != kNone && data.LRVolumeControl != newLRVolumeControl)
+     Setup();
+  return state;
+}
+
+void cMenuSetupMisc::Setup(void)
+{
+  int current = Current();
+  Clear();
+#endif /* VOLCTRL */
   Add(new cMenuEditIntItem( tr("Setup.Miscellaneous$Min. event timeout (min)"),   &data.MinEventTimeout));
   Add(new cMenuEditIntItem( tr("Setup.Miscellaneous$Min. user inactivity (min)"), &data.MinUserInactivity));
   Add(new cMenuEditIntItem( tr("Setup.Miscellaneous$SVDRP timeout (s)"),          &data.SVDRPTimeout));
@@ -3113,6 +3839,20 @@
   Add(new cMenuEditIntItem( tr("Setup.Miscellaneous$Initial volume"),             &data.InitialVolume, -1, 255, tr("Setup.Miscellaneous$as before")));
   Add(new cMenuEditBoolItem(tr("Setup.Miscellaneous$Channels wrap"),              &data.ChannelsWrap));
   Add(new cMenuEditBoolItem(tr("Setup.Miscellaneous$Emergency exit"),             &data.EmergencyExit));
+#ifdef USE_LIRCSETTINGS
+  Add(new cMenuEditIntItem( tr("Setup.Miscellaneous$Lirc repeat delay"),          &data.LircRepeatDelay, 0, 1000));
+  Add(new cMenuEditIntItem( tr("Setup.Miscellaneous$Lirc repeat freq"),           &data.LircRepeatFreq, 0, 1000));
+  Add(new cMenuEditIntItem( tr("Setup.Miscellaneous$Lirc repeat timeout"),        &data.LircRepeatTimeout, 0, 5000));
+#endif /* LIRCSETTINGS */
+#ifdef USE_VOLCTRL
+  Add(new cMenuEditBoolItem(tr("Setup.Miscellaneous$Volume ctrl with left/right"),     &data.LRVolumeControl));
+  if (data.LRVolumeControl) {
+     Add(new cMenuEditStraItem(tr("Setup.Miscellaneous$Channelgroups with left/right"),   &data.LRChannelGroups, 3, lrChannelGroupsTexts));
+     Add(new cMenuEditStraItem(tr("Setup.Miscellaneous$Search fwd/back with left/right"), &data.LRForwardRewind, 3, lrForwardRewindTexts));
+     }
+  SetCurrent(Get(current));
+  Display();
+#endif /* VOLCTRL */
 }
 
 // --- cMenuSetupPluginItem --------------------------------------------------
@@ -3137,6 +3877,9 @@
 public:
   cMenuSetupPlugins(void);
   virtual eOSState ProcessKey(eKeys Key);
+#ifdef USE_GRAPHTFT
+  virtual const char* MenuKind() { return "MenuSetupPlugins"; }
+#endif /* GRAPHTFT */
   };
 
 cMenuSetupPlugins::cMenuSetupPlugins(void)
@@ -3186,6 +3929,9 @@
 public:
   cMenuSetup(void);
   virtual eOSState ProcessKey(eKeys Key);
+#ifdef USE_GRAPHTFT
+  virtual const char* MenuKind() { return "MenuSetup"; }
+#endif /* GRAPHTFT */
   };
 
 cMenuSetup::cMenuSetup(void)
@@ -3282,26 +4028,58 @@
      menuXML = cString::sprintf("%s/setup/vdr-menu.xml", cPlugin::ConfigDirectory());
   subMenu.LoadXml(menuXML);
   nrDynamicMenuEntries = 0;
-#endif /* USE_SETUP */
+#endif /* SETUP */
 
   replaying = false;
   stopReplayItem = NULL;
   cancelEditingItem = NULL;
   stopRecordingItem = NULL;
   recordControlsState = 0;
+
+#ifdef USE_MENUORG
+  MenuOrgPatch::EnterRootMenu();
+#endif /* MENUORG */
   Set();
 
   // Initial submenus:
+#ifdef USE_MAINMENUHOOKS
+  cOsdMenu *menu = NULL;
+#endif /* MAINMENUHOOKS */
 
   switch (State) {
+#ifdef USE_MAINMENUHOOKS
+    case osSchedule:
+        if (!cPluginManager::CallFirstService("MainMenuHooksPatch-v1.0::osSchedule", &menu))
+            menu = new cMenuSchedule;
+        break;
+    case osChannels:
+        if (!cPluginManager::CallFirstService("MainMenuHooksPatch-v1.0::osChannels", &menu))
+            menu = new cMenuChannels;
+        break;
+    case osTimers:
+        if (!cPluginManager::CallFirstService("MainMenuHooksPatch-v1.0::osTimers", &menu))
+            menu = new cMenuTimers;
+        break;
+    case osRecordings:
+        if (!cPluginManager::CallFirstService("MainMenuHooksPatch-v1.0::osRecordings", &menu))
+            menu = new cMenuRecordings(NULL, 0, true);
+        break;
+    case osSetup:      menu = new cMenuSetup; break;
+    case osCommands:   menu = new cMenuCommands(tr("Commands"), &Commands); break;
+#else
     case osSchedule:   AddSubMenu(new cMenuSchedule); break;
     case osChannels:   AddSubMenu(new cMenuChannels); break;
     case osTimers:     AddSubMenu(new cMenuTimers); break;
     case osRecordings: AddSubMenu(new cMenuRecordings(NULL, 0, true)); break;
     case osSetup:      AddSubMenu(new cMenuSetup); break;
     case osCommands:   AddSubMenu(new cMenuCommands(tr("Commands"), &Commands)); break;
+#endif /* MAINMENUHOOKS */
     default: break;
     }
+#ifdef USE_MAINMENUHOOKS
+  if (menu)
+      AddSubMenu(menu);
+#endif /* MAINMENUHOOKS */
 }
 
 cOsdObject *cMenuMain::PluginOsdObject(void)
@@ -3321,6 +4099,30 @@
   SetTitle("VDR");
   SetHasHotkeys();
 
+#ifdef USE_MENUORG
+  if (MenuOrgPatch::IsCustomMenuAvailable()) {
+     MenuItemDefinitions* menuItems = MenuOrgPatch::MainMenuItems();
+     for (MenuItemDefinitions::iterator i = menuItems->begin(); i != menuItems->end(); i++) {
+        cOsdItem* osdItem = NULL;
+        if ((*i)->IsCustomOsdItem()) {
+           osdItem = (*i)->CustomOsdItem();
+           if (osdItem &&  !(*i)->IsSeparatorItem())
+              osdItem->SetText(hk(osdItem->Text()));
+           }
+        else if ((*i)->IsPluginItem()) {
+           const char *item = (*i)->PluginMenuEntry();
+           if (item)
+              osdItem = new cMenuPluginItem(hk(item), (*i)->PluginIndex());
+           }
+        if (osdItem) {
+           Add(osdItem);
+           if ((*i)->IsSelected())
+              SetCurrent(osdItem);
+           }
+        }
+     }
+  else {
+#endif /* MENUORG */
 #ifdef USE_SETUP
   stopReplayItem = NULL;
   cancelEditingItem = NULL;
@@ -3385,34 +4187,59 @@
      SetCurrent(Get(current));
      }
 
-#else /* NO USE_SETUP */
+#else /* NO SETUP */
+
   // Basic menu items:
 
+#ifdef USE_PINPLUGIN
+  if (!cStatus::MsgMenuItemProtected("Schedule", true))   Add(new cOsdItem(hk(tr("Schedule")),   osSchedule));
+  if (!cStatus::MsgMenuItemProtected("Channels", true))   Add(new cOsdItem(hk(tr("Channels")),   osChannels));
+  if (!cStatus::MsgMenuItemProtected("Timers", true))     Add(new cOsdItem(hk(tr("Timers")),     osTimers));
+  if (!cStatus::MsgMenuItemProtected("Recordings", true)) Add(new cOsdItem(hk(tr("Recordings")), osRecordings));
+#else
   Add(new cOsdItem(hk(tr("Schedule")),   osSchedule));
   Add(new cOsdItem(hk(tr("Channels")),   osChannels));
   Add(new cOsdItem(hk(tr("Timers")),     osTimers));
   Add(new cOsdItem(hk(tr("Recordings")), osRecordings));
+#endif /* PINPLUGIN */
 
   // Plugins:
 
   for (int i = 0; ; i++) {
       cPlugin *p = cPluginManager::GetPlugin(i);
       if (p) {
+#ifdef USE_PINPLUGIN
+         if (!cStatus::MsgPluginProtected(p, true)) {
+#endif /* PINPLUGIN */
          const char *item = p->MainMenuEntry();
          if (item)
             Add(new cMenuPluginItem(hk(item), i));
          }
+#ifdef USE_PINPLUGIN
+         }
+#endif /* PINPLUGIN */
       else
          break;
       }
 
   // More basic menu items:
 
+#ifdef USE_PINPLUGIN
+  if (!cStatus::MsgMenuItemProtected("Setup", true)) Add(new cOsdItem(hk(tr("Setup")), osSetup));
+#else
   Add(new cOsdItem(hk(tr("Setup")),      osSetup));
+#endif /* PINPLUGIN */
   if (Commands.Count())
+#ifdef USE_PINPLUGIN
+     if (!cStatus::MsgMenuItemProtected("Commands", true))
+#endif /* PINPLUGIN */
      Add(new cOsdItem(hk(tr("Commands")),  osCommands));
-#endif /* USE_SETUP */   
+#endif /* SETUP */   
 
+#ifdef USE_MENUORG
+  }
+#endif /* MENUORG */
+
   Update(true);
 
   Display();
@@ -3421,16 +4248,16 @@
 bool cMenuMain::Update(bool Force)
 {
   bool result = false;
+  
 #ifdef USE_SETUP
   cOsdItem *fMenu = NULL;
   if (Force && subMenu.isTopMenu()) {
      fMenu = First();
      nrDynamicMenuEntries = 0;
      }
- 
+
   if (subMenu.isTopMenu()) {
 #endif /* SETUP */
-
   // Title with disk usage:
   if (FreeDiskSpace.HasChanged(Force)) {
      //XXX -> skin function!!!
@@ -3443,7 +4270,7 @@
      SetTitle(cString::sprintf("%s  -  %s", tr("VDR"), subMenu.GetParentMenuTitel()));
      result = true;
      }
-#endif /* USE_SETUP */
+#endif /* SETUP */
 
   bool NewReplaying = cControl::Control() != NULL;
   if (Force || NewReplaying != replaying) {
@@ -3451,6 +4278,9 @@
      // Replay control:
      if (replaying && !stopReplayItem)
         // TRANSLATORS: note the leading blank!
+#ifdef USE_LIEMIEXT
+        if (Setup.MenuCmdPosition) Ins(stopReplayItem = new cOsdItem(tr(" Stop replaying"), osStopReplay)); else
+#endif /* LIEMIEXT */
         Add(stopReplayItem = new cOsdItem(tr(" Stop replaying"), osStopReplay));
      else if (stopReplayItem && !replaying) {
         Del(stopReplayItem->Index());
@@ -3465,6 +4295,9 @@
   bool CutterActive = cCutter::Active();
   if (CutterActive && !cancelEditingItem) {
      // TRANSLATORS: note the leading blank!
+#ifdef USE_LIEMIEXT
+     if (Setup.MenuCmdPosition) Ins(cancelEditingItem = new cOsdItem(tr(" Cancel editing"), osCancelEdit)); else
+#endif /* LIEMIEXT */
      Add(cancelEditingItem = new cOsdItem(tr(" Cancel editing"), osCancelEdit));
      result = true;
      }
@@ -3485,17 +4318,21 @@
      while ((s = cRecordControls::GetInstantId(s)) != NULL) {
            cOsdItem *item = new cOsdItem(osStopRecord);
            item->SetText(cString::sprintf("%s%s", tr(STOP_RECORDING), s));
+#ifdef USE_LIEMIEXT
+           if (Setup.MenuCmdPosition) Ins(item); else
+#endif /* LIEMIEXT */
            Add(item);
            if (!stopRecordingItem)
               stopRecordingItem = item;
            }
      result = true;
      }
+
 #ifdef USE_SETUP
   // adjust nrDynamicMenuEntries
   if (fMenu != NULL)
      nrDynamicMenuEntries = fMenu->Index();
-#endif /* USE_SETUP */
+#endif /* SETUP */
 
   return result;
 }
@@ -3507,13 +4344,53 @@
   eOSState state = cOsdMenu::ProcessKey(Key);
   HadSubMenu |= HasSubMenu();
 
+#ifdef USE_MAINMENUHOOKS
+  cOsdMenu *menu = NULL;
+#endif /* MAINMENUHOOKS */
+#ifdef USE_PINPLUGIN
+  cOsdItem* item = Get(Current());
+
+  if (item && item->Text() && state != osContinue && state != osUnknown && state != osBack)
+     if (cStatus::MsgMenuItemProtected(item->Text()))
+        return osContinue;
+#endif /* PINPLUGIN */
+
   switch (state) {
+#ifdef USE_MAINMENUHOOKS
+    case osSchedule:
+        if (!cPluginManager::CallFirstService("MainMenuHooksPatch-v1.0::osSchedule", &menu))
+            menu = new cMenuSchedule;
+        else
+            state = osContinue;
+        break;
+    case osChannels:
+        if (!cPluginManager::CallFirstService("MainMenuHooksPatch-v1.0::osChannels", &menu))
+            menu = new cMenuChannels;
+        else
+            state = osContinue;
+        break;
+    case osTimers:
+        if (!cPluginManager::CallFirstService("MainMenuHooksPatch-v1.0::osTimers", &menu))
+            menu = new cMenuTimers;
+        else
+            state = osContinue;
+        break;
+    case osRecordings:
+        if (!cPluginManager::CallFirstService("MainMenuHooksPatch-v1.0::osRecordings", &menu))
+            menu = new cMenuRecordings;
+        else
+            state = osContinue;
+        break;
+    case osSetup:      menu = new cMenuSetup; break;
+    case osCommands:   menu = new cMenuCommands(tr("Commands"), &Commands); break;
+#else
     case osSchedule:   return AddSubMenu(new cMenuSchedule);
     case osChannels:   return AddSubMenu(new cMenuChannels);
     case osTimers:     return AddSubMenu(new cMenuTimers);
     case osRecordings: return AddSubMenu(new cMenuRecordings);
     case osSetup:      return AddSubMenu(new cMenuSetup);
     case osCommands:   return AddSubMenu(new cMenuCommands(tr("Commands"), &Commands));
+#endif /* MAINMENUHOOKS */
     case osStopRecord: if (Interface->Confirm(tr("Stop recording?"))) {
                           cOsdItem *item = Get(Current());
                           if (item) {
@@ -3532,6 +4409,9 @@
                          if (item) {
                             cPlugin *p = cPluginManager::GetPlugin(item->PluginIndex());
                             if (p) {
+#ifdef USE_PINPLUGIN
+                               if (!cStatus::MsgPluginProtected(p)) {
+#endif /* PINPLUGIN */
                                cOsdObject *menu = p->MainMenuAction();
                                if (menu) {
                                   if (menu->IsMenu())
@@ -3541,11 +4421,51 @@
                                      return osPlugin;
                                      }
                                   }
+#ifdef USE_PINPLUGIN
                                }
+#endif /* PINPLUGIN */
                             }
+                         }
                          state = osEnd;
                        }
                        break;
+#ifdef USE_MENUORG
+    case osBack:       {
+                          if (MenuOrgPatch::IsCustomMenuAvailable())
+                          {
+                              bool leavingMenuSucceeded = MenuOrgPatch::LeaveSubMenu();
+                              Set();
+                              stopReplayItem = NULL;
+                              cancelEditingItem = NULL;
+                              stopRecordingItem = NULL;
+                              recordControlsState = 0;
+                              Update(true);
+                              Display();
+                              if (leavingMenuSucceeded)
+                                 return osContinue;
+                              else
+                                 return osEnd;
+                          }
+                       }
+                       break;
+    case osUser1:      {
+                          if (MenuOrgPatch::IsCustomMenuAvailable()) {
+                             MenuOrgPatch::EnterSubMenu(Get(Current()));
+                             Set();
+                             return osContinue;
+                          }
+                       }
+                       break;
+    case osUser2:      {
+                          if (MenuOrgPatch::IsCustomMenuAvailable()) {
+                             cOsdMenu* osdMenu = MenuOrgPatch::Execute(Get(Current()));
+                             if (osdMenu)
+                                return AddSubMenu(osdMenu);
+                             return osEnd;
+                          }
+                       }
+                       break;
+#endif /* MENUORG */
 #ifdef USE_SETUP
     case osBack:       {
                          int newCurrent = 0;
@@ -3557,7 +4477,7 @@
                             return osEnd;
                        }
                        break;
-#endif /* USE_SETUP */
+#endif /* SETUP */
     default: switch (Key) {
                case kRecord:
                case kRed:    if (!HadSubMenu)
@@ -3623,10 +4543,14 @@
                                 return osContinue;
                                 }
                              break;
-#endif /* USE_SETUP */
-             default:      break;
+#endif /* SETUP */
+               default:      break;
                }
     }
+#ifdef USE_MAINMENUHOOKS
+  if (menu)
+      return AddSubMenu(menu);
+#endif /* MAINMENUHOOKS */
   if (!HasSubMenu() && Update(HadSubMenu))
      Display();
   if (Key != kNone) {
@@ -3773,6 +4697,9 @@
   if (Direction) {
      while (Channel) {
            Channel = Direction > 0 ? Channels.Next(Channel) : Channels.Prev(Channel);
+#ifdef USE_PINPLUGIN
+        if (cStatus::MsgChannelProtected(0, Channel) == false)
+#endif /* PINPLUGIN */
            if (!Channel && Setup.ChannelsWrap)
               Channel = Direction > 0 ? Channels.First() : Channels.Last();
            if (Channel && !Channel->GroupSep() && cDevice::GetDevice(Channel, 0, true))
@@ -3833,6 +4760,13 @@
     case kLeft:
     case kRight|k_Repeat:
     case kRight:
+#ifdef USE_VOLCTRL
+         if (Setup.LRVolumeControl && !Setup.LRChannelGroups) {
+            cRemote::Put(NORMALKEY(Key) == kLeft ? kVolDn : kVolUp, true);
+            break;
+            }
+         // else fall through
+#endif /* VOLCTRL */
     case kNext|k_Repeat:
     case kNext:
     case kPrev|k_Repeat:
@@ -3992,6 +4926,17 @@
 eOSState cDisplayVolume::ProcessKey(eKeys Key)
 {
   switch (Key) {
+#ifdef USE_VOLCTRL
+    case kLeft|k_Repeat:
+    case kLeft:
+    case kRight|k_Repeat:
+    case kRight:
+         if (Setup.LRVolumeControl) {
+            cRemote::Put(NORMALKEY(Key) == kLeft ? kVolDn : kVolUp, true);
+            break;
+            }
+         // else fall through
+#endif /* VOLCTRL */
     case kVolUp|k_Repeat:
     case kVolUp:
     case kVolDn|k_Repeat:
@@ -4239,8 +5184,16 @@
 
 // --- cRecordControl --------------------------------------------------------
 
+#ifdef USE_ALTERNATECHANNEL
+cRecordControl::cRecordControl(cDevice *Device, cTimer *Timer, bool Pause, cChannel *Channel)
+#else
 cRecordControl::cRecordControl(cDevice *Device, cTimer *Timer, bool Pause)
+#endif /* ALTERNATECHANNEL */
 {
+#ifdef USE_DVLRECSCRIPTADDON
+  const cChannel *recChan = NULL;
+  char *chanName = NULL;
+#endif /* DVLRECSCRIPTADDON */
   // We're going to manipulate an event here, so we need to prevent
   // others from modifying any EPG data:
   cSchedulesLock SchedulesLock;
@@ -4285,12 +5238,29 @@
      return;
      }
 
+#ifdef USE_DVLRECSCRIPTADDON
+  if (timer)
+     if ((recChan = timer->Channel()) != NULL)
+        chanName = strdup(recChan->Name());
+  if (chanName != NULL) {
+     cRecordingUserCommand::InvokeCommand(RUC_BEFORERECORDING, fileName, chanName);
+     free(chanName);
+     }
+  else
+#endif /* DVLRECSCRIPTADDON */
   cRecordingUserCommand::InvokeCommand(RUC_BEFORERECORDING, fileName);
   isyslog("record %s", fileName);
   if (MakeDirs(fileName, true)) {
+#ifdef USE_ALTERNATECHANNEL
+     const cChannel *ch = Channel ? Channel : timer->Channel();
+     if (ch)
+        recorder = new cRecorder(fileName, ch, timer->Priority());
+     if (ch && device->AttachReceiver(recorder)) {
+#else
      const cChannel *ch = timer->Channel();
      recorder = new cRecorder(fileName, ch, timer->Priority());
      if (device->AttachReceiver(recorder)) {
+#endif /* ALTERNATECHANNEL */
         Recording.WriteInfo();
         cStatus::MsgRecording(device, Recording.Name(), Recording.FileName(), true);
         if (!Timer && !cReplayControl::LastReplayed()) // an instant recording, maybe from cRecordControls::PauseLiveVideo()
@@ -4299,7 +5269,12 @@
         return;
         }
      else
+#ifdef USE_ALTERNATECHANNEL
+        if (ch)
         DELETENULL(recorder);
+#else
+        DELETENULL(recorder);
+#endif /* ALTERNATECHANNEL */
      }
   if (!Timer) {
      Timers.Del(timer);
@@ -4347,12 +5322,26 @@
 void cRecordControl::Stop(bool ExecuteUserCommand)
 {
   if (timer) {
+#ifdef USE_DVLRECSCRIPTADDON
+     char *chanName = NULL;
+     const cChannel *recChan = NULL;
+
+     recChan = timer -> Channel();
+     if (recChan != NULL)
+        chanName = strdup(recChan -> Name());
+#endif /* DVLRECSCRIPTADDON */
      DELETENULL(recorder);
      timer->SetRecording(false);
      timer = NULL;
      cStatus::MsgRecording(device, NULL, fileName, false);
      if (ExecuteUserCommand)
+#ifdef USE_DVLRECSCRIPTADDON
+        cRecordingUserCommand::InvokeCommand(RUC_AFTERRECORDING, fileName, chanName);
+     if (chanName != NULL)
+        free(chanName);
+#else
         cRecordingUserCommand::InvokeCommand(RUC_AFTERRECORDING, fileName);
+#endif /* DVLRECSCRIPTADDON */
      }
 }
 
@@ -4398,8 +5387,32 @@
   if (channel) {
      int Priority = Timer ? Timer->Priority() : Pause ? Setup.PausePriority : Setup.DefaultPriority;
      cDevice *device = cDevice::GetDevice(channel, Priority, false);
+
+#ifdef USE_ALTERNATECHANNEL
+     if (!device && channel->AlternativeChannelID().Valid()) {// check for alternatives
+        dsyslog("prepare to use alternative channel for channel %d", channel->Number());
+        channel = Channels.GetByChannelID(channel->AlternativeChannelID());
+        device = cDevice::GetDevice(channel, Priority, false);
+        if (device)
+            dsyslog("use of alternative channel %d successfully initiated", channel->Number());
+        }
+#endif /* ALTERNATECHANNEL */
+
      if (device) {
         dsyslog("switching device %d to channel %d", device->DeviceNumber() + 1, channel->Number());
+#ifdef USE_LNBSHARE
+        cDevice *tmpDevice;
+        while ((tmpDevice = device->GetBadDevice(channel))) {
+          if (tmpDevice->Replaying() == false) {
+            Stop(tmpDevice);
+            if (tmpDevice->CardIndex() == tmpDevice->ActualDevice()->CardIndex())
+              tmpDevice->SwitchChannelForced(channel, true);
+            else
+              tmpDevice->SwitchChannelForced(channel, false);
+          } else
+                 tmpDevice->SwitchChannelForced(channel, false);
+           }
+#endif /* LNBSHARE */
         if (!device->SwitchChannel(channel, false)) {
            ShutdownHandler.RequestEmergencyExit();
            return false;
@@ -4407,7 +5420,14 @@
         if (!Timer || Timer->Matches()) {
            for (int i = 0; i < MAXRECORDCONTROLS; i++) {
                if (!RecordControls[i]) {
+#ifdef USE_ALTERNATECHANNEL
+                  RecordControls[i] = new cRecordControl(device, Timer, Pause, channel);
+#else
                   RecordControls[i] = new cRecordControl(device, Timer, Pause);
+#endif /* ALTERNATECHANNEL */
+#ifdef USE_PINPLUGIN
+                  cStatus::MsgRecordingFile(RecordControls[i]->FileName());
+#endif /* PINPLUGIN */
                   return RecordControls[i]->Process(time(NULL));
                   }
                }
@@ -4443,6 +5463,21 @@
       }
 }
 
+#ifdef USE_LNBSHARE
+void cRecordControls::Stop(cDevice *Device)
+{
+  ChangeState();
+  for (int i = 0; i < MAXRECORDCONTROLS; i++) {
+      if (RecordControls[i]) {
+         if (RecordControls[i]->Device() == Device) {
+            isyslog("stopping recording on DVB device %d due to higher priority", Device->CardIndex() + 1);
+            RecordControls[i]->Stop();
+            }
+         }
+      }
+}
+#endif /* LNBSHARE */
+
 bool cRecordControls::PauseLiveVideo(void)
 {
   Skins.Message(mtStatus, tr("Pausing live video..."));
@@ -4546,12 +5581,22 @@
 
 // --- cReplayControl --------------------------------------------------------
 
+#ifdef USE_LIEMIEXT
+#define REPLAYCONTROLSKIPLIMIT   9    // s
+#define REPLAYCONTROLSKIPSECONDS 90   // s
+#define REPLAYCONTROLSKIPTIMEOUT 5000 // ms
+#endif /* LIEMIEXT */
+
 cReplayControl *cReplayControl::currentReplayControl = NULL;
 char *cReplayControl::fileName = NULL;
 char *cReplayControl::title = NULL;
 
 cReplayControl::cReplayControl(void)
+#ifdef USE_JUMPPLAY
+:cDvbPlayerControl(fileName), marks(fileName)
+#else
 :cDvbPlayerControl(fileName)
+#endif /* JUMPPLAY */
 {
   currentReplayControl = this;
   displayReplay = NULL;
@@ -4559,11 +5604,18 @@
   lastCurrent = lastTotal = -1;
   lastPlay = lastForward = false;
   lastSpeed = -2; // an invalid value
+#ifdef USE_LIEMIEXT
+  lastSkipKey = kNone;
+  lastSkipSeconds = REPLAYCONTROLSKIPSECONDS;
+  lastSkipTimeout.Set(0);
+#endif /* LIEMIEXT */
   timeoutShow = 0;
   timeSearchActive = false;
   cRecording Recording(fileName);
   cStatus::MsgReplaying(this, Recording.Name(), Recording.FileName(), true);
+#ifndef USE_JUMPPLAY
   marks.Load(fileName, Recording.FramesPerSecond(), Recording.IsPesRecording());
+#endif /* JUMPPLAY */
   SetTrackDescriptions(false);
 }
 
@@ -4823,8 +5875,16 @@
         ShowTimed(2);
         bool Play, Forward;
         int Speed;
+#ifdef USE_JUMPPLAY
+        if (GetReplayMode(Play, Forward, Speed) && !Play) {
+#else
         if (GetReplayMode(Play, Forward, Speed) && !Play)
+#endif /* JUMPPLAY */
            Goto(Current, true);
+#ifdef USE_JUMPPLAY
+           displayFrames = true;
+           }
+#endif /* JUMPPLAY */
         }
      marks.Save();
      }
@@ -4837,8 +5897,22 @@
      if (GetIndex(Current, Total)) {
         cMark *m = Forward ? marks.GetNext(Current) : marks.GetPrev(Current);
         if (m) {
+#ifdef USE_JUMPPLAY
+           bool Play2, Forward2;
+           int Speed;
+           if (Setup.JumpPlay && GetReplayMode(Play2, Forward2, Speed) &&
+               Play2 && Forward && m->position < Total - SecondsToFrames(3, FramesPerSecond())) {
+              Goto(m->position);
+              Play();
+              }
+           else {
+              Goto(m->position, true);
+              displayFrames = true;
+              }
+#else
            Goto(m->position, true);
            displayFrames = true;
+#endif /* JUMPPLAY */
            }
         }
      }
@@ -4893,7 +5967,11 @@
      if (!m)
         m = marks.GetNext(Current);
      if (m) {
+#ifdef USE_JUMPPLAY
+        if ((m->Index() & 0x01) != 0 && !Setup.PlayJump)
+#else
         if ((m->Index() & 0x01) != 0)
+#endif /* JUMPPLAY */
            m = marks.Next(m);
         if (m) {
            Goto(m->position - SecondsToFrames(3, FramesPerSecond()));
@@ -4915,6 +5993,9 @@
 {
   if (!Active())
      return osEnd;
+#ifdef USE_JUMPPLAY
+  marks.Reload();
+#endif /* JUMPPLAY */
   if (visible) {
      if (timeoutShow && time(NULL) > timeoutShow) {
         Hide();
@@ -4933,6 +6014,22 @@
      return osContinue;
      }
   bool DoShowMode = true;
+#ifdef USE_VOLCTRL
+  if (Setup.LRVolumeControl && (!Setup.LRForwardRewind || (Setup.LRForwardRewind == 1 && !visible))) {
+     switch (Key) {
+       // Left/Right volume control
+       case kLeft|k_Repeat:
+       case kLeft:
+       case kRight|k_Repeat:
+       case kRight:
+            cRemote::Put(NORMALKEY(Key) == kLeft ? kVolDn : kVolUp, true);
+            return osContinue;
+            break;
+       default:
+            break;
+       }
+     }
+#endif /* VOLCTRL */
   switch (Key) {
     // Positioning:
     case kPlay:
@@ -4950,25 +6047,73 @@
     case kFastFwd:
     case kRight:   Forward(); break;
     case kRed:     TimeSearch(); break;
+#ifdef USE_JUMPINGSECONDS
+    case kGreen|k_Repeat: 
+                   SkipSeconds(-(Setup.JumpSecondsRepeat)); break;
+    case kGreen:   SkipSeconds(-(Setup.JumpSeconds)); break;
+    case k1|k_Repeat:
+    case k1:       SkipSeconds(-Setup.JumpSecondsSlow); break;
+    case k3|k_Repeat:
+    case k3:       SkipSeconds( Setup.JumpSecondsSlow); break;
+    case kYellow|k_Repeat: 
+                   SkipSeconds(Setup.JumpSecondsRepeat); break;
+    case kYellow:  SkipSeconds(Setup.JumpSeconds); break;
+#else
     case kGreen|k_Repeat:
     case kGreen:   SkipSeconds(-60); break;
     case kYellow|k_Repeat:
     case kYellow:  SkipSeconds( 60); break;
+#endif /* JUMPINGSECONDS */
+#ifdef USE_LIEMIEXT
+#ifndef USE_JUMPINGSECONDS
+    case k1|k_Repeat:
+    case k1:       SkipSeconds(-20); break;
+    case k3|k_Repeat:
+    case k3:       SkipSeconds( 20); break;
+#endif /* JUMPINGSECONDS */
+    case kPrev|k_Repeat:
+    case kPrev:    if (lastSkipTimeout.TimedOut()) {
+                      lastSkipSeconds = REPLAYCONTROLSKIPSECONDS;
+                      lastSkipKey = kPrev;
+                   }
+                   else if (RAWKEY(lastSkipKey) != kPrev && lastSkipSeconds > (2 * REPLAYCONTROLSKIPLIMIT)) {
+                      lastSkipSeconds /= 2;
+                      lastSkipKey = kNone;
+                   }
+                   lastSkipTimeout.Set(REPLAYCONTROLSKIPTIMEOUT);
+                   SkipSeconds(-lastSkipSeconds); break;
+    case kNext|k_Repeat:
+    case kNext:    if (lastSkipTimeout.TimedOut()) {
+                      lastSkipSeconds = REPLAYCONTROLSKIPSECONDS;
+                      lastSkipKey = kNext;	
+                   }
+                   else if (RAWKEY(lastSkipKey) != kNext && lastSkipSeconds > (2 * REPLAYCONTROLSKIPLIMIT)) {
+                      lastSkipSeconds /= 2;
+                      lastSkipKey = kNone;
+                   }
+                   lastSkipTimeout.Set(REPLAYCONTROLSKIPTIMEOUT);
+                   SkipSeconds(lastSkipSeconds); break;
+#endif /* LIEMIEXT */
     case kStop:
     case kBlue:    Hide();
                    Stop();
                    return osEnd;
+
     default: {
       DoShowMode = false;
       switch (Key) {
         // Editing:
         case kMarkToggle:      MarkToggle(); break;
+#ifndef USE_LIEMIEXT
         case kPrev|k_Repeat:
         case kPrev:
+#endif /* LIEMIEXT */
         case kMarkJumpBack|k_Repeat:
         case kMarkJumpBack:    MarkJump(false); break;
+#ifndef USE_LIEMIEXT
         case kNext|k_Repeat:
         case kNext:
+#endif /* LIEMIEXT */
         case kMarkJumpForward|k_Repeat:
         case kMarkJumpForward: MarkJump(true); break;
         case kMarkMoveBack|k_Repeat:
Index: cutter.c
===================================================================
--- cutter.c	(revision 15412)
+++ cutter.c	(revision 15413)
@@ -14,6 +14,19 @@
 
 // --- cCuttingThread --------------------------------------------------------
 
+#ifdef USE_CUTTERLIMIT
+#ifndef CUTTER_MAX_BANDWIDTH
+#define CUTTER_MAX_BANDWIDTH MEGABYTE(10) // 10 MB/s
+#endif
+#ifndef CUTTER_REL_BANDWIDTH
+#define CUTTER_REL_BANDWIDTH 75 // %
+#endif
+#ifndef CUTTER_PRIORITY
+#define CUTTER_PRIORITY sched_get_priority_min(SCHED_OTHER)
+#endif
+#define CUTTER_TIMESLICE   100   // ms
+#endif /* CUTTERLIMIT */
+
 class cCuttingThread : public cThread {
 private:
   const char *error;
@@ -66,6 +79,22 @@
 
 void cCuttingThread::Action(void)
 {
+#ifdef USE_CUTTERLIMIT
+#ifdef USE_HARDLINKCUTTER
+  if (!Setup.HardLinkCutter)
+#endif /* HARDLINKCUTTER */
+  {
+    sched_param tmp;
+    tmp.sched_priority = CUTTER_PRIORITY;
+    if(!pthread_setschedparam(pthread_self(), SCHED_OTHER, &tmp))
+      printf("cCuttingThread::Action: cant set priority\n");
+  }
+
+  int bytes = 0;
+  int __attribute__((unused)) burst_size = CUTTER_MAX_BANDWIDTH * CUTTER_TIMESLICE / 1000; // max bytes/timeslice
+  cTimeMs __attribute__((unused)) t;
+#endif /* CUTTERLIMIT */
+
   cMark *Mark = fromMarks.First();
   if (Mark) {
      fromFile = fromFileName->Open();
@@ -77,6 +106,9 @@
      Mark = fromMarks.Next(Mark);
      off_t FileSize = 0;
      int CurrentFileNumber = 0;
+#ifdef USE_HARDLINKCUTTER
+     bool SkipThisSourceFile = false;
+#endif /* HARDLINKCUTTER */
      int LastIFrame = 0;
      toMarks.Add(0);
      toMarks.Save();
@@ -95,12 +127,101 @@
 
            // Read one frame:
 
+#ifdef USE_HARDLINKCUTTER
+           if (!fromIndex->Get(Index++, &FileNumber, &FileOffset, &Independent, &Length)) {
+              // Error, unless we're past last cut-in and there's no cut-out
+              if (Mark || LastMark)
+                 error = "index";
+              break;
+              }
+
+           if (FileNumber != CurrentFileNumber) {
+              fromFile = fromFileName->SetOffset(FileNumber, FileOffset);
+              fromFile->SetReadAhead(MEGABYTE(20));
+              CurrentFileNumber = FileNumber;
+              if (SkipThisSourceFile) {
+                 // At end of fast forward: Always skip to next file
+                 toFile = toFileName->NextFile();
+                 if (!toFile) {
+                    error = "toFile 4";
+                    break;
+                    }
+                 FileSize = 0;
+                 SkipThisSourceFile = false;
+                 }
+
+
+              if (Setup.HardLinkCutter && FileOffset == 0) {
+                 // We are at the beginning of a new source file.
+                 // Do we need to copy the whole file?
+
+                 // if !Mark && LastMark, then we're past the last cut-out and continue to next I-frame
+                 // if !Mark && !LastMark, then there's just a cut-in, but no cut-out
+                 // if Mark, then we're between a cut-in and a cut-out
+
+                 uint16_t MarkFileNumber;
+                 off_t MarkFileOffset;
+                 // Get file number of next cut mark
+                 if (!Mark && !LastMark
+                     || Mark
+                        && fromIndex->Get(Mark->position, &MarkFileNumber, &MarkFileOffset)
+                        && (MarkFileNumber != CurrentFileNumber)) {
+                    // The current source file will be copied completely.
+                    // Start new output file unless we did that already
+                    if (FileSize != 0) {
+                       toFile = toFileName->NextFile();
+                       if (!toFile) {
+                          error = "toFile 3";
+                          break;
+                          }
+                       FileSize = 0;
+                       }
+
+                    // Safety check that file has zero size
+                    struct stat buf;
+                    if (stat(toFileName->Name(), &buf) == 0) {
+                       if (buf.st_size != 0) {
+                          esyslog("cCuttingThread: File %s exists and has nonzero size", toFileName->Name());
+                          error = "nonzero file exist";
+                          break;
+                          }
+                       }
+                    else if (errno != ENOENT) {
+                       esyslog("cCuttingThread: stat failed on %s", toFileName->Name());
+                       error = "stat";
+                       break;
+                       }
+
+                    // Clean the existing 0-byte file
+                    toFileName->Close();
+                    cString ActualToFileName(ReadLink(toFileName->Name()), true);
+                    unlink(ActualToFileName);
+                    unlink(toFileName->Name());
+
+                    // Try to create a hard link
+                    if (HardLinkVideoFile(fromFileName->Name(), toFileName->Name())) {
+                       // Success. Skip all data transfer for this file
+                       SkipThisSourceFile = true;
+                       cutIn = false;
+                       toFile = NULL; // was deleted by toFileName->Close()
+                       }
+                    else {
+                       // Fallback: Re-open the file if necessary
+                       toFile = toFileName->Open();
+                       }
+                    }
+                 }
+              }
+
+           if (!SkipThisSourceFile) {
+#else
            if (fromIndex->Get(Index++, &FileNumber, &FileOffset, &Independent, &Length)) {
               if (FileNumber != CurrentFileNumber) {
                  fromFile = fromFileName->SetOffset(FileNumber, FileOffset);
                  fromFile->SetReadAhead(MEGABYTE(20));
                  CurrentFileNumber = FileNumber;
                  }
+#endif /* HARDLINKCUTTER */
               if (fromFile) {
                  int len = ReadFrame(fromFile, buffer,  Length, sizeof(buffer));
                  if (len < 0) {
@@ -117,19 +238,25 @@
                  break;
                  }
               }
+#ifndef USE_HARDLINKCUTTER
            else {
               // Error, unless we're past the last cut-in and there's no cut-out
               if (Mark || LastMark)
                  error = "index";
               break;
               }
+#endif /* HARDLINKCUTTER */
 
            // Write one frame:
 
            if (Independent) { // every file shall start with an independent frame
               if (LastMark) // edited version shall end before next I-frame
                  break;
+#ifdef USE_HARDLINKCUTTER
+              if (!SkipThisSourceFile && FileSize > toFileName->MaxFileSize()) {
+#else
               if (FileSize > maxVideoFileSize) {
+#endif /* HARDLINKCUTTER */
                  toFile = toFileName->NextFile();
                  if (!toFile) {
                     error = "toFile 1";
@@ -139,7 +266,11 @@
                  }
               LastIFrame = 0;
 
+#ifdef USE_HARDLINKCUTTER
+              if (!SkipThisSourceFile && cutIn) {
+#else
               if (cutIn) {
+#endif /* HARDLINKCUTTER */
                  if (isPesRecording)
                     cRemux::SetBrokenLink(buffer, Length);
                  else
@@ -147,7 +278,11 @@
                  cutIn = false;
                  }
               }
+#ifdef USE_HARDLINKCUTTER
+           if (!SkipThisSourceFile && toFile->Write(buffer, Length) < 0) {
+#else
            if (toFile->Write(buffer, Length) < 0) {
+#endif /* HARDLINKCUTTER */
               error = "safe_write";
               break;
               }
@@ -182,9 +317,46 @@
                     }
                  }
               else
+#ifdef USE_HARDLINKCUTTER
+                 LastMark = true; // After last cut-out: Write on until next I-frame, then exit
+#else
                  LastMark = true;
+#endif /* HARDLINKCUTTER */
               }
+
+#ifdef USE_CUTTERLIMIT
+#ifdef USE_HARDLINKCUTTER
+           if (!Setup.HardLinkCutter) {
+#endif /* HARDLINKCUTTER */
+           bytes += Length;
+           if(bytes >= burst_size) {
+             int elapsed = t.Elapsed();
+             int sleep = 0;
+
+#if CUTTER_REL_BANDWIDTH > 0 &&  CUTTER_REL_BANDWIDTH < 100
+             // stay under max. relative bandwidth
+
+             sleep = (elapsed * 100 / CUTTER_REL_BANDWIDTH) - elapsed;
+             //if(sleep<=0 && elapsed<=2) sleep = 1;
+             //if(sleep) esyslog("cutter: relative bandwidth limit, sleep %d ms (chunk %dk / %dms)", sleep, burst_size/1024, CUTTER_TIMESLICE);
+#endif
+             // stay under max. absolute bandwidth
+             if(elapsed < CUTTER_TIMESLICE) {
+               sleep = max(CUTTER_TIMESLICE - elapsed, sleep);
+               //if(sleep) esyslog("cutter: absolute bandwidth limit, sleep %d ms (chunk %dk / %dms)", sleep, burst_size/1024, CUTTER_TIMESLICE);
+             }
+
+             if(sleep>0)
+               cCondWait::SleepMs(sleep);
+             t.Set();
+             bytes = 0;
            }
+#ifdef USE_HARDLINKCUTTER
+              }
+#endif /* HARDLINKCUTTER */
+#endif /* CUTTERLIMIT */
+
+           }
      Recordings.TouchUpdate();
      }
   else
@@ -206,6 +378,12 @@
      error = false;
      ended = false;
      cRecording Recording(FileName);
+#ifdef USE_CUTTIME
+     cMarks FromMarks;
+     FromMarks.Load(FileName);
+     cMark *First=FromMarks.First();
+     if (First) Recording.SetStartTime(Recording.start+(int(First->position/Recording.FramesPerSecond()+30)/60)*60);
+#endif /* CUTTIME */
      const char *evn = Recording.PrefixFileName('%');
      if (evn && RemoveVideoFile(evn) && MakeDirs(evn, true)) {
         // XXX this can be removed once RenameVideoFile() follows symlinks (see videodir.c)
@@ -261,6 +439,7 @@
      editedVersionName = NULL;
      ended = true;
      }
+
   return false;
 }
 
Index: menu.h
===================================================================
--- menu.h	(revision 15412)
+++ menu.h	(revision 15413)
@@ -20,7 +20,7 @@
 #include "skins.h"
 #ifdef USE_SETUP
 #include "submenu.h"
-#endif /* USE_SETUP */
+#endif /* SETUP */
 
 class cMenuText : public cOsdMenu {
 private:
@@ -54,6 +54,9 @@
   cMenuFolder(const char *Title, cNestedItemList *NestedItemList, const char *Path = NULL);
   cString GetFolder(void);
   virtual eOSState ProcessKey(eKeys Key);
+#ifdef USE_GRAPHTFT
+  virtual const char* MenuKind() { return "MenuText"; }
+#endif /* GRAPHTFT */
   };
 
 class cMenuCommands : public cOsdMenu {
@@ -87,6 +90,9 @@
   cMenuEditTimer(cTimer *Timer, bool New = false);
   virtual ~cMenuEditTimer();
   virtual eOSState ProcessKey(eKeys Key);
+#ifdef USE_GRAPHTFT
+  virtual const char* MenuKind() { return "MenuTimerEdit"; }
+#endif /* GRAPHTFT */
   };
 
 class cMenuEvent : public cOsdMenu {
@@ -96,6 +102,9 @@
   cMenuEvent(const cEvent *Event, bool CanSwitch = false, bool Buttons = false);
   virtual void Display(void);
   virtual eOSState ProcessKey(eKeys Key);
+#ifdef USE_GRAPHTFT
+  virtual const char* MenuKind() { return "MenuEvent"; }
+#endif /* GRAPHTFT */
   };
 
 #ifdef REELVDR
@@ -115,31 +124,40 @@
 #endif /* REELVDR*/
 
 class cMenuMain : public cOsdMenu {
+#ifdef REELVDR
+protected:
+  cMenuMain(const char *Title):cOsdMenu(Title){}; // Allow custom constructor
+#else
 private:
+#endif
 #ifdef USE_SETUP
   int    nrDynamicMenuEntries;
-#endif /* USE_SETUP */
+#endif /* SETUP */
   bool replaying;
   cOsdItem *stopReplayItem;
   cOsdItem *cancelEditingItem;
   cOsdItem *stopRecordingItem;
   int recordControlsState;
   static cOsdObject *pluginOsdObject;
-#ifdef REELVDR
-  static void SetPluginOsdObject(cOsdObject *PluginOsdObject) { pluginOsdObject = PluginOsdObject ; }
-#endif /* REELVDR */
 #ifdef USE_SETUP
   void Set(int current=0);
   bool Update(bool Force = false);
   cSubMenu subMenu;
 #else
-   void Set(void);
-   bool Update(bool Force = false);
-#endif /* USE_SETUP */
+  void Set(void);
+  bool Update(bool Force = false);
+#endif /* SETUP */
 public:
   cMenuMain(eOSState State = osUnknown);
   virtual eOSState ProcessKey(eKeys Key);
   static cOsdObject *PluginOsdObject(void);
+#ifdef REELVDR
+  static void SetPluginOsdObject(cOsdObject *PluginOsdObject)
+      { pluginOsdObject = PluginOsdObject ; }
+#endif /* REELVDR */
+#ifdef USE_GRAPHTFT
+  virtual const char* MenuKind() { return "MenuMain"; }
+#endif /* GRAPHTFT */
   };
 
 class cDisplayChannel : public cOsdObject {
@@ -235,6 +253,9 @@
   eOSState Delete(void);
   eOSState Info(void);
   eOSState Commands(eKeys Key = kNone);
+#ifdef USE_LIEMIEXT
+  eOSState Rename(void);
+#endif /* LIEMIEXT */
 protected:
   cRecording *GetRecording(cMenuRecordingItem *Item);
 public:
@@ -253,7 +274,11 @@
   char *fileName;
   bool GetEvent(void);
 public:
+#ifdef USE_ALTERNATECHANNEL
+  cRecordControl(cDevice *Device, cTimer *Timer = NULL, bool Pause = false, cChannel *Channel = NULL);
+#else
   cRecordControl(cDevice *Device, cTimer *Timer = NULL, bool Pause = false);
+#endif /* ALTERNATECHANNEL */
   virtual ~cRecordControl();
   bool Process(time_t t);
   cDevice *Device(void) { return device; }
@@ -270,6 +295,9 @@
 public:
   static bool Start(cTimer *Timer = NULL, bool Pause = false);
   static void Stop(const char *InstantId);
+#ifdef USE_LNBSHARE
+  static void Stop(cDevice *Device);   // LNB Sharing
+#endif /* LNBSHARE */
   static bool PauseLiveVideo(void);
 #ifdef REELVDR
   static const char *GetInstantId(const char *LastInstantId, bool LIFO=false);
@@ -288,11 +316,20 @@
 class cReplayControl : public cDvbPlayerControl {
 private:
   cSkinDisplayReplay *displayReplay;
+#ifdef USE_JUMPPLAY
+  cMarksReload marks;
+#else
   cMarks marks;
+#endif /* JUMPPLAY */
   bool visible, modeOnly, shown, displayFrames;
   int lastCurrent, lastTotal;
   bool lastPlay, lastForward;
   int lastSpeed;
+#ifdef USE_LIEMIEXT
+  int lastSkipSeconds;
+  eKeys lastSkipKey;
+  cTimeMs lastSkipTimeout;
+#endif /* LIEMIEXT */
   time_t timeoutShow;
   bool timeSearchActive, timeSearchHide;
   int timeSearchTime, timeSearchPos;
Index: osd.c
===================================================================
--- osd.c	(revision 15412)
+++ osd.c	(revision 15413)
@@ -743,6 +743,9 @@
 int cOsd::osdWidth = 0;
 int cOsd::osdHeight = 0;
 cVector<cOsd *> cOsd::Osds;
+#ifdef USE_PINPLUGIN
+bool cOsd::pinValid = false;
+#endif /* PINPLUGIN */
 
 cOsd::cOsd(int Left, int Top, uint Level)
 {
@@ -753,6 +756,9 @@
   width = height = 0;
   level = Level;
   active = false;
+#ifdef USE_YAEPG
+  vidWin.bpp = 0;
+#endif /* YAEPG */
   for (int i = 0; i < Osds.Size(); i++) {
       if (Osds[i]->level > level) {
          Osds.Insert(this, i);
Index: osd.h
===================================================================
--- osd.h	(revision 15412)
+++ osd.h	(revision 15413)
@@ -287,6 +287,10 @@
 #endif /* REELVDR */
   uint level;
   bool active;
+#ifdef USE_YAEPG
+public:
+  tArea vidWin;
+#endif /* YAEPG */
 protected:
   cOsd(int Left, int Top, uint Level);
        ///< Initializes the OSD with the given coordinates.
@@ -429,6 +433,9 @@
 #endif /* REELVDR */
   virtual void Flush(void);
        ///< Actually commits all data to the OSD hardware.
+#ifdef USE_PINPLUGIN
+  static bool pinValid;
+#endif /* PINPLUGIN */
   };
 
 class cOsdProvider {
Index: svdrp.c
===================================================================
--- svdrp.c	(revision 15412)
+++ svdrp.c	(revision 15413)
@@ -304,6 +304,10 @@
   "REMO [ on | off ]\n"
   "    Turns the remote control on or off. Without a parameter, the current\n"
   "    status of the remote control is reported.",
+#ifdef USE_LIEMIEXT
+  "RENR <number> <new name>\n"
+  "    Rename recording. Number must be the Number as returned by LSTR command.",
+#endif /* LIEMIEXT */
   "SCAN\n"
   "    Forces an EPG scan. If this is a single DVB device system, the scan\n"
   "    will be done on the primary device unless it is currently recording.",
@@ -1493,6 +1497,38 @@
   Reply(250, "EPG scan triggered");
 }
 
+#ifdef USE_LIEMIEXT
+void cSVDRP::CmdRENR(const char *Option)
+{
+  bool recordings = Recordings.Update(true);
+  if (recordings) {
+     if (*Option) {
+        char *tail;
+        int n = strtol(Option, &tail, 10);
+        cRecording *recording = Recordings.Get(n - 1);
+        if (recording && tail && tail != Option) {
+           char *oldName = strdup(recording->Name());
+           tail = skipspace(tail);
+           if (recording->Rename(tail)) {
+              Reply(250, "Renamed \"%s\" to \"%s\"", oldName, recording->Name());
+              Recordings.ChangeState();
+              Recordings.TouchUpdate();
+              }
+           else
+              Reply(501, "Renaming \"%s\" to \"%s\" failed", oldName, tail);
+           free(oldName);
+           }
+        else
+          Reply(501, "Recording not found or wrong syntax");
+        }
+     else
+        Reply(501, "Missing Input settings");
+     }
+  else
+     Reply(550, "No recordings available");
+}
+#endif /* LIEMIEXT */
+
 void cSVDRP::CmdSTAT(const char *Option)
 {
   if (*Option) {
@@ -1608,6 +1644,9 @@
   else if (CMD("PLUG"))  CmdPLUG(s);
   else if (CMD("PUTE"))  CmdPUTE(s);
   else if (CMD("REMO"))  CmdREMO(s);
+#ifdef USE_LIEMIEXT
+  else if (CMD("RENR"))  CmdRENR(s);
+#endif /* LIEMIEXT */
   else if (CMD("SCAN"))  CmdSCAN(s);
   else if (CMD("STAT"))  CmdSTAT(s);
   else if (CMD("UPDT"))  CmdUPDT(s);
Index: timers.c
===================================================================
--- timers.c	(revision 15412)
+++ timers.c	(revision 15413)
@@ -49,6 +49,9 @@
      stop -= 2400;
   priority = Pause ? Setup.PausePriority : Setup.DefaultPriority;
   lifetime = Pause ? Setup.PauseLifetime : Setup.DefaultLifetime;
+#ifdef USE_PINPLUGIN
+  fskProtection = 0;
+#endif /* PINPLUGIN */
   *file = 0;
   aux = NULL;
   event = NULL;
@@ -87,6 +90,9 @@
      stop -= 2400;
   priority = Setup.DefaultPriority;
   lifetime = Setup.DefaultLifetime;
+#ifdef USE_PINPLUGIN
+  fskProtection = 0;
+#endif /* PINPLUGIN */
   *file = 0;
   const char *Title = Event->Title();
   if (!isempty(Title))
@@ -98,6 +104,9 @@
      }
   aux = NULL;
   event = NULL; // let SetEvent() be called to get a log message
+#ifdef USE_PINPLUGIN
+  cStatus::MsgTimerCreation(this, Event);
+#endif /* PINPLUGIN */
 }
 
 cTimer::cTimer(const cTimer &Timer)
@@ -132,6 +141,9 @@
      stop         = Timer.stop;
      priority     = Timer.priority;
      lifetime     = Timer.lifetime;
+#ifdef USE_PINPLUGIN
+     fskProtection = Timer.fskProtection;
+#endif /* PINPLUGIN */
      strncpy(file, Timer.file, sizeof(file));
      free(aux);
      aux = Timer.aux ? strdup(Timer.aux) : NULL;
@@ -378,6 +390,9 @@
         result = false;
         }
      }
+#ifdef USE_PINPLUGIN
+  fskProtection = aux && strstr(aux, "<pin-plugin><protected>yes</protected></pin-plugin>");
+#endif /* PINPLUGIN */
 #ifdef USEMYSQL
   if(UpdateDB && ((Setup.ReelboxModeTemp == eModeClient) || (Setup.ReelboxModeTemp == eModeServer))) // Client & Server
       UpdateTimerDB();
@@ -719,6 +734,37 @@
 }
 #endif /* USEMYSQL */
 
+#ifdef USE_PINPLUGIN
+void cTimer::SetFskProtection(int aFlag)
+{
+   char* p;
+   char* tmp = 0;
+
+   fskProtection = aFlag;
+
+   if (fskProtection && (!aux || !strstr(aux, "<pin-plugin><protected>yes</protected></pin-plugin>")))
+   {
+      // add protection info to aux
+
+      if (aux) { tmp = strdup(aux); free(aux); }
+      if (asprintf(&aux,"%s<pin-plugin><protected>yes</protected></pin-plugin>", tmp ? tmp : "") < 0 )
+         aux = NULL;
+   }
+   else if (!fskProtection && aux && (p = strstr(aux, "<pin-plugin><protected>yes</protected></pin-plugin>")))
+   {
+      // remove protection info to aux
+
+      if (asprintf(&tmp, "%.*s%s", p-aux, aux, p+strlen("<pin-plugin><protected>yes</protected></pin-plugin>")) >= 0 ) {
+         free(aux);
+         aux = strdup(tmp);
+         }
+   }
+
+   if (tmp)
+      free(tmp);
+}
+#endif /* PINPLUGIN */
+
 // --- cTimers ---------------------------------------------------------------
 
 cTimers Timers;
Index: svdrp.h
===================================================================
--- svdrp.h	(revision 15412)
+++ svdrp.h	(revision 15413)
@@ -79,6 +79,9 @@
   void CmdPLUG(const char *Option);
   void CmdPUTE(const char *Option);
   void CmdREMO(const char *Option);
+#ifdef USE_LIEMIEXT
+  void CmdRENR(const char *Option);
+#endif /* LIEMIEXT */
   void CmdSCAN(const char *Option);
   void CmdSTAT(const char *Option);
   void CmdUPDT(const char *Option);
Index: receiver.c
===================================================================
--- receiver.c	(revision 15412)
+++ receiver.c	(revision 15413)
@@ -82,7 +82,12 @@
             (Channel->Ppid() == Channel->Vpid() || AddPid(Channel->Ppid())) &&
             AddPids(Channel->Apids()) &&
             AddPids(Channel->Dpids()) &&
+#ifdef USE_TTXTSUBS
+            AddPids(Channel->Spids()) &&
+            (!Setup.SupportTeletext || AddPid(Channel->Tpid()));
+#else
             AddPids(Channel->Spids());
+#endif /* TTXTSUBS */
      }
 return true;
 }
Index: timers.h
===================================================================
--- timers.h	(revision 15412)
+++ timers.h	(revision 15413)
@@ -48,6 +48,9 @@
   int start;
   int stop;
   int priority;
+#ifdef USE_PINPLUGIN
+  int fskProtection;
+#endif /* PINPLUGIN */
   int lifetime;
   mutable char file[MaxFileName];
   char *aux;
@@ -72,6 +75,9 @@
   int Start(void) const { return start; }
   int Stop(void) const { return stop; }
   int Priority(void) const { return priority; }
+#ifdef USE_PINPLUGIN
+  int FskProtection(void) const { return fskProtection; }
+#endif /* PINPLUGIN */
   int Lifetime(void) const { return lifetime; }
   const char *File(void) const { return file; }
   time_t FirstDay(void) const { return weekdays ? day : 0; }
@@ -104,6 +110,9 @@
   void SetInVpsMargin(bool InVpsMargin);
   void SetPriority(int Priority);
   void SetFlags(uint Flags);
+#ifdef USE_PINPLUGIN
+  void SetFskProtection(int aFlag);
+#endif /* PINPLUGIN */
   void ClrFlags(uint Flags);
   void InvFlags(uint Flags);
   bool HasFlags(uint Flags) const;
Index: submenu.c
===================================================================
--- submenu.c	(revision 15412)
+++ submenu.c	(revision 15413)
@@ -1,1194 +1,1211 @@
-#ifdef USE_SETUP
-/****************************************************************************
- * DESCRIPTION:
- *             Submenu
- *
- * $Id: vdr-1.3.44-Setup-0.3.0.diff,v 1.1 2006/03/04 09:58:47 ralf Exp $
- *
- * Contact:    ranga@teddycats.de
- *
- * Copyright (C) 2004, 2005 by Ralf Dotzert
- *
- * modified for the VDR Extensions Patch by zulu @vdr-portal
- ****************************************************************************/
-
-#ifndef SUBMENU_H
-#include "submenu.h"
-#include "plugin.h"
-#ifdef USE_WAREAGLEICON
-#include "iconpatch.h"
-#endif /* WAREAGLEICON */
-
-static const char* TAG_SYSTEM      = "system";
-static const char* TAG_PLUGIN      = "plugin";
-static const char* TAG_COMMAND     = "command";
-static const char* TAG_THREAD      = "thread";
-static const char* TAG_MENU        = "menu";
-#ifdef REELVDR
-static const char* TAG_INCLUDE     = "include";
-#endif /*REELVDR*/
-static const char* TAG_UNDEFINED   = "undefined";
-static const char* TRUE_STR        = "yes";
-
-#ifdef REELVDR
-bool getfiles(const char *string, std::vector<char*> *files)
-{
-    char command[128];
-    FILE *file;
-
-    sprintf(command, "ls %s 2>/dev/null", string);
-    file = popen(command, "r");
-    if(file)
-    {
-        char *strBuff;
-        cReadLine readline;
-        strBuff = readline.Read(file);
-        while(strBuff)
-        {
-            files->push_back(strdup(strBuff));
-            strBuff = readline.Read(file);
-        }
-        pclose(file);
-    }
-    else
-       return false;
-
-    return true;
-}
-#endif /* REELVDR */
-
-//################################################################################
-//# SubMenuNode
-//################################################################################
-
-cSubMenuNode::cSubMenuNode(TiXmlElement *xml, int level,  cSubMenuNodes *currentMenu, cSubMenuNodes *parentMenu)
-{
-  init();
-  _parentMenu  = parentMenu;
-  _currentMenu = currentMenu;
-  _level       = level;
-
-  if (xml != NULL && xml->Type() == TiXmlNode::TINYXML_ELEMENT) {
-     const char *tag = xml->Value();
-
-     if (cSubMenuNode::IsType(tag) != cSubMenuNode::UNDEFINED) {
-        SetType(tag);
-#ifdef REELVDR
-        const char *name = xml->Attribute("name");
-        const char *info = xml->Attribute("info");
-        const char *help = xml->Attribute("help");
-        const char *iconNumber = xml->Attribute("icon_number");
-        SetName(name);
-        SetIconNumber(iconNumber);
-        if (info) SetInfo(info);
-        if (help) {
-           if (!info) SetInfo("(?)");
-           SetHelp(help);
-        }
-        if (strcmp(name,"setup") == 0)
-            SetSetupLink(xml->Attribute("link"));
-#else
-        SetName(xml->Attribute("name"));
-#endif /* REELVDR */
-        if ((_type == COMMAND) || (_type == THREAD)) {
-           SetCommand(xml->Attribute("execute"));
-           const char *confirmStr = xml->Attribute("confirm");
-           if (confirmStr != NULL && strcmp(confirmStr, TRUE_STR) == 0)
-              _commandConfirm = true;
-           }
-        else if (_type == PLUGIN) { // Add Plugin Index
-           SetCustomTitle(xml->Attribute("title"));
-#ifdef REELVDR
-           SetPlugin(GetSetupLink());
-#else
-           SetPlugin();
-#endif
-           }
-        else if (_type == MENU && xml->NoChildren() == false) {
-           xml = xml->FirstChildElement();
-           do {
-#ifdef REELVDR
-              if(cSubMenuNode::IsType(xml->Value()) == cSubMenuNode::INCLUDE)
-              {
-                  char *includeXML;
-                  asprintf(&includeXML, "%s/setup/%s", cPlugin::ConfigDirectory(), xml->Attribute("name"));
-                  if(strchr(includeXML, '*'))
-                  {
-                      std::vector<char*> includeXMLs;
-                      getfiles(includeXML, &includeXMLs);
-                      for(unsigned int i=0; i<includeXMLs.size(); ++i)
-                          IncludeXml(includeXMLs.at(i));
-                  }
-                  else
-                      IncludeXml(includeXML);
-                  free(includeXML);
-              }
-              else
-              {
-                  cSubMenuNode *node = new cSubMenuNode(xml, level+1, &_subMenus, currentMenu);
-                  _subMenus.Add(node);
-              }
-#else
-              cSubMenuNode *node = new cSubMenuNode(xml, level+1, &_subMenus, currentMenu);
-              _subMenus.Add(node);
-#endif
-              } while ((xml=xml->NextSiblingElement()) != NULL);
-           }
-        }
-     }
-  else
-     throw "Invalid XML Node";
-}
-
-/**
- * Construct new Node empty Node
- *
- *
- */
-cSubMenuNode::cSubMenuNode(cSubMenuNodes *currentMenu, cSubMenuNodes *parentMenu)
-{
-  init();
-  _parentMenu  = parentMenu;
-  _currentMenu = currentMenu;
-
-}
-
-
-/**
- *
- */
-void cSubMenuNode::init()
-{
-  _name                = NULL;
-  _command             = NULL;
-  _title               = NULL;
-  _pluginMainMenuEntry = NULL;
-  _type                = UNDEFINED;
-  _level               = 0;
-  _parentMenu          = NULL;
-  _currentMenu         = NULL;
-  _pluginIndex         = 0;
-  _commandConfirm      = false;
-#ifdef REELVDR
-  _help                = NULL;
-  _info                = NULL;
-  _iconNumber          = NULL;
-  _setupLink           = NULL;
-#endif /* REELVDR */
-}
-
-
-cSubMenuNode::~ cSubMenuNode()
-{
-  if (_name != NULL)
-     free((void*)_name);
-  if (_command != NULL)
-     free((void*)_command);
-  if (_title != NULL)
-     free((void*)_title);
-  if (_pluginMainMenuEntry != NULL)
-     free((void*)_pluginMainMenuEntry);
-#ifdef REELVDR
-  if (_help != NULL)
-     free((void*)_help);
-  if (_info != NULL)
-     free((void*)_info);
-  if (_iconNumber != NULL)
-     free((void*)_iconNumber);
-  if (_setupLink != NULL)
-     free((void*)_setupLink);
-#endif /* REELVDR */
-}
-
-#ifdef REELVDR
-bool cSubMenuNode::IncludeXml(const char *includeXML)
-{
-    TiXmlDocument  xmlDoc = TiXmlDocument(includeXML);
-    TiXmlElement *xml;
-    bool  ok =true;
-
-    if ((ok=xmlDoc.LoadFile()))
-    {
-        if ((xml = xmlDoc.FirstChildElement()) != NULL)
-        {
-            do
-            {
-                if (xml != NULL && xml->Type() == TiXmlNode::TINYXML_ELEMENT)
-                {
-                    int type = IsType(xml->Value());
-
-                    if ((type == PLUGIN) || (type == COMMAND) || (type == MENU && xml->NoChildren() == false))
-                    {
-                        cSubMenuNode *node = new cSubMenuNode(xml, _level+1, &_subMenus, _currentMenu);
-                        _subMenus.Add(node);
-                    }
-                    else if(type == INCLUDE)
-                    {
-                        char *includeXML;
-                        asprintf(&includeXML, "%s/setup/%s", cPlugin::ConfigDirectory(), xml->Attribute("name"));
-                        if(strchr(includeXML, '*'))
-                        {
-                            std::vector<char*> includeXMLs;
-                            getfiles(includeXML, &includeXMLs);
-                            for(unsigned int i=0; i<includeXMLs.size(); ++i)
-                                IncludeXml(includeXMLs.at(i));
-                        }
-                        else
-                            IncludeXml(includeXML);
-                        free(includeXML);
-                    }
-                }
-                else
-                    throw "Invalid XML Node";
-            }
-            while(ok==true && (xml=xml->NextSiblingElement()) !=NULL);
-        }
-    }
-    else
-    {
-        esyslog("ERROR: in %s : %s  Col=%d Row=%d\n", includeXML,
-                xmlDoc.ErrorDesc(),
-                xmlDoc.ErrorCol(),
-                xmlDoc.ErrorRow());
-
-        ok=false;
-    }
-
-    return ok;
-}
-
-void cSubMenuNode::SetSetupLink(const char *link)
-{
-  if (_setupLink) free (_setupLink);
-
-  if (link && strlen(link) > 0 )
-  {
-    _setupLink = strdup(link);
-  }
-  else
-  {
-    _setupLink = NULL;
-  }
-}
-
-void cSubMenuNode::SetPlugin(const char *link)
-{
-  bool found = false;
-
-  for (unsigned int pIndex = 0; ; pIndex++)
-  {
-     cPlugin *p = cPluginManager::GetPlugin(pIndex);
-     if (p)
-     {
-        if (strcmp(_name, p->Name()) == 0 && p->MainMenuEntry() != NULL)
-        {
-           if (strcmp("setup",p->Name()) == 0 && p->MainMenuEntry() != NULL)
-           {
-              if (link)
-              {
-                SetPluginMainMenuEntry(link);
-                _pluginIndex = pIndex;
-                found=true;
-                break;
-              }
-           }
-
-           SetPluginMainMenuEntry(p->MainMenuEntry());
-           _pluginIndex = pIndex;
-           found=true;
-           break;
-        }
-    }
-    else
-    {
-      break;
-    }
-  }
-
-  if (!found)
-  {
-     _type=UNDEFINED;
-  }
-}
-
-void cSubMenuNode::SetIconNumber(const char*icon)
-{
-    if (_iconNumber)
-    {
-        free((void*)_iconNumber);
-        _iconNumber = NULL;
-    }
-    if (icon) _iconNumber = strdup(icon);
-}
-
-void cSubMenuNode::SetHelp(const char *help)
-{
-  if (_help) free ((void*)_help);
-  help? _help = strdup(help):help = NULL;
-}
-
-void cSubMenuNode::SetInfo(const char *info)
-{
-  if (_info) free((void*)_info);
-
-  //info? _info = strdup(info):info = NULL;
-  if (info)
-      _info = strdup(tr(info));
-  else _info = NULL;
-}
-
-#else
-
-/**
- *
- */
-void cSubMenuNode::SetPlugin()
-{
-  bool found = false;
-  for (int i = 0; ; i++) {
-      cPlugin *p = cPluginManager::GetPlugin(i);
-      if (p) {
-         if (strcmp(_name, p->Name()) == 0 && p->MainMenuEntry() != NULL) {
-            SetPluginMainMenuEntry(p->MainMenuEntry());
-            _pluginIndex = i;
-            found = true;
-            break;
-            }
-         }
-      else
-         break;
-      }
-
-      if (!found)
-         _type = UNDEFINED;
-}
-#endif /* REELVDR */
-
-bool cSubMenuNode::SaveXml(TiXmlElement *root)
-{
-  bool ok = true;
-
-  if (root!=NULL) {
-     TiXmlElement *e = NULL;
-     switch(_type) {
-        case SYSTEM:
-           e = new TiXmlElement(TAG_SYSTEM);
-           e->SetAttribute("name", GetName());
-           break;
-        case COMMAND:
-           e = new TiXmlElement(TAG_COMMAND);
-           e->SetAttribute("name", GetName());
-           e->SetAttribute("execute", GetCommand());
-           if (_commandConfirm)
-              e->SetAttribute("confirm", TRUE_STR);
-           break;
-        case THREAD:
-           e = new TiXmlElement(TAG_THREAD);
-           e->SetAttribute("name", GetName());
-           e->SetAttribute("execute", GetCommand());
-           if (_commandConfirm)
-              e->SetAttribute("confirm", TRUE_STR);
-           break;
-        case PLUGIN:
-           e = new TiXmlElement(TAG_PLUGIN);
-           e->SetAttribute("name", GetName());
-           if (GetCustomTitle() != NULL && strcmp(GetCustomTitle(), "") != 0)
-              e->SetAttribute("title", GetCustomTitle());
-           break;
-        case MENU:
-           e = new TiXmlElement(TAG_MENU);
-           e->SetAttribute("name", GetName());
-           break;
-        case UNDEFINED:
-        default:
-           ok = false;
-           break;
-        }
-        if (ok) {
-           root->LinkEndChild(e);
-           if (HasSubMenus())
-              for (cSubMenuNode *node = _subMenus.First(); node; node = _subMenus.Next(node))
-                  node->SaveXml(e);
-           }
-     }
-
-  return(ok);
-}
-
-
-cSubMenuNode::Type cSubMenuNode::IsType(const char *name)
-{
-  Type type = UNDEFINED;
-
-  if (strcmp(name ,TAG_SYSTEM) == 0)
-     type = cSubMenuNode::SYSTEM;
-  else if (strcmp(name ,TAG_PLUGIN) == 0)
-     type = cSubMenuNode::PLUGIN;
-  else if (strcmp(name ,TAG_COMMAND) == 0)
-     type = cSubMenuNode::COMMAND;
-  else if (strcmp(name ,TAG_THREAD) == 0)
-     type = cSubMenuNode::THREAD;
-  else if (strcmp(name ,TAG_MENU) == 0)
-     type = cSubMenuNode::MENU;
-#ifdef REELVDR
-  else if (strcmp(name ,TAG_INCLUDE) == 0)
-     type =  cSubMenuNode::INCLUDE;
-#endif /* REELVDR */
-
-  return(type);
-}
-
-void cSubMenuNode::SetType(const char *name)
-{
-   _type = IsType(name);
-}
-
-void cSubMenuNode::SetType(enum Type type)
-{
-  _type = type;
-}
-
-
-cSubMenuNode::Type cSubMenuNode::GetType()
-{
-  return(_type);
-}
-
-const char *cSubMenuNode::GetTypeAsString()
-{
-  const char *str=NULL;
-  switch(_type) {
-     case SYSTEM:
-        str = TAG_SYSTEM;
-        break;
-     case COMMAND:
-        str = TAG_COMMAND;
-        break;
-     case THREAD:
-        str = TAG_THREAD;
-        break;
-     case PLUGIN:
-        str = TAG_PLUGIN;
-        break;
-     case MENU:
-        str = TAG_MENU;
-        break;
-     case UNDEFINED:
-        str = TAG_UNDEFINED;
-     default:
-        break;
-    }
-
-  return(str);
-}
-
-void cSubMenuNode::SetCommand(const char *command)
-{
-  if (_command != NULL)
-     free((void*)_command);
-
-  if (command != NULL)
-     _command = strdup(command);
-  else
-     _command = NULL;
-}
-
-const char *cSubMenuNode::GetCommand()
-{
-  return(_command);
-}
-
-bool cSubMenuNode::CommandConfirm()
-{
-  return(_commandConfirm);
-}
-
-void cSubMenuNode::SetCommandConfirm(int val)
-{
-  if (val == 1)
-     _commandConfirm = true;
-  else
-     _commandConfirm = false;
-}
-
-void cSubMenuNode::SetCustomTitle(const char *title)
-{
-  if (_title != NULL)
-     free((void*)_title);
-
-  if (title != NULL)
-     _title = strdup(title);
-  else
-     _title = NULL;
-}
-
-const char *cSubMenuNode::GetCustomTitle()
-{
-  return(_title);
-}
-
-void cSubMenuNode::SetName(const char *name)
-{
-  if (_name)
-     free ((void*)_name);
-
-  if (name != NULL)
-     _name = strdup(name);
-  else
-     _name = NULL;
-}
-
-const char *cSubMenuNode::GetName()
-{
-  return(_name);
-}
-
-int cSubMenuNode::GetLevel()
-{
-  return(_level);
-}
-
-void cSubMenuNode::SetLevel(int level)
-{
-  _level = level;
-  if (HasSubMenus()) { //Adjust Levels of Subnodes
-     for (cSubMenuNode *node = _subMenus.First(); node; node = _subMenus.Next(node))
-         node->SetLevel(level+1);
-     }
-}
-
-int cSubMenuNode::GetPluginIndex()
-{
-  return(_pluginIndex);
-}
-
-void cSubMenuNode::SetPluginIndex(int index)
-{
-  _pluginIndex = index;
-}
-
-void cSubMenuNode::SetPluginMainMenuEntry(const char *mainMenuEntry)
-{
-  if (_pluginMainMenuEntry != NULL)
-     free((void*)_pluginMainMenuEntry);
-
-  if (_title != NULL && strcmp(_title, "") != 0)
-     _pluginMainMenuEntry = strdup(_title);
-  else if (mainMenuEntry != NULL)
-     _pluginMainMenuEntry = strdup(mainMenuEntry);
-  else
-     _pluginMainMenuEntry = NULL;
-}
-
-const char *cSubMenuNode::GetPluginMainMenuEntry()
-{
-  return(_pluginMainMenuEntry);
-}
-
-
-cSubMenuNodes *cSubMenuNode::GetParentMenu()
-{
-  return(_parentMenu);
-}
-
-void cSubMenuNode::SetParentMenu(cSubMenuNodes *parent)
-{
-  _parentMenu = parent;
-}
-
-cSubMenuNodes *cSubMenuNode::GetCurrentMenu()
-{
-  return(_currentMenu);
-}
-
-void cSubMenuNode::SetCurrentMenu(cSubMenuNodes *current)
-{
-  _currentMenu = current;
-}
-
-
-cSubMenuNodes *cSubMenuNode::GetSubMenus()
-{
-  return(&_subMenus);
-}
-
-bool cSubMenuNode::HasSubMenus()
-{
-  if (_subMenus.Count() > 0)
-     return(true);
-  else
-     return(false);
-}
-
-
-void cSubMenuNode::Print(int index)
-{
-  for (int i = 0; i < index; i++)
-      printf(" ");
-
-  printf("Name=%s Type=%s Level=%d", _name, GetTypeAsString(), _level);
-  if (_type == COMMAND || _type == THREAD)
-     printf(" Command=%s", _command);
-  else if (_type == PLUGIN && _title != NULL)
-     printf(" Title=%s", _title);
-  printf("\n");
-
-  for (cSubMenuNode *node = _subMenus.First(); node; node = _subMenus.Next(node))
-      node->Print(index+4);
-}
-
-
-//################################################################################
-//#
-//################################################################################
-cSubMenu::cSubMenu()
-{
-  _commandResult         = NULL;
-  _currentMenuTree       = &_menuTree;
-  _currentParentMenuTree = NULL;
-#ifdef USE_PINPLUGIN
-  _currentParentIndex    = -1;
-#endif /* PINPLUGIN */
-  _nodeArray             = NULL;
-  _nrNodes               = 0;
-}
-
-
-cSubMenu::~cSubMenu()
-{
-  if (_commandResult)
-     free(_commandResult);
-  if (_nodeArray)
-     free(_nodeArray);
-  _nrNodes = 0;
-}
-
-
-bool cSubMenu::LoadXml(cString fname)
-{
-  TiXmlDocument  xmlDoc = TiXmlDocument(fname);
-  TiXmlElement  *root   = NULL;
-  cSubMenuNode  *node   = NULL;
-
-  bool  ok = true;
-  // Clear previously loaded Menu
-  _menuTree.Clear();
-  _fname = fname;
-
-  if ((ok = xmlDoc.LoadFile())) {
-     if ((root = xmlDoc.FirstChildElement("menus")) != NULL) {
-        cString tmp = root->Attribute("suffix");
-#ifdef USE_WAREAGLEICON
-        if      (strcmp(tmp, "ICON_FOLDER") == 0)      tmp = cString::sprintf(" %s", IsLangUtf8() ? ICON_FOLDER_UTF8 : ICON_FOLDER);
-        else if (strcmp(tmp, "ICON_MOVE_FOLDER") == 0) tmp = cString::sprintf(" %s", IsLangUtf8() ? ICON_MOVE_FOLDER_UTF8 : ICON_MOVE_FOLDER);
-#endif /* WAREAGLEICON */
-        if (*tmp)
-           _menuSuffix = tmp;
-        else
-           _menuSuffix = cString::sprintf(" ");
-
-        if ((root = root->FirstChildElement()) != NULL) {
-           do {
-              try {
-                 node = new cSubMenuNode(root, 0,  &_menuTree, NULL);
-#ifdef REELVDR
-                 const char* tmp_name = root->Attribute("name");
-                 //printf("%s : %i \n",tmp_name, node->SubMenuSize());
-                 if (tmp_name && strcmp("Additional Software",tmp_name) == 0 /*no translation of "Additional Software" here*/
-                              && node->SubMenuSize() <= 0) // empty submenu;
-                 // no additional plugins installed
-                 {
-                   delete node;
-                   node = NULL;
-                 }
-                 else
-#endif /* REELVDR */
-                 _menuTree.Add(node);
-                 }
-              catch (char *message) {
-                 esyslog("ERROR: while decoding XML Node");
-                 ok = false;
-                 }
-              } while (ok == true && (root = root->NextSiblingElement()) != NULL);
-#ifndef REELVDR
-            addMissingPlugins();
-#endif /* REELVDR */
-           removeUndefinedNodes();
-           }
-        }
-     else {
-        esyslog("ERROR: in %s, missing Tag <menus>\n", *fname);
-        ok = false;
-        }
-     }
-  else {
-     esyslog("ERROR: in %s : %s  Col=%d Row=%d\n",
-            *fname,
-            xmlDoc.ErrorDesc(),
-            xmlDoc.ErrorCol(),
-            xmlDoc.ErrorRow());
-     ok = false;
-     }
-
-  return(ok);
-}
-
-
-bool cSubMenu::SaveXml()
-{
-  return(SaveXml(_fname));
-}
-
-
-bool cSubMenu::SaveXml(cString fname)
-{
-  bool ok = true;
-
-  if (*_fname) {
-     TiXmlDocument xml = TiXmlDocument(fname);
-     TiXmlComment  comment;
-     comment.SetValue("\n\
--    VDR Menu-Configuration File\n\
--\n\
--\n\
--   Example:\n\
--\n\
- <menus>\n\
-    <system name=\"Schedule\" />\n\
-    <system name=\"Channels\" />\n\
-    <system name=\"Timers\" />\n\
-    <system name=\"Recordings\" />\n\
-    <menu name=\"System\">\n\
-        <system name=\"Setup\" />\n\
-        <system name=\"Commands\" />\n\
-        <plugin name=\"setup\" title=\"My Setup\" />\n\
-        <command name=\"myCommand1\" execute=\"/usr/bin/mycommand1\" />\n\
-        <command name=\"myCommand2\" execute=\"/usr/bin/mycommand2\" confirm=\"yes\" />\n\
-        <thread name=\"myCommand3\" execute=\"/usr/bin/mycommand3\" confirm=\"yes\" />\n\
-        <plugin name=\"epgsearch\" title=\"myProgram\" />\n\
-        <menu name=\"mySubSubMenu\">\n\
-            ...\n\
-        </menu>\n\
-    </menu>\n\
-     <menu name=\"Suche\">\n\
-        <plugin name=\"epgsearch\" />\n\
-        ...\n\
-    </menu>\n\
- </menus>\n\
-");
-
-     TiXmlElement root("menus");
-     root.SetAttribute("suffix", _menuSuffix);
-     for (cSubMenuNode *node = _menuTree.First(); node; node = _menuTree.Next(node))
-         node->SaveXml(&root);
-
-         if (xml.InsertEndChild(comment) != NULL && xml.InsertEndChild(root) != NULL)
-            ok = xml.SaveFile(fname);
-     }
-  else
-     ok = false;
-
-  return(ok);
-}
-
-
-cSubMenuNodes *cSubMenu::GetMenuTree()
-{
-  return(_currentMenuTree);
-}
-
-
-void cSubMenu::PrintMenuTree()
-{
-  for (cSubMenuNode *node = _menuTree.First(); node; node = _menuTree.Next(node))
-      node->Print();
-}
-
-
-int cSubMenu::GetNrOfNodes()
-{
-  if (_nrNodes == 0) {
-     if ((_nrNodes = countNodes(&_menuTree)) > 0) {
-        _nodeArray = (cSubMenuNode**) malloc(sizeof(cSubMenuNode*)*_nrNodes);
-        int index = 0;
-        tree2Array(&_menuTree, index);
-        }
-     }
-
-  return(_nrNodes);
-}
-
-
-/**
- * returns the specified node within the current menu
- * @param index position in the current menu
- * @return node or null if not found
- */
-cSubMenuNode *cSubMenu::GetNode(int index)
-{
-  cSubMenuNode *node = NULL;
-  if (_currentMenuTree == NULL || (node=_currentMenuTree->Get(index)) == NULL)
-     esyslog("ERROR: illegal call of cSubMenu::GetNode(%d)", index);
-
-  return(node);
-}
-
-
-/**
- * Get the specified Node
- * @param index specfies the absolut indes in the list of all nodes
- * @return node or NULL if not found
- */
-cSubMenuNode *cSubMenu::GetAbsNode(int index)
-{
-  cSubMenuNode *node = NULL;
-  GetNrOfNodes();
-  if (_nrNodes > 0 && index >= 0 && index < _nrNodes)
-     node = _nodeArray[index];
-
-  return(node);
-}
-
-
-#ifdef USE_PINPLUGIN
-bool cSubMenu::Down(cSubMenuNode *node, int currentIndex)
-#else
-bool cSubMenu::Down(int index)
-#endif /* PINPLUGIN */
-{
-  bool ok = true;
-#ifdef USE_PINPLUGIN
-  if (_currentMenuTree != NULL && node && node->GetType() == cSubMenuNode::MENU) {
-#else
-  cSubMenuNode *node = NULL;
-
-  if (_currentMenuTree != NULL && (node=_currentMenuTree->Get(index)) != NULL && node->GetType() == cSubMenuNode::MENU) {
-#endif /* PINPLUGIN */
-     _currentParentMenuTree = _currentMenuTree;
-#ifdef USE_PINPLUGIN
-     _currentParentIndex = currentIndex;
-#endif /* PINPLUGIN */
-     _currentMenuTree = node->GetSubMenus();
-     }
-  else {
-     ok = false;
-#ifdef USE_PINPLUGIN
-     esyslog("ERROR: illegal call of cSubMenu::Down");
-#else
-     esyslog("ERROR: illegal call of cSubMenu::Down(%d)", index);
-#endif /* PINPLUGIN */
-     }
-
-  return(ok);
-}
-
-bool cSubMenu::Up(int *parentIndex)
-{
-  bool ok = true;
-
-  if (_currentMenuTree != NULL && parentIndex != NULL) {
-#ifndef USE_PINPLUGIN
-     cSubMenuNode *node = NULL;
-#endif /* PINPLUGIN */
-     *parentIndex = 0;
-#ifdef USE_PINPLUGIN
-     if (_currentParentIndex >= 0)
-        *parentIndex = _currentParentIndex;
-#else
-     if (_currentParentMenuTree != NULL)
-        for (int i = 0; (node = _currentParentMenuTree->Get(i)) != NULL; i++) {
-            if (_currentMenuTree == node->GetSubMenus()) {
-               *parentIndex = i;
-               break;
-               }
-            }
-#endif /* PINPLUGIN */
-
-     _currentMenuTree = _currentParentMenuTree;
-     if (_currentMenuTree != NULL)
-        _currentParentMenuTree = _currentMenuTree->Get(0)->GetParentMenu();
-     else
-        ok = false;
-     }
-  else {
-     ok = false;
-     esyslog("ERROR: illegal call of cSubMenu::Up()");
-     }
-
-  return(ok);
-}
-
-const char *cSubMenu::ExecuteCommand(const char *cmd)
-{
-  free(_commandResult);
-  _commandResult = NULL;
-
-  dsyslog("executing command '%s'", cmd);
-  FILE *p = popen(cmd, "r");
-  if (p) {
-     int l = 0;
-     int c;
-     while ((c = fgetc(p)) != EOF) {
-           if (l % 20 == 0)
-              _commandResult = (char *)realloc(_commandResult, l + 21);
-           _commandResult[l++] = c;
-           }
-     if (_commandResult)
-        _commandResult[l] = 0;
-     pclose(p);
-     }
-  else
-     esyslog("ERROR: can't open pipe for command '%s'", cmd);
-
-  return _commandResult;
-}
-
-/**
- * Move Menu Entry to new Position
- * @param index  index of menu entry to move 
- * @param toIndex index of destination
- * @param where After ore before the destination index
- */
-void cSubMenu::MoveMenu(int index, int toIndex, enum Where where)
-{
-  if (index < 0 || index > _nrNodes || // invalid index is ignored
-     toIndex < 0 || toIndex > _nrNodes || index == toIndex)
-     return;
-
-  cSubMenuNode *srcNode  = GetAbsNode(index);
-  cSubMenuNode *destNode = GetAbsNode(toIndex);
-
-  if (where == cSubMenu::INTO && destNode->GetType() != cSubMenuNode::MENU)
-     return;
-
-  if (where == cSubMenu::INTO) {
-     if (destNode->GetType() == cSubMenuNode::MENU) {
-        srcNode->GetCurrentMenu()->Del(srcNode, false);
-        srcNode->SetLevel(destNode->GetLevel()+1);
-        srcNode->SetParentMenu(destNode->GetCurrentMenu());
-        srcNode->SetCurrentMenu(destNode->GetSubMenus());
-
-        destNode->GetSubMenus()->Add(srcNode);
-        reloadNodeArray();
-        }
-     }
-  else {
-     srcNode->GetCurrentMenu()->Del(srcNode, false);
-     srcNode->SetLevel(destNode->GetLevel());
-     srcNode->SetParentMenu(destNode->GetParentMenu());
-     srcNode->SetCurrentMenu(destNode->GetCurrentMenu());
-
-     if (where == cSubMenu::BEHIND) {
-        destNode->GetCurrentMenu()->Add(srcNode, GetAbsNode(toIndex));
-        reloadNodeArray();
-        }
-     else {
-        destNode->GetCurrentMenu()->Ins(srcNode, GetAbsNode(toIndex));
-        reloadNodeArray();
-        }
-     }
-}
-
-/**
- * Create a new Menu Entry
- * @param index index of destination
- * @param menuTitle  Titel of new Menu entry
- */
-void cSubMenu::CreateMenu(int index, const char *menuTitle)
-{
-  if (index >= 0 && index < _nrNodes) {
-     cSubMenuNode *srcNode  = GetAbsNode(index);
-     if (srcNode != NULL) {
-        cSubMenuNode *newNode = new cSubMenuNode(srcNode->GetParentMenu(), srcNode->GetCurrentMenu());
-        newNode->SetLevel(srcNode->GetLevel());
-        newNode->SetName(menuTitle);
-        newNode->SetType(cSubMenuNode::MENU);
-        newNode->SetParentMenu(srcNode->GetParentMenu());
-        newNode->SetCurrentMenu(srcNode->GetCurrentMenu());
-
-        srcNode->GetCurrentMenu()->Add(newNode, GetAbsNode(index));
-        reloadNodeArray();
-        }
-     }
-}
-
-/**
- * delete the specified entry, or subtree if the specified entry is a menu
- * @param index destion index 
- */
-void cSubMenu::DeleteMenu(int index)
-{
-  if (index >= 0 && index < _nrNodes) {
-     cSubMenuNode *srcNode = GetAbsNode(index);
-     srcNode->GetCurrentMenu()->Del(srcNode, true);
-     reloadNodeArray();
-     }
-}
-
-
-// Private Methods
-
-int cSubMenu::countNodes(cSubMenuNodes *tree)
-{
-  int count = 0;
-  if (tree != NULL) {
-     for (cSubMenuNode *node = tree->First(); node; node = tree->Next(node)) {
-         count++;
-         if (node->HasSubMenus())
-            count += countNodes(node->GetSubMenus());
-         }
-     }
-  return(count);
-}
-
-
-void cSubMenu::tree2Array(cSubMenuNodes *tree, int &index)
-{
-  if (tree != NULL) {
-     for (cSubMenuNode *node = tree->First(); node; node = tree->Next(node)) {
-         _nodeArray[index++]=node;
-         if (node->HasSubMenus())
-            tree2Array(node->GetSubMenus(), index);
-         }
-     }
-
-}
-
-bool cSubMenu::IsPluginInMenu(const char *name)
-{
-  bool found = false;
-  for (int i = 0; i < _nrNodes && found == false; i++) {
-      cSubMenuNode *node = GetAbsNode(i);
-      if (node != NULL && node->GetType() == cSubMenuNode::PLUGIN && strcmp(name, node->GetName()) == 0)
-         found = true;
-      }
-  return(found);
-}
-
-/**
- * Adds the given plugin to the Menu-Tree if not allready in List
- * @param name specifies the name of the plugin
- */
-void cSubMenu::AddPlugin(const char *name)
-{
-  if (! IsPluginInMenu(name)) {
-     cSubMenuNode *node = new  cSubMenuNode(&_menuTree, NULL);
-     node->SetName(name);
-     node->SetType("plugin");
-     node->SetPlugin();
-     _menuTree.Add(node);
-     }
-}
-
-void cSubMenu::addMissingPlugins()
-{
-  _nrNodes = GetNrOfNodes();
-  for (int i = 0; ; i++) {
-      cPlugin *p = cPluginManager::GetPlugin(i);
-      if (p)
-         AddPlugin(p->Name());
-      else
-         break;
-      }
-  reloadNodeArray();
-}
-
-/**
- * Adds the given command to the Menu-Tree
- * @param name specifies the name of the command
- */
-void cSubMenu::CreateCommand(int index, const char *name, const char *execute, int confirm)
-{
-  if (index >= 0 && index < _nrNodes) {
-     cSubMenuNode *srcNode  = GetAbsNode(index);
-     if (srcNode != NULL) {
-        cSubMenuNode *newNode = new cSubMenuNode(srcNode->GetParentMenu(), srcNode->GetCurrentMenu());
-        newNode->SetLevel(srcNode->GetLevel());
-        newNode->SetName(name);
-        newNode->SetType("command");
-        newNode->SetCommand(execute);
-        newNode->SetCommandConfirm(confirm);
-        newNode->SetParentMenu(srcNode->GetParentMenu());
-        newNode->SetCurrentMenu(srcNode->GetCurrentMenu());
-
-        srcNode->GetCurrentMenu()->Add(newNode, GetAbsNode(index));
-        reloadNodeArray();
-        }
-     }
-}
-
-void cSubMenu::CreateThread(int index, const char *name, const char *execute, int confirm)
-{
-  if (index >= 0 && index < _nrNodes) {
-     cSubMenuNode *srcNode  = GetAbsNode(index);
-     if (srcNode != NULL) {
-        cSubMenuNode *newNode = new cSubMenuNode(srcNode->GetParentMenu(), srcNode->GetCurrentMenu());
-        newNode->SetLevel(srcNode->GetLevel());
-        newNode->SetName(name);
-        newNode->SetType("thread");
-        newNode->SetCommand(execute);
-        newNode->SetCommandConfirm(confirm);
-        newNode->SetParentMenu(srcNode->GetParentMenu());
-        newNode->SetCurrentMenu(srcNode->GetCurrentMenu());
-
-        srcNode->GetCurrentMenu()->Add(newNode, GetAbsNode(index));
-        reloadNodeArray();
-        }
-     }
-}
-
-/**
- * reloads the internal Array of Nodes
- */
-void cSubMenu::reloadNodeArray()
-{
-  if (_nrNodes > 0)
-     free(_nodeArray);
-  _nodeArray = NULL;
-  _nrNodes = 0;
-  _nrNodes = GetNrOfNodes();
-}
-
-/**
- * remove Undefined Nodes
- */
-void cSubMenu::removeUndefinedNodes()
-{
-  bool remove = false;
-
-  reloadNodeArray();
-  for (int i = 0; i < _nrNodes; i++) {
-      cSubMenuNode *node = GetAbsNode(i);
-      if (node != NULL && node->GetType() == cSubMenuNode::UNDEFINED) {
-         cSubMenuNodes *pMenu = node->GetCurrentMenu();
-         pMenu->Del(node, true);
-         remove = true;
-         }
-      }
-  if (remove)
-     reloadNodeArray();
-}
-
-
-/**
-* Retrieves the Menutitel of the parent Menu
-*/
-const char *cSubMenu::GetParentMenuTitel()
-{
-  const char *result = "";
-
-  if (_currentMenuTree != NULL && _currentParentMenuTree != NULL) {
-     cSubMenuNode *node = NULL;
-     for (int i = 0; (node = _currentParentMenuTree->Get(i)) != NULL; i++) {
-         if (_currentMenuTree == node->GetSubMenus()) {
-            result = node->GetName();
-            break;
-            }
-         }
-     }
-
-  return(result);
-}
-
-#endif
-#endif /* USE_SETUP */
+#ifdef USE_SETUP
+/****************************************************************************
+ * DESCRIPTION:
+ *             Submenu
+ *
+ * $Id: vdr-1.3.44-Setup-0.3.0.diff,v 1.1 2006/03/04 09:58:47 ralf Exp $
+ *
+ * Contact:    ranga@teddycats.de
+ *
+ * Copyright (C) 2004, 2005 by Ralf Dotzert
+ *
+ * modified for the VDR Extensions Patch by zulu @vdr-portal
+ ****************************************************************************/
+
+#ifndef SUBMENU_H
+#include "submenu.h"
+#include "plugin.h"
+#ifdef USE_WAREAGLEICON
+#include "iconpatch.h"
+#endif /* WAREAGLEICON */
+
+static const char* TAG_SYSTEM      = "system";
+static const char* TAG_PLUGIN      = "plugin";
+static const char* TAG_COMMAND     = "command";
+static const char* TAG_THREAD      = "thread";
+static const char* TAG_MENU        = "menu";
+#ifdef REELVDR
+static const char* TAG_INCLUDE     = "include";
+#endif /*REELVDR*/
+static const char* TAG_UNDEFINED   = "undefined";
+static const char* TRUE_STR        = "yes";
+
+#ifdef REELVDR
+bool getfiles(const char *string, std::vector<char*> *files)
+{
+    char command[128];
+    FILE *file;
+
+    sprintf(command, "ls %s 2>/dev/null", string);
+    file = popen(command, "r");
+    if(file)
+    {
+        char *strBuff;
+        cReadLine readline;
+        strBuff = readline.Read(file);
+        while(strBuff)
+        {
+            files->push_back(strdup(strBuff));
+            strBuff = readline.Read(file);
+        }
+        pclose(file);
+    }
+    else
+        return false;
+
+    return true;
+}
+#endif /* REELVDR */
+
+//################################################################################
+//# SubMenuNode
+//################################################################################
+
+cSubMenuNode::cSubMenuNode(TiXmlElement *xml, int level,  cSubMenuNodes *currentMenu, cSubMenuNodes *parentMenu)
+{
+  init();
+  _parentMenu  = parentMenu;
+  _currentMenu = currentMenu;
+  _level       = level;
+
+  if (xml != NULL && xml->Type() == TiXmlNode::TINYXML_ELEMENT) {
+     const char *tag = xml->Value();
+
+     if (cSubMenuNode::IsType(tag) != cSubMenuNode::UNDEFINED) {
+        SetType(tag);
+#ifdef REELVDR
+        const char *name = xml->Attribute("name");
+        const char *info = xml->Attribute("info");
+        const char *help = xml->Attribute("help");
+        const char *iconNumber = xml->Attribute("icon_number");
+        SetName(name);
+        SetIconNumber(iconNumber);
+        if (info) SetInfo(info);
+        if (help) {
+           if (!info) SetInfo("(?)");
+           SetHelp(help); 
+        }
+        if (strcmp(name,"setup") == 0) 
+            SetSetupLink(xml->Attribute("link"));
+#else
+        SetName(xml->Attribute("name"));
+#endif /* REELVDR */
+        if ((_type == COMMAND) || (_type == THREAD)) {
+           SetCommand(xml->Attribute("execute"));
+           const char *confirmStr = xml->Attribute("confirm");
+           if (confirmStr != NULL && strcmp(confirmStr, TRUE_STR) == 0)
+              _commandConfirm = true;
+           }
+        else if (_type == PLUGIN) { // Add Plugin Index
+           SetCustomTitle(xml->Attribute("title"));
+#ifdef REELVDR
+           SetPlugin(GetSetupLink());
+#else
+           SetPlugin();
+#endif
+           }
+#ifdef REELVDR
+        else if(_type == INCLUDE) {
+            char *includeXML;
+            asprintf(&includeXML, "%s/setup/%s", cPlugin::ConfigDirectory(), xml->Attribute("name"));
+            if(strchr(includeXML, '*'))
+            {
+                std::vector<char*> includeXMLs;
+                getfiles(includeXML, &includeXMLs);
+                for(unsigned int i=0; i<includeXMLs.size(); ++i)
+                    IncludeXml(includeXMLs.at(i));
+            }
+            else
+                IncludeXml(includeXML);
+            free(includeXML);
+            }
+#endif /* REELVDR */
+        else if (_type == MENU && xml->NoChildren() == false) {
+           xml = xml->FirstChildElement();
+           do {
+#ifdef REELVDR
+              if(cSubMenuNode::IsType(xml->Value()) == cSubMenuNode::INCLUDE)
+              {
+                  char *includeXML;
+                  asprintf(&includeXML, "%s/setup/%s", cPlugin::ConfigDirectory(), xml->Attribute("name"));
+                  if(strchr(includeXML, '*'))
+                  {
+                      std::vector<char*> includeXMLs;
+                      getfiles(includeXML, &includeXMLs);
+                      for(unsigned int i=0; i<includeXMLs.size(); ++i)
+                          IncludeXml(includeXMLs.at(i));
+                  }
+                  else
+                      IncludeXml(includeXML);
+                  free(includeXML);
+              }
+              else
+              {
+                  cSubMenuNode *node = new cSubMenuNode(xml, level+1, &_subMenus, currentMenu);
+                  _subMenus.Add(node);
+              }
+#else
+              cSubMenuNode *node = new cSubMenuNode(xml, level+1, &_subMenus, currentMenu);
+              _subMenus.Add(node);
+#endif
+              } while ((xml=xml->NextSiblingElement()) != NULL);
+           }
+        }
+     }
+  else
+     throw "Invalid XML Node";
+}
+
+/**
+ * Construct new Node empty Node
+ *
+ *
+ */
+cSubMenuNode::cSubMenuNode(cSubMenuNodes *currentMenu, cSubMenuNodes *parentMenu)
+{
+  init();
+  _parentMenu  = parentMenu;
+  _currentMenu = currentMenu;
+
+}
+
+
+/**
+ *
+ */
+void cSubMenuNode::init()
+{
+  _name                = NULL;
+  _command             = NULL;
+  _title               = NULL;
+  _pluginMainMenuEntry = NULL;
+  _type                = UNDEFINED;
+  _level               = 0;
+  _parentMenu          = NULL;
+  _currentMenu         = NULL;
+  _pluginIndex         = 0;
+  _commandConfirm      = false;
+#ifdef REELVDR
+  _help                = NULL;
+  _info                = NULL;
+  _iconNumber          = NULL;
+  _setupLink           = NULL;
+#endif /* REELVDR */
+}
+
+
+cSubMenuNode::~ cSubMenuNode()
+{
+  if (_name != NULL)
+     free((void*)_name);
+  if (_command != NULL)
+     free((void*)_command);
+  if (_title != NULL)
+     free((void*)_title);
+  if (_pluginMainMenuEntry != NULL)
+     free((void*)_pluginMainMenuEntry);
+#ifdef REELVDR
+  if (_help != NULL)
+     free((void*)_help);
+  if (_info != NULL)
+     free((void*)_info);
+  if (_iconNumber != NULL)
+     free((void*)_iconNumber);
+  if (_setupLink != NULL)
+     free((void*)_setupLink);
+#endif /* REELVDR */
+}
+
+#ifdef REELVDR
+bool cSubMenuNode::IncludeXml(const char *includeXML)
+{
+    TiXmlDocument  xmlDoc = TiXmlDocument(includeXML);
+    TiXmlElement *xml;
+    bool  ok =true;
+
+    if ((ok=xmlDoc.LoadFile()))
+    { 
+        if ((xml = xmlDoc.FirstChildElement()) != NULL)
+        {
+            do
+            {
+                if (xml != NULL && xml->Type() == TiXmlNode::TINYXML_ELEMENT)
+                {     
+                    int type = IsType(xml->Value());
+
+                    if ((type == PLUGIN) || (type == COMMAND) || (type == MENU && xml->NoChildren() == false))
+                    {
+                        cSubMenuNode *node = new cSubMenuNode(xml, _level+1, &_subMenus, _currentMenu);
+                        _subMenus.Add(node);
+                    }
+                    else if(type == INCLUDE)
+                    {
+                        char *includeXML;
+                        asprintf(&includeXML, "%s/setup/%s", cPlugin::ConfigDirectory(), xml->Attribute("name"));
+                        if(strchr(includeXML, '*'))
+                        {
+                            std::vector<char*> includeXMLs;
+                            getfiles(includeXML, &includeXMLs);
+                            for(unsigned int i=0; i<includeXMLs.size(); ++i)
+                                IncludeXml(includeXMLs.at(i));
+                        }
+                        else
+                            IncludeXml(includeXML);
+                        free(includeXML);
+                    }
+                }
+                else
+                    throw "Invalid XML Node";
+            }
+            while(ok==true && (xml=xml->NextSiblingElement()) !=NULL);
+        }
+    }
+    else
+    {
+        esyslog("ERROR: in %s : %s  Col=%d Row=%d\n", includeXML,
+                xmlDoc.ErrorDesc(),
+                xmlDoc.ErrorCol(),
+                xmlDoc.ErrorRow());
+
+        ok=false;
+    }
+
+    return ok;
+}
+
+void cSubMenuNode::SetSetupLink(const char *link)
+{
+  if (_setupLink) free (_setupLink);
+
+  if (link && strlen(link) > 0 )  
+  {
+    _setupLink = strdup(link);
+  }
+  else 
+  {
+    _setupLink = NULL;
+  }
+}
+
+void cSubMenuNode::SetPlugin(const char *link)
+{
+  bool found = false;
+   
+  for (unsigned int pIndex = 0; ; pIndex++)
+  {
+     cPlugin *p = cPluginManager::GetPlugin(pIndex);
+     if (p)
+     {
+        if (strcmp(_name, p->Name()) == 0 && p->MainMenuEntry() != NULL)
+        {
+           if (strcmp("setup",p->Name()) == 0 && p->MainMenuEntry() != NULL)
+           {
+              if (link) 
+              {
+                SetPluginMainMenuEntry(link);
+                _pluginIndex = pIndex;
+                found=true;
+                break;
+              }
+           }
+                 
+           SetPluginMainMenuEntry(p->MainMenuEntry());
+           _pluginIndex = pIndex;
+           found=true;
+           break;
+        }
+    }
+    else
+    {
+      break;
+    } 
+  }
+
+  if (!found)
+  {
+     _type=UNDEFINED;
+  }
+}
+
+void cSubMenuNode::SetHelp(const char *help)
+{
+  if (_help) free ((void*)_help);
+  help? _help = strdup(help):help = NULL;
+}
+
+void cSubMenuNode::SetInfo(const char *info)
+{
+  if (_info) free((void*)_info);
+
+  //info? _info = strdup(info):info = NULL;
+  if (info)
+      _info = strdup(tr(info));
+  else _info = NULL;
+}
+
+void cSubMenuNode::SetIconNumber(const char*icon)
+{
+    if (_iconNumber) 
+    {
+        free((void*)_iconNumber); 
+        _iconNumber = NULL;
+    }
+    if (icon) _iconNumber = strdup(icon);
+}
+
+#else
+
+/**
+ *
+ */
+void cSubMenuNode::SetPlugin()
+{
+  bool found = false;
+  for (int i = 0; ; i++) {
+      cPlugin *p = cPluginManager::GetPlugin(i);
+      if (p) {
+         if (strcmp(_name, p->Name()) == 0 && p->MainMenuEntry() != NULL) {
+            SetPluginMainMenuEntry(p->MainMenuEntry());
+            _pluginIndex = i;
+            found = true;
+            break;
+            }
+         }
+      else
+         break;
+      }
+
+      if (!found)
+         _type = UNDEFINED;
+}
+#endif /* REELVDR */
+
+
+bool cSubMenuNode::SaveXml(TiXmlElement *root)
+{
+  bool ok = true;
+
+  if (root!=NULL) {
+     TiXmlElement *e = NULL;
+     switch(_type) {
+        case SYSTEM:
+           e = new TiXmlElement(TAG_SYSTEM);
+           e->SetAttribute("name", GetName());
+           break;
+        case COMMAND:
+           e = new TiXmlElement(TAG_COMMAND);
+           e->SetAttribute("name", GetName());
+           e->SetAttribute("execute", GetCommand());
+           if (_commandConfirm)
+              e->SetAttribute("confirm", TRUE_STR);
+           break;
+        case THREAD:
+           e = new TiXmlElement(TAG_THREAD);
+           e->SetAttribute("name", GetName());
+           e->SetAttribute("execute", GetCommand());
+           if (_commandConfirm)
+              e->SetAttribute("confirm", TRUE_STR);
+           break;
+        case PLUGIN:
+           e = new TiXmlElement(TAG_PLUGIN);
+           e->SetAttribute("name", GetName());
+           if (GetCustomTitle() != NULL && strcmp(GetCustomTitle(), "") != 0)
+              e->SetAttribute("title", GetCustomTitle());
+           break;
+        case MENU:
+           e = new TiXmlElement(TAG_MENU);
+           e->SetAttribute("name", GetName());
+           break;
+        case UNDEFINED:
+        default:
+           ok = false;
+           break;
+        }
+        if (ok) {
+           root->LinkEndChild(e);
+           if (HasSubMenus())
+              for (cSubMenuNode *node = _subMenus.First(); node; node = _subMenus.Next(node))
+                  node->SaveXml(e);
+           }
+     }
+
+  return(ok);
+}
+
+
+cSubMenuNode::Type cSubMenuNode::IsType(const char *name)
+{
+  Type type = UNDEFINED;
+
+  if (strcmp(name ,TAG_SYSTEM) == 0)
+     type = cSubMenuNode::SYSTEM;
+  else if (strcmp(name ,TAG_PLUGIN) == 0)
+     type = cSubMenuNode::PLUGIN;
+  else if (strcmp(name ,TAG_COMMAND) == 0)
+     type = cSubMenuNode::COMMAND;
+  else if (strcmp(name ,TAG_THREAD) == 0)
+     type = cSubMenuNode::THREAD;
+  else if (strcmp(name ,TAG_MENU) == 0)
+     type = cSubMenuNode::MENU;
+#ifdef REELVDR
+  else if (strcmp(name ,TAG_INCLUDE) == 0)
+    type =  cSubMenuNode::INCLUDE;
+#endif /* REELVDR */
+
+  return(type);
+}
+
+void cSubMenuNode::SetType(const char *name)
+{
+   _type = IsType(name);
+}
+
+void cSubMenuNode::SetType(enum Type type)
+{
+  _type = type;
+}
+
+
+cSubMenuNode::Type cSubMenuNode::GetType()
+{
+  return(_type);
+}
+
+const char *cSubMenuNode::GetTypeAsString()
+{
+  const char *str=NULL;
+  switch(_type) {
+     case SYSTEM:
+        str = TAG_SYSTEM;
+        break;
+     case COMMAND:
+        str = TAG_COMMAND;
+        break;
+     case THREAD:
+        str = TAG_THREAD;
+        break;
+     case PLUGIN:
+        str = TAG_PLUGIN;
+        break;
+     case MENU:
+        str = TAG_MENU;
+        break;
+     case UNDEFINED:
+        str = TAG_UNDEFINED;
+     default:
+        break;
+    }
+
+  return(str);
+}
+
+void cSubMenuNode::SetCommand(const char *command)
+{
+  if (_command != NULL)
+     free((void*)_command);
+
+  if (command != NULL)
+     _command = strdup(command);
+  else
+     _command = NULL;
+}
+
+const char *cSubMenuNode::GetCommand()
+{
+  return(_command);
+}
+
+bool cSubMenuNode::CommandConfirm()
+{
+  return(_commandConfirm);
+}
+
+void cSubMenuNode::SetCommandConfirm(int val)
+{
+  if (val == 1)
+     _commandConfirm = true;
+  else
+     _commandConfirm = false;
+}
+
+void cSubMenuNode::SetCustomTitle(const char *title)
+{
+  if (_title != NULL)
+     free((void*)_title);
+
+  if (title != NULL)
+     _title = strdup(title);
+  else
+     _title = NULL;
+}
+
+const char *cSubMenuNode::GetCustomTitle()
+{
+  return(_title);
+}
+
+void cSubMenuNode::SetName(const char *name)
+{
+  if (_name)
+     free ((void*)_name);
+
+  if (name != NULL)
+     _name = strdup(name);
+  else
+     _name = NULL;
+}
+
+const char *cSubMenuNode::GetName()
+{
+  return(_name);
+}
+
+int cSubMenuNode::GetLevel()
+{
+  return(_level);
+}
+
+void cSubMenuNode::SetLevel(int level)
+{
+  _level = level;
+  if (HasSubMenus()) { //Adjust Levels of Subnodes
+     for (cSubMenuNode *node = _subMenus.First(); node; node = _subMenus.Next(node))
+         node->SetLevel(level+1);
+     }
+}
+
+int cSubMenuNode::GetPluginIndex()
+{
+  return(_pluginIndex);
+}
+
+void cSubMenuNode::SetPluginIndex(int index)
+{
+  _pluginIndex = index;
+}
+
+void cSubMenuNode::SetPluginMainMenuEntry(const char *mainMenuEntry)
+{
+  if (_pluginMainMenuEntry != NULL)
+     free((void*)_pluginMainMenuEntry);
+
+  if (_title != NULL && strcmp(_title, "") != 0)
+     _pluginMainMenuEntry = strdup(_title);
+  else if (mainMenuEntry != NULL)
+     _pluginMainMenuEntry = strdup(mainMenuEntry);
+  else
+     _pluginMainMenuEntry = NULL;
+}
+
+const char *cSubMenuNode::GetPluginMainMenuEntry()
+{
+  return(_pluginMainMenuEntry);
+}
+
+
+cSubMenuNodes *cSubMenuNode::GetParentMenu()
+{
+  return(_parentMenu);
+}
+
+void cSubMenuNode::SetParentMenu(cSubMenuNodes *parent)
+{
+  _parentMenu = parent;
+}
+
+cSubMenuNodes *cSubMenuNode::GetCurrentMenu()
+{
+  return(_currentMenu);
+}
+
+void cSubMenuNode::SetCurrentMenu(cSubMenuNodes *current)
+{
+  _currentMenu = current;
+}
+
+
+cSubMenuNodes *cSubMenuNode::GetSubMenus()
+{
+  return(&_subMenus);
+}
+
+bool cSubMenuNode::HasSubMenus()
+{
+  if (_subMenus.Count() > 0)
+     return(true);
+  else
+     return(false);
+}
+
+
+void cSubMenuNode::Print(int index)
+{
+  for (int i = 0; i < index; i++)
+      printf(" ");
+
+  printf("Name=%s Type=%s Level=%d", _name, GetTypeAsString(), _level);
+  if (_type == COMMAND || _type == THREAD)
+     printf(" Command=%s", _command);
+  else if (_type == PLUGIN && _title != NULL)
+     printf(" Title=%s", _title);
+  printf("\n");
+
+  for (cSubMenuNode *node = _subMenus.First(); node; node = _subMenus.Next(node))
+      node->Print(index+4);
+}
+
+
+//################################################################################
+//#
+//################################################################################
+cSubMenu::cSubMenu()
+{
+  _commandResult         = NULL;
+  _currentMenuTree       = &_menuTree;
+  _currentParentMenuTree = NULL;
+#ifdef USE_PINPLUGIN
+  _currentParentIndex    = -1;
+#endif /* PINPLUGIN */
+  _nodeArray             = NULL;
+  _nrNodes               = 0;
+}
+
+
+cSubMenu::~cSubMenu()
+{
+  if (_commandResult)
+     free(_commandResult);
+  if (_nodeArray)
+     free(_nodeArray);
+  _nrNodes = 0;
+}
+
+
+bool cSubMenu::LoadXml(cString fname)
+{
+  TiXmlDocument  xmlDoc = TiXmlDocument(fname);
+  TiXmlElement  *root   = NULL;
+  cSubMenuNode  *node   = NULL;
+
+  bool  ok = true;
+  // Clear previously loaded Menu
+  _menuTree.Clear();
+  _fname = fname;
+
+  if ((ok = xmlDoc.LoadFile())) {
+     if ((root = xmlDoc.FirstChildElement("menus")) != NULL) {
+        cString tmp = root->Attribute("suffix");
+#ifdef USE_WAREAGLEICON
+        if      (strcmp(tmp, "ICON_FOLDER") == 0)      tmp = cString::sprintf(" %s", IsLangUtf8() ? ICON_FOLDER_UTF8 : ICON_FOLDER);
+        else if (strcmp(tmp, "ICON_MOVE_FOLDER") == 0) tmp = cString::sprintf(" %s", IsLangUtf8() ? ICON_MOVE_FOLDER_UTF8 : ICON_MOVE_FOLDER);
+#endif /* WAREAGLEICON */
+        if (*tmp)
+           _menuSuffix = tmp;
+        else
+           _menuSuffix = cString::sprintf(" ");
+
+        if ((root = root->FirstChildElement()) != NULL) {
+           do {
+              try {
+                 node = new cSubMenuNode(root, 0,  &_menuTree, NULL);
+#ifdef REELVDR
+                 const char* tmp_name = root->Attribute("name");
+                 //printf("%s : %i \n",tmp_name, node->SubMenuSize());
+                 if (tmp_name && strcmp("Additional Software",tmp_name) == 0 /*no translation of "Additional Software" here*/
+                              && node->SubMenuSize() <= 0) // empty submenu;
+                 // no additional plugins installed
+                 {
+                   delete node;
+                   node = NULL;
+                 }
+                 else
+#endif /* REELVDR */
+                 _menuTree.Add(node);
+                 }
+              catch (char *message) {
+                 esyslog("ERROR: while decoding XML Node");
+                 ok = false;
+                 }
+              } while (ok == true && (root = root->NextSiblingElement()) != NULL);
+#ifndef REELVDR
+           addMissingPlugins();
+#endif /* REELVDR */
+           removeUndefinedNodes();
+           }
+        }
+     else {
+        esyslog("ERROR: in %s, missing Tag <menus>\n", *fname);
+        ok = false;
+        }
+     }
+  else {
+     esyslog("ERROR: in %s : %s  Col=%d Row=%d\n",
+            *fname,
+            xmlDoc.ErrorDesc(),
+            xmlDoc.ErrorCol(),
+            xmlDoc.ErrorRow());
+     ok = false;
+     }
+
+  return(ok);
+}
+
+
+bool cSubMenu::SaveXml()
+{
+  return(SaveXml(_fname));
+}
+
+
+bool cSubMenu::SaveXml(cString fname)
+{
+  bool ok = true;
+
+  if (*_fname) {
+     TiXmlDocument xml = TiXmlDocument(fname);
+     TiXmlComment  comment;
+     comment.SetValue("\n\
+-    VDR Menu-Configuration File\n\
+-\n\
+-\n\
+-   Example:\n\
+-\n\
+ <menus>\n\
+    <system name=\"Schedule\" />\n\
+    <system name=\"Channels\" />\n\
+    <system name=\"Timers\" />\n\
+    <system name=\"Recordings\" />\n\
+    <menu name=\"System\">\n\
+        <system name=\"Setup\" />\n\
+        <system name=\"Commands\" />\n\
+        <plugin name=\"setup\" title=\"My Setup\" />\n\
+        <command name=\"myCommand1\" execute=\"/usr/bin/mycommand1\" />\n\
+        <command name=\"myCommand2\" execute=\"/usr/bin/mycommand2\" confirm=\"yes\" />\n\
+        <thread name=\"myCommand3\" execute=\"/usr/bin/mycommand3\" confirm=\"yes\" />\n\
+        <plugin name=\"epgsearch\" title=\"myProgram\" />\n\
+        <menu name=\"mySubSubMenu\">\n\
+            ...\n\
+        </menu>\n\
+    </menu>\n\
+     <menu name=\"Suche\">\n\
+        <plugin name=\"epgsearch\" />\n\
+        ...\n\
+    </menu>\n\
+ </menus>\n\
+");
+
+     TiXmlElement root("menus");
+     root.SetAttribute("suffix", _menuSuffix);
+     for (cSubMenuNode *node = _menuTree.First(); node; node = _menuTree.Next(node))
+         node->SaveXml(&root);
+
+         if (xml.InsertEndChild(comment) != NULL && xml.InsertEndChild(root) != NULL)
+            ok = xml.SaveFile(fname);
+     }
+  else
+     ok = false;
+
+  return(ok);
+}
+
+
+cSubMenuNodes *cSubMenu::GetMenuTree()
+{
+  return(_currentMenuTree);
+}
+
+
+void cSubMenu::PrintMenuTree()
+{
+  for (cSubMenuNode *node = _menuTree.First(); node; node = _menuTree.Next(node))
+      node->Print();
+}
+
+
+int cSubMenu::GetNrOfNodes()
+{
+  if (_nrNodes == 0) {
+     if ((_nrNodes = countNodes(&_menuTree)) > 0) {
+        _nodeArray = (cSubMenuNode**) malloc(sizeof(cSubMenuNode*)*_nrNodes);
+        int index = 0;
+        tree2Array(&_menuTree, index);
+        }
+     }
+
+  return(_nrNodes);
+}
+
+
+/**
+ * returns the specified node within the current menu
+ * @param index position in the current menu
+ * @return node or null if not found
+ */
+cSubMenuNode *cSubMenu::GetNode(int index)
+{
+  cSubMenuNode *node = NULL;
+  if (_currentMenuTree == NULL || (node=_currentMenuTree->Get(index)) == NULL)
+     esyslog("ERROR: illegal call of cSubMenu::GetNode(%d)", index);
+
+  return(node);
+}
+
+
+/**
+ * Get the specified Node
+ * @param index specfies the absolut indes in the list of all nodes
+ * @return node or NULL if not found
+ */
+cSubMenuNode *cSubMenu::GetAbsNode(int index)
+{
+  cSubMenuNode *node = NULL;
+  GetNrOfNodes();
+  if (_nrNodes > 0 && index >= 0 && index < _nrNodes)
+     node = _nodeArray[index];
+
+  return(node);
+}
+
+
+#ifdef USE_PINPLUGIN
+bool cSubMenu::Down(cSubMenuNode *node, int currentIndex)
+#else
+bool cSubMenu::Down(int index)
+#endif /* PINPLUGIN */
+{
+  bool ok = true;
+#ifdef USE_PINPLUGIN
+  if (_currentMenuTree != NULL && node && node->GetType() == cSubMenuNode::MENU) {
+#else
+  cSubMenuNode *node = NULL;
+
+  if (_currentMenuTree != NULL && (node=_currentMenuTree->Get(index)) != NULL && node->GetType() == cSubMenuNode::MENU) {
+#endif /* PINPLUGIN */
+     _currentParentMenuTree = _currentMenuTree;
+#ifdef USE_PINPLUGIN
+     _currentParentIndex = currentIndex;
+#endif /* PINPLUGIN */
+     _currentMenuTree = node->GetSubMenus();
+     }
+  else {
+     ok = false;
+#ifdef USE_PINPLUGIN
+     esyslog("ERROR: illegal call of cSubMenu::Down");
+#else
+     esyslog("ERROR: illegal call of cSubMenu::Down(%d)", index);
+#endif /* PINPLUGIN */
+     }
+
+  return(ok);
+}
+
+bool cSubMenu::Up(int *parentIndex)
+{
+  bool ok = true;
+
+  if (_currentMenuTree != NULL && parentIndex != NULL) {
+#ifndef USE_PINPLUGIN
+     cSubMenuNode *node = NULL;
+#endif /* PINPLUGIN */
+     *parentIndex = 0;
+#ifdef USE_PINPLUGIN
+     if (_currentParentIndex >= 0)
+        *parentIndex = _currentParentIndex;
+#else
+     if (_currentParentMenuTree != NULL)
+        for (int i = 0; (node = _currentParentMenuTree->Get(i)) != NULL; i++) {
+            if (_currentMenuTree == node->GetSubMenus()) {
+               *parentIndex = i;
+               break;
+               }
+            }
+#endif /* PINPLUGIN */
+
+     _currentMenuTree = _currentParentMenuTree;
+     if (_currentMenuTree != NULL)
+        _currentParentMenuTree = _currentMenuTree->Get(0)->GetParentMenu();
+     else
+        ok = false;
+     }
+  else {
+     ok = false;
+     esyslog("ERROR: illegal call of cSubMenu::Up()");
+     }
+
+  return(ok);
+}
+
+const char *cSubMenu::ExecuteCommand(const char *cmd)
+{
+  free(_commandResult);
+  _commandResult = NULL;
+
+  dsyslog("executing command '%s'", cmd);
+  FILE *p = popen(cmd, "r");
+  if (p) {
+     int l = 0;
+     int c;
+     while ((c = fgetc(p)) != EOF) {
+           if (l % 20 == 0)
+              _commandResult = (char *)realloc(_commandResult, l + 21);
+           _commandResult[l++] = c;
+           }
+     if (_commandResult)
+        _commandResult[l] = 0;
+     pclose(p);
+     }
+  else
+     esyslog("ERROR: can't open pipe for command '%s'", cmd);
+
+  return _commandResult;
+}
+
+/**
+ * Move Menu Entry to new Position
+ * @param index  index of menu entry to move 
+ * @param toIndex index of destination
+ * @param where After ore before the destination index
+ */
+void cSubMenu::MoveMenu(int index, int toIndex, enum Where where)
+{
+  if (index < 0 || index > _nrNodes || // invalid index is ignored
+     toIndex < 0 || toIndex > _nrNodes || index == toIndex)
+     return;
+
+  cSubMenuNode *srcNode  = GetAbsNode(index);
+  cSubMenuNode *destNode = GetAbsNode(toIndex);
+
+  if (where == cSubMenu::INTO && destNode->GetType() != cSubMenuNode::MENU)
+     return;
+
+  if (where == cSubMenu::INTO) {
+     if (destNode->GetType() == cSubMenuNode::MENU) {
+        srcNode->GetCurrentMenu()->Del(srcNode, false);
+        srcNode->SetLevel(destNode->GetLevel()+1);
+        srcNode->SetParentMenu(destNode->GetCurrentMenu());
+        srcNode->SetCurrentMenu(destNode->GetSubMenus());
+
+        destNode->GetSubMenus()->Add(srcNode);
+        reloadNodeArray();
+        }
+     }
+  else {
+     srcNode->GetCurrentMenu()->Del(srcNode, false);
+     srcNode->SetLevel(destNode->GetLevel());
+     srcNode->SetParentMenu(destNode->GetParentMenu());
+     srcNode->SetCurrentMenu(destNode->GetCurrentMenu());
+
+     if (where == cSubMenu::BEHIND) {
+        destNode->GetCurrentMenu()->Add(srcNode, GetAbsNode(toIndex));
+        reloadNodeArray();
+        }
+     else {
+        destNode->GetCurrentMenu()->Ins(srcNode, GetAbsNode(toIndex));
+        reloadNodeArray();
+        }
+     }
+}
+
+/**
+ * Create a new Menu Entry
+ * @param index index of destination
+ * @param menuTitle  Titel of new Menu entry
+ */
+void cSubMenu::CreateMenu(int index, const char *menuTitle)
+{
+  if (index >= 0 && index < _nrNodes) {
+     cSubMenuNode *srcNode  = GetAbsNode(index);
+     if (srcNode != NULL) {
+        cSubMenuNode *newNode = new cSubMenuNode(srcNode->GetParentMenu(), srcNode->GetCurrentMenu());
+        newNode->SetLevel(srcNode->GetLevel());
+        newNode->SetName(menuTitle);
+        newNode->SetType(cSubMenuNode::MENU);
+        newNode->SetParentMenu(srcNode->GetParentMenu());
+        newNode->SetCurrentMenu(srcNode->GetCurrentMenu());
+
+        srcNode->GetCurrentMenu()->Add(newNode, GetAbsNode(index));
+        reloadNodeArray();
+        }
+     }
+}
+
+/**
+ * delete the specified entry, or subtree if the specified entry is a menu
+ * @param index destion index 
+ */
+void cSubMenu::DeleteMenu(int index)
+{
+  if (index >= 0 && index < _nrNodes) {
+     cSubMenuNode *srcNode = GetAbsNode(index);
+     srcNode->GetCurrentMenu()->Del(srcNode, true);
+     reloadNodeArray();
+     }
+}
+
+
+// Private Methods
+
+int cSubMenu::countNodes(cSubMenuNodes *tree)
+{
+  int count = 0;
+  if (tree != NULL) {
+     for (cSubMenuNode *node = tree->First(); node; node = tree->Next(node)) {
+         count++;
+         if (node->HasSubMenus())
+            count += countNodes(node->GetSubMenus());
+         }
+     }
+  return(count);
+}
+
+
+void cSubMenu::tree2Array(cSubMenuNodes *tree, int &index)
+{
+  if (tree != NULL) {
+     for (cSubMenuNode *node = tree->First(); node; node = tree->Next(node)) {
+         _nodeArray[index++]=node;
+         if (node->HasSubMenus())
+            tree2Array(node->GetSubMenus(), index);
+         }
+     }
+
+}
+
+bool cSubMenu::IsPluginInMenu(const char *name)
+{
+  bool found = false;
+  for (int i = 0; i < _nrNodes && found == false; i++) {
+      cSubMenuNode *node = GetAbsNode(i);
+      if (node != NULL && node->GetType() == cSubMenuNode::PLUGIN && strcmp(name, node->GetName()) == 0)
+         found = true;
+      }
+  return(found);
+}
+
+/**
+ * Adds the given plugin to the Menu-Tree if not allready in List
+ * @param name specifies the name of the plugin
+ */
+void cSubMenu::AddPlugin(const char *name)
+{
+  if (! IsPluginInMenu(name)) {
+     cSubMenuNode *node = new  cSubMenuNode(&_menuTree, NULL);
+     node->SetName(name);
+     node->SetType("plugin");
+     node->SetPlugin();
+     _menuTree.Add(node);
+     }
+}
+
+void cSubMenu::addMissingPlugins()
+{
+  _nrNodes = GetNrOfNodes();
+  for (int i = 0; ; i++) {
+      cPlugin *p = cPluginManager::GetPlugin(i);
+      if (p)
+         AddPlugin(p->Name());
+      else
+         break;
+      }
+  reloadNodeArray();
+}
+
+/**
+ * Adds the given command to the Menu-Tree
+ * @param name specifies the name of the command
+ */
+void cSubMenu::CreateCommand(int index, const char *name, const char *execute, int confirm)
+{
+  if (index >= 0 && index < _nrNodes) {
+     cSubMenuNode *srcNode  = GetAbsNode(index);
+     if (srcNode != NULL) {
+        cSubMenuNode *newNode = new cSubMenuNode(srcNode->GetParentMenu(), srcNode->GetCurrentMenu());
+        newNode->SetLevel(srcNode->GetLevel());
+        newNode->SetName(name);
+        newNode->SetType("command");
+        newNode->SetCommand(execute);
+        newNode->SetCommandConfirm(confirm);
+        newNode->SetParentMenu(srcNode->GetParentMenu());
+        newNode->SetCurrentMenu(srcNode->GetCurrentMenu());
+
+        srcNode->GetCurrentMenu()->Add(newNode, GetAbsNode(index));
+        reloadNodeArray();
+        }
+     }
+}
+
+void cSubMenu::CreateThread(int index, const char *name, const char *execute, int confirm)
+{
+  if (index >= 0 && index < _nrNodes) {
+     cSubMenuNode *srcNode  = GetAbsNode(index);
+     if (srcNode != NULL) {
+        cSubMenuNode *newNode = new cSubMenuNode(srcNode->GetParentMenu(), srcNode->GetCurrentMenu());
+        newNode->SetLevel(srcNode->GetLevel());
+        newNode->SetName(name);
+        newNode->SetType("thread");
+        newNode->SetCommand(execute);
+        newNode->SetCommandConfirm(confirm);
+        newNode->SetParentMenu(srcNode->GetParentMenu());
+        newNode->SetCurrentMenu(srcNode->GetCurrentMenu());
+
+        srcNode->GetCurrentMenu()->Add(newNode, GetAbsNode(index));
+        reloadNodeArray();
+        }
+     }
+}
+
+/**
+ * reloads the internal Array of Nodes
+ */
+void cSubMenu::reloadNodeArray()
+{
+  if (_nrNodes > 0)
+     free(_nodeArray);
+  _nodeArray = NULL;
+  _nrNodes = 0;
+  _nrNodes = GetNrOfNodes();
+}
+
+/**
+ * remove Undefined Nodes
+ */
+void cSubMenu::removeUndefinedNodes()
+{
+  bool remove = false;
+
+  reloadNodeArray();
+  for (int i = 0; i < _nrNodes; i++) {
+      cSubMenuNode *node = GetAbsNode(i);
+      if (node != NULL && node->GetType() == cSubMenuNode::UNDEFINED) {
+         cSubMenuNodes *pMenu = node->GetCurrentMenu();
+         pMenu->Del(node, true);
+         remove = true;
+         }
+      }
+  if (remove)
+     reloadNodeArray();
+}
+
+
+/**
+* Retrieves the Menutitel of the parent Menu
+*/
+const char *cSubMenu::GetParentMenuTitel()
+{
+  const char *result = "";
+
+  if (_currentMenuTree != NULL && _currentParentMenuTree != NULL) {
+     cSubMenuNode *node = NULL;
+     for (int i = 0; (node = _currentParentMenuTree->Get(i)) != NULL; i++) {
+         if (_currentMenuTree == node->GetSubMenus()) {
+            result = node->GetName();
+            break;
+            }
+         }
+     }
+
+  return(result);
+}
+
+#endif
+#endif /* SETUP */
Index: submenu.h
===================================================================
--- submenu.h	(revision 15412)
+++ submenu.h	(revision 15413)
@@ -1,184 +1,190 @@
-#ifdef USE_SETUP
-/****************************************************************************
- * DESCRIPTION:
- *             Submenu
- *
- * $Id: vdr-1.3.44-Setup-0.3.0.diff,v 1.1 2006/03/04 09:58:47 ralf Exp $
- *
- * Contact:    ranga@teddycats.de
- *
- * Copyright (C) 2004, 2005 by Ralf Dotzert
- *
- * modified for the VDR Extensions Patch by zulu @vdr-portal
- ****************************************************************************/
-
-#ifndef SUBMENU_H
-#define SUBMENU_H
-
-#include "thread.h"
-#include "tools.h"
-#include <tinyxml/tinystr.h>
-#include <tinyxml/tinyxml.h>
-
-class cSubMenuNode;
-class cSubMenuNodes;
-class cSubMenu;
-
-
-class cSubMenuNodes : public cList<cSubMenuNode> {};
-
-// execute cmd thread
-class cExecCmdThread : public cThread {
-private:
-  cString ExecCmd;
-protected:
-  virtual void Action(void) {
-     if (system(ExecCmd) == 0)
-        esyslog("%s - finished", *ExecCmd);
-     delete(this);
-     };
-public:
-  cExecCmdThread(char *cmd) {
-     ExecCmd = cString::sprintf("%s", cmd);
-     }
-  cExecCmdThread(const char *cmd) {
-     ExecCmd = cString::sprintf("%s", cmd);
-     }
-  ~cExecCmdThread() {
-     };
-  };
-
-//################################################################################
-//# SubMenuNode
-//################################################################################
-class cSubMenuNode : public cListObject {
-public:
-#ifdef REELVDR
-  enum Type { UNDEFINED, SYSTEM, COMMAND, THREAD, PLUGIN, MENU, INCLUDE };
-#else
-   enum Type { UNDEFINED, SYSTEM, COMMAND, THREAD, PLUGIN, MENU };
-#endif /* REELVDR */
-  cSubMenuNode(TiXmlElement *xml, int level, cSubMenuNodes *currentMenu, cSubMenuNodes *parentMenu);
-  cSubMenuNode(cSubMenuNodes *currentMenu, cSubMenuNodes *parentMenu);
-  ~cSubMenuNode();
-  bool SaveXml(TiXmlElement *root);
-  static cSubMenuNode::Type IsType(const char *name);
-  void  SetType(const char *name);
-  void  SetType(enum Type type);
-#ifdef REELVDR
-  int SubMenuSize(){return _subMenus.Count();}
-  bool IncludeXml(const char *includeXML);
-  void SetHelp(const char *Help);
-  const char *GetHelp() {return _help;};
-  void SetInfo(const char *Info);
-  const char *GetInfo() {return _info;};
-  void SetIconNumber(const char* iconNumber);
-  const char *GetIconNumber() {return _iconNumber;};
-  void SetSetupLink(const char*name);
-  const char *GetSetupLink() {return _setupLink;};
-  void  SetPlugin(const char *link=NULL);
-#else
-  void  SetPlugin();
-#endif /* REELVDR */
-  cSubMenuNode::Type GetType();
-  const char *GetTypeAsString();
-  void SetCommand(const char *command);
-  bool CommandConfirm();
-  void SetCommandConfirm(int val);
-  const char *GetCommand();
-  void SetCustomTitle(const char *title);
-  const char *GetCustomTitle();
-  void SetName(const char *name);
-  const char*GetName();
-  int  GetLevel();
-  void SetLevel(int level);
-  int  GetPluginIndex();
-  void SetPluginIndex(int index);
-  void SetPluginMainMenuEntry(const char *mainMenuEntry);
-  const char *GetPluginMainMenuEntry();
-  cSubMenuNodes *GetParentMenu();
-  void SetParentMenu(cSubMenuNodes *parent);
-  cSubMenuNodes *GetCurrentMenu();
-  void SetCurrentMenu(cSubMenuNodes *current);
-  cSubMenuNodes *GetSubMenus();
-  bool HasSubMenus();
-  void Print(int index = 0);
-private:
-  Type _type;
-  int _level;
-  // Plugin Variables
-  int _pluginIndex;
-  const char *_pluginMainMenuEntry;
-  // common
-  const char *_name;
-  const char *_command;
-  bool _commandConfirm;
-  const char *_title;
-#ifdef REELVDR
-  const char *_help;
-  const char *_info;
-  const char *_iconNumber;
-  char *_setupLink;
-#endif /* REELVDR */
-  cSubMenuNodes _subMenus;
-  cSubMenuNodes *_parentMenu;
-  cSubMenuNodes *_currentMenu;
-  void init();
-  };
-
-
-//################################################################################
-//# SubMenu Class
-//################################################################################
-class cSubMenu {
-public:
-  cSubMenu();
-  ~cSubMenu();
-  enum Where { BEFORE, BEHIND, INTO};
-  bool LoadXml(cString fname);
-  bool SaveXml(cString fname);
-  bool SaveXml();
-  cSubMenuNodes *GetMenuTree();
-  bool Up(int *ParentIndex);
-#ifdef USE_PINPLUGIN
-  bool Down(cSubMenuNode* node, int currentIndex);
-#else
-  bool Down(int index);
-#endif /* PINPLUGIN */
-  int  GetNrOfNodes();
-  cSubMenuNode* GetAbsNode(int index);
-  cSubMenuNode* GetNode(int index);
-  void PrintMenuTree();
-  bool IsPluginInMenu(const char *name);
-  void AddPlugin(const char *name);
-  void CreateCommand(int index, const char *name, const char *execute, int confirm);
-  void CreateThread(int index, const char *name, const char *execute, int confirm);
-  const char *ExecuteCommand(const char *command);
-  void MoveMenu(int index, int toindex, enum Where);
-  void CreateMenu(int index, const char *menuTitle);
-  void DeleteMenu(int index);
-  cString GetMenuSuffix() { return _menuSuffix; }
-  void SetMenuSuffix(char *suffix) { _menuSuffix = suffix; }
-  bool isTopMenu() { return (_currentParentMenuTree == NULL); }
-  const char *GetParentMenuTitel();
-private:
-  cSubMenuNodes _menuTree;
-  cSubMenuNodes *_currentMenuTree;
-  cSubMenuNodes *_currentParentMenuTree;
-#ifdef USE_PINPLUGIN
-  int _currentParentIndex;
-#endif /* PINPLUGIN */
-  cString _fname;
-  char *_commandResult;
-  int _nrNodes;
-  cSubMenuNode **_nodeArray;
-  cString _menuSuffix;
-  int countNodes(cSubMenuNodes *tree);
-  void tree2Array(cSubMenuNodes *tree, int &index);
-  void addMissingPlugins();
-  void reloadNodeArray();
-  void removeUndefinedNodes();
-  };
-
-#endif //__SUBMENU_H
-#endif /* USE_SETUP */
+#ifdef USE_SETUP
+/****************************************************************************
+ * DESCRIPTION:
+ *             Submenu
+ *
+ * $Id: vdr-1.3.44-Setup-0.3.0.diff,v 1.1 2006/03/04 09:58:47 ralf Exp $
+ *
+ * Contact:    ranga@teddycats.de
+ *
+ * Copyright (C) 2004, 2005 by Ralf Dotzert
+ *
+ * modified for the VDR Extensions Patch by zulu @vdr-portal
+ ****************************************************************************/
+
+#ifndef SUBMENU_H
+#define SUBMENU_H
+
+#include "thread.h"
+#include "tools.h"
+#ifndef REELVDR
+#define TIXML_USE_STL
+#include <tinystr.h>
+#include <tinyxml.h>
+#else
+#include <tinyxml/tinystr.h>
+#include <tinyxml/tinyxml.h>
+#endif
+
+class cSubMenuNode;
+class cSubMenuNodes;
+class cSubMenu;
+
+
+class cSubMenuNodes : public cList<cSubMenuNode> {};
+
+// execute cmd thread
+class cExecCmdThread : public cThread {
+private:
+  cString ExecCmd;
+protected:
+  virtual void Action(void) {
+     if (system(ExecCmd) == 0)
+        esyslog("%s - finished", *ExecCmd);
+     delete(this);
+     };
+public:
+  cExecCmdThread(char *cmd) {
+     ExecCmd = cString::sprintf("%s", cmd);
+     }
+  cExecCmdThread(const char *cmd) {
+     ExecCmd = cString::sprintf("%s", cmd);
+     }
+  ~cExecCmdThread() {
+     };
+  };
+
+//################################################################################
+//# SubMenuNode
+//################################################################################
+class cSubMenuNode : public cListObject {
+public:
+#ifdef REELVDR
+  enum Type { UNDEFINED, SYSTEM, COMMAND, THREAD, PLUGIN, MENU, INCLUDE };
+#else
+  enum Type { UNDEFINED, SYSTEM, COMMAND, THREAD, PLUGIN, MENU };
+#endif /* REELVDR */
+  cSubMenuNode(TiXmlElement *xml, int level, cSubMenuNodes *currentMenu, cSubMenuNodes *parentMenu);
+  cSubMenuNode(cSubMenuNodes *currentMenu, cSubMenuNodes *parentMenu);
+  ~cSubMenuNode();
+  bool SaveXml(TiXmlElement *root);
+  static cSubMenuNode::Type IsType(const char *name);
+  void  SetType(const char *name);
+  void  SetType(enum Type type);
+#ifdef REELVDR
+  int SubMenuSize(){return _subMenus.Count();}
+  bool IncludeXml(const char *includeXML);
+  void SetHelp(const char *Help);
+  const char *GetHelp() {return _help;};
+  void SetInfo(const char *Info);
+  const char *GetInfo() {return _info;};
+  void SetIconNumber(const char* iconNumber);
+  const char *GetIconNumber() {return _iconNumber;};
+  void SetSetupLink(const char*name);
+  const char *GetSetupLink() {return _setupLink;};
+  void  SetPlugin(const char *link=NULL);
+#else
+  void  SetPlugin();
+#endif /* REELVDR */
+  cSubMenuNode::Type GetType();
+  const char *GetTypeAsString();
+  void SetCommand(const char *command);
+  bool CommandConfirm();
+  void SetCommandConfirm(int val);
+  const char *GetCommand();
+  void SetCustomTitle(const char *title);
+  const char *GetCustomTitle();
+  void SetName(const char *name);
+  const char*GetName();
+  int  GetLevel();
+  void SetLevel(int level);
+  int  GetPluginIndex();
+  void SetPluginIndex(int index);
+  void SetPluginMainMenuEntry(const char *mainMenuEntry);
+  const char *GetPluginMainMenuEntry();
+  cSubMenuNodes *GetParentMenu();
+  void SetParentMenu(cSubMenuNodes *parent);
+  cSubMenuNodes *GetCurrentMenu();
+  void SetCurrentMenu(cSubMenuNodes *current);
+  cSubMenuNodes *GetSubMenus();
+  bool HasSubMenus();
+  void Print(int index = 0);
+private:
+  Type _type;
+  int _level;
+  // Plugin Variables
+  int _pluginIndex;
+  const char *_pluginMainMenuEntry;
+  // common
+  const char *_name;
+  const char *_command;
+  bool _commandConfirm;
+  const char *_title;
+#ifdef REELVDR
+  const char *_help;
+  const char *_info;
+  const char *_iconNumber;
+  char *_setupLink;
+#endif /* REELVDR */
+  cSubMenuNodes _subMenus;
+  cSubMenuNodes *_parentMenu;
+  cSubMenuNodes *_currentMenu;
+  void init();
+  };
+
+
+//################################################################################
+//# SubMenu Class
+//################################################################################
+class cSubMenu {
+public:
+  cSubMenu();
+  ~cSubMenu();
+  enum Where { BEFORE, BEHIND, INTO};
+  bool LoadXml(cString fname);
+  bool SaveXml(cString fname);
+  bool SaveXml();
+  cSubMenuNodes *GetMenuTree();
+  bool Up(int *ParentIndex);
+#ifdef USE_PINPLUGIN
+  bool Down(cSubMenuNode* node, int currentIndex);
+#else
+  bool Down(int index);
+#endif /* PINPLUGIN */
+  int  GetNrOfNodes();
+  cSubMenuNode* GetAbsNode(int index);
+  cSubMenuNode* GetNode(int index);
+  void PrintMenuTree();
+  bool IsPluginInMenu(const char *name);
+  void AddPlugin(const char *name);
+  void CreateCommand(int index, const char *name, const char *execute, int confirm);
+  void CreateThread(int index, const char *name, const char *execute, int confirm);
+  const char *ExecuteCommand(const char *command);
+  void MoveMenu(int index, int toindex, enum Where);
+  void CreateMenu(int index, const char *menuTitle);
+  void DeleteMenu(int index);
+  cString GetMenuSuffix() { return _menuSuffix; }
+  void SetMenuSuffix(char *suffix) { _menuSuffix = suffix; }
+  bool isTopMenu() { return (_currentParentMenuTree == NULL); }
+  const char *GetParentMenuTitel();
+private:
+  cSubMenuNodes _menuTree;
+  cSubMenuNodes *_currentMenuTree;
+  cSubMenuNodes *_currentParentMenuTree;
+#ifdef USE_PINPLUGIN
+  int _currentParentIndex;
+#endif /* PINPLUGIN */
+  cString _fname;
+  char *_commandResult;
+  int _nrNodes;
+  cSubMenuNode **_nodeArray;
+  cString _menuSuffix;
+  int countNodes(cSubMenuNodes *tree);
+  void tree2Array(cSubMenuNodes *tree, int &index);
+  void addMissingPlugins();
+  void reloadNodeArray();
+  void removeUndefinedNodes();
+  };
+
+#endif //__SUBMENU_H
+#endif /* SETUP */
Index: eitscan.c
===================================================================
--- eitscan.c	(revision 15412)
+++ eitscan.c	(revision 15413)
@@ -151,9 +151,17 @@
                             if (Device->ProvidesTransponder(Channel)) {
                                if (!Device->Receiving()) {
                                   bool MaySwitchTransponder = Device->MaySwitchTransponder();
+#ifdef USE_LNBSHARE
+                                  if (MaySwitchTransponder && Device->GetMaxBadPriority(Channel) == -2 || (MaySwitchTransponder || Device->ProvidesTransponderExclusively(Channel)) && Device->GetMaxBadPriority(Channel) <= -1 && now - lastActivity > Setup.EPGScanTimeout * 3600) {
+#else
                                   if (MaySwitchTransponder || Device->ProvidesTransponderExclusively(Channel) && now - lastActivity > Setup.EPGScanTimeout * 3600) {
+#endif /* LNBSHARE */
                                      if (!MaySwitchTransponder) {
+#ifdef USE_LNBSHARE
+                                        if ((Device == cDevice::ActualDevice() || Device->GetMaxBadPriority(Channel) == -1) && !currentChannel) {
+#else
                                         if (Device == cDevice::ActualDevice() && !currentChannel) {
+#endif /* LNBSHARE */
                                            cDevice::PrimaryDevice()->StopReplay(); // stop transfer mode
                                            currentChannel = Device->CurrentChannel();
                                            Skins.Message(mtInfo, tr("Starting EPG scan"));
Index: dvbplayer.c
===================================================================
--- dvbplayer.c	(revision 15412)
+++ dvbplayer.c	(revision 15413)
@@ -204,6 +204,9 @@
   cNonBlockingFileReader *nonBlockingFileReader;
   cRingBufferFrame *ringBuffer;
   cPtsIndex ptsIndex;
+#ifdef USE_JUMPPLAY
+  cMarksReload marks;
+#endif /* JUMPPLAY */
   cFileName *fileName;
   cIndexFile *index;
   cUnbufferedFile *replayFile;
@@ -250,7 +253,11 @@
 int cDvbPlayer::Speeds[] = { 0, -2, -4, -8, 1, 2, 4, 12, 0 };
 
 cDvbPlayer::cDvbPlayer(const char *FileName)
+#ifdef USE_JUMPPLAY
+:cThread("dvbplayer"), marks(FileName)
+#else
 :cThread("dvbplayer")
+#endif /* JUMPPLAY */
 {
   nonBlockingFileReader = NULL;
   ringBuffer = NULL;
@@ -360,6 +367,12 @@
   if (index) {
      int Index = ptsIndex.FindIndex(DeviceGetSTC());
      if (Index >= 0) {
+#ifdef USE_JUMPPLAY
+        // set resume position to 0 if replay stops at the first mark
+        if (Setup.PlayJump && marks.First() &&
+            abs(Index - marks.First()->position) <= int(round(RESUMEBACKUP * framesPerSecond)))
+          Index = 0;
+#endif /* JUMPPLAY */
         Index -= int(round(RESUMEBACKUP * framesPerSecond));
         if (Index > 0)
            Index = index->GetNextIFrame(Index, false);
@@ -386,11 +399,30 @@
 {
   uchar *p = NULL;
   int pc = 0;
+#ifdef USE_JUMPPLAY
+  bool cutIn = false;
+  int total = -1;
+#endif /* JUMPPLAY */
 
   readIndex = Resume();
   if (readIndex >= 0)
      isyslog("resuming replay at index %d (%s)", readIndex, *IndexToHMSF(readIndex, true, framesPerSecond));
 
+#ifdef USE_JUMPPLAY
+  if (Setup.PlayJump && readIndex <= 0 && marks.First() && index) {
+    int Index = marks.First()->position;
+    uint16_t FileNumber;
+    off_t FileOffset;
+    if (index->Get(Index, &FileNumber, &FileOffset) &&
+      NextFile(FileNumber, FileOffset)) {
+      isyslog("PlayJump: start replay at first mark %d (%s)",
+              Index, *IndexToHMSF(Index, true, framesPerSecond));
+      readIndex = Index;
+      }
+    }
+
+  bool LastMarkPause = false;
+#endif /* JUMPPLAY */
   nonBlockingFileReader = new cNonBlockingFileReader;
   int Length = 0;
   bool Sleep = false;
@@ -415,7 +447,11 @@
 
           // Read the next frame from the file:
 
+#ifdef USE_JUMPPLAY
+          if (playMode != pmStill && playMode != pmPause && !LastMarkPause) {
+#else
           if (playMode != pmStill && playMode != pmPause) {
+#endif /* JUMPPLAY */
              if (!readFrame && (replayFile || readIndex >= 0)) {
                 if (!nonBlockingFileReader->Reading()) {
                    if (!SwitchToPlayFrame && (playMode == pmFast || (playMode == pmSlow && playDir == pdBackward))) {
@@ -452,6 +488,46 @@
                    else if (index) {
                       uint16_t FileNumber;
                       off_t FileOffset;
+#ifdef USE_JUMPPLAY
+                      if (Setup.PlayJump || Setup.PauseLastMark) {
+                         // check for end mark - jump to next mark or pause
+                         readIndex++;
+                         marks.Reload();
+                         cMark *m = marks.Get(readIndex);
+                         if (m && (m->Index() & 0x01) != 0) {
+                            m = marks.Next(m);
+                            int Index;
+                            if (m)
+                               Index = m->position;
+                            else if (Setup.PauseLastMark) {
+                               // pause at last mark
+                               isyslog("PauseLastMark: pause at position %d (%s)",
+                                       readIndex, *IndexToHMSF(readIndex, true, framesPerSecond));
+                               LastMarkPause = true;
+                               Index = -1;
+                               }
+                            else if (total == index->Last())
+                               // at last mark jump to end of recording
+                               Index = index->Last() - 1;
+                            else
+                               // jump but stay off end of live-recordings
+                               Index = index->GetNextIFrame(index->Last() - int(round(MAXSTUCKATEOF * framesPerSecond)), true);
+                            // don't jump in edited recordings
+                            if (Setup.PlayJump && Index > readIndex &&
+                                Index > index->GetNextIFrame(readIndex, true)) {
+                               isyslog("PlayJump: %d frames to %d (%s)",
+                                       Index - readIndex, Index,
+                                       *IndexToHMSF(Index, true, framesPerSecond));
+                               readIndex = Index;
+                               cutIn = true;
+                               }
+                            }
+                         readIndex--;
+                      }
+                      // for detecting growing length of live-recordings
+                      if (index->Get(readIndex + 1, &FileNumber, &FileOffset, &readIndependent) && readIndependent)
+                         total = index->Last();
+#endif /* JUMPPLAY */
                       if (index->Get(readIndex + 1, &FileNumber, &FileOffset, &readIndependent, &Length) && NextFile(FileNumber, FileOffset))
                          readIndex++;
                       else
@@ -496,6 +572,15 @@
              // Store the frame in the buffer:
 
              if (readFrame) {
+#ifdef USE_JUMPPLAY
+                if (cutIn) {
+                   if (isPesRecording)
+                      cRemux::SetBrokenLink(readFrame->Data(), readFrame->Count());
+                   else
+                      TsSetTeiOnBrokenPackets(readFrame->Data(), readFrame->Count());
+                   cutIn = false;
+                   }
+#endif /* JUMPPLAY */
                 if (ringBuffer->Put(readFrame))
                    readFrame = NULL;
                 else
@@ -561,8 +646,19 @@
                 p = NULL;
                 }
              }
+#ifdef USE_JUMPPLAY
+          else {
+             if (LastMarkPause) {
+                LastMarkPause = false;
+                playMode = pmPause;
+                }
+#else
           else
+#endif /* JUMPPLAY */
              Sleep = true;
+#ifdef USE_JUMPPLAY
+             }
+#endif /* JUMPPLAY */
 
           // Handle hitting begin/end of recording:
 
Index: plugin.c
===================================================================
--- plugin.c	(revision 15412)
+++ plugin.c	(revision 15413)
@@ -324,14 +324,14 @@
   char *p = strchr(s, ' ');
   if (p)
      *p = 0;
-#ifdef REELVDR
+#ifdef USE_PLUGINMISSING
   struct stat st;
   if (stat (cString::sprintf("%s/%s%s%s%s", directory, LIBVDR_PREFIX, s, SO_INDICATOR, APIVERSION), &st) && errno == ENOENT) {
      esyslog("WARN: missing plugin '%s'", s);
      fprintf(stderr, "vdr: missing plugin '%s'\n", s);
      }
   else
-#endif /*REELVDR*/
+#endif /* PLUGINMISSING */
   dlls.Add(new cDll(cString::sprintf("%s/%s%s%s%s", directory, LIBVDR_PREFIX, s, SO_INDICATOR, APIVERSION), Args));
   free(s);
 }
@@ -340,11 +340,11 @@
 {
   for (cDll *dll = dlls.First(); dll; dll = dlls.Next(dll)) {
       if (!dll->Load(Log))
-#ifdef REELVDR
+#ifdef USE_PLUGINMISSING
          ;
 #else
          return false;
-#endif /*REELVDR*/
+#endif /* PLUGINMISSING */
       }
   return true;
 }
Index: plugin.h
===================================================================
--- plugin.h	(revision 15412)
+++ plugin.h	(revision 15413)
@@ -45,6 +45,9 @@
 
   virtual const char *MainMenuEntry(void);
   virtual cOsdObject *MainMenuAction(void);
+#ifdef USE_MCLI
+  virtual cOsdObject *AltMenuAction(void) { return NULL; };
+#endif /* MCLI */
 
   virtual cMenuSetupPage *SetupMenu(void);
   virtual bool SetupParse(const char *Name, const char *Value);
Index: recorder.c
===================================================================
--- recorder.c	(revision 15412)
+++ recorder.c	(revision 15413)
@@ -87,7 +87,11 @@
 bool cRecorder::NextFile(void)
 {
   if (recordFile && frameDetector->IndependentFrame()) { // every file shall start with an independent frame
+#ifdef USE_HARDLINKCUTTER
+     if (fileSize > fileName->MaxFileSize() || RunningLowOnDiskSpace()) {
+#else
      if (fileSize > MEGABYTE(off_t(Setup.MaxVideoFileSize)) || RunningLowOnDiskSpace()) {
+#endif /* HARDLINKCUTTER */
         recordFile = fileName->NextFile();
         fileSize = 0;
         }
Index: eit.c
===================================================================
--- eit.c	(revision 15412)
+++ eit.c	(revision 15413)
@@ -27,7 +27,7 @@
 #ifdef USE_NOEPG
 private:
   bool allowedEPG(tChannelID kanalID);
-#endif /* USE_NOEPG */
+#endif /* NOEPG */
   };
 
 #ifdef USE_NOEPG
@@ -43,7 +43,7 @@
 
   return rc;
 }
-#endif /* USE_NOEPG */
+#endif /* NOEPG */
 
 cEIT::cEIT(cSchedules *Schedules, int Source, u_char Tid, const u_char *Data, bool OnlyRunningStatus)
 :SI::EIT(Data, false)
@@ -55,13 +55,14 @@
   cChannel *channel = Channels.GetByChannelID(channelID, true);
   if (!channel)
      return; // only collect data for known channels
+
 #ifdef USE_NOEPG
   // only use epg from channels not blocked by noEPG-patch
   tChannelID kanalID;
   kanalID = channel->GetChannelID();
   if (!allowedEPG(kanalID))
      return;
-#endif /* USE_NOEPG */
+#endif /* NOEPG */
 
   cSchedule *pSchedule = (cSchedule *)Schedules->GetSchedule(channel, true);
 
@@ -109,7 +110,87 @@
          uchar TableID = pEvent->TableID();
          if (TableID == 0x00) {
             if (pEvent->Version() == getVersionNumber())
+#ifdef USE_DDEPGENTRY
+            {
+               if(Setup.MixEpgAction == 0)
+                   continue;
+
+               //printf("in");
+               //printf("%s", pEvent->GetTimeString());
+               // to use the info of the original epg, update the extern one,
+               // if it has less info
+               SI::Descriptor *d;
+               SI::ExtendedEventDescriptors *ExtendedEventDescriptors = NULL;
+               //SI::ExtendedEventDescriptor *eed = NULL;
+               SI::ShortEventDescriptor *ShortEventDescriptor = NULL;
+               //SI::ShortEventDescriptor *sed = NULL;
+               //SI::TimeShiftedEventDescriptor *tsed = NULL;
+               //cLinkChannels *LinkChannels = NULL;
+               for (SI::Loop::Iterator it2; (d = SiEitEvent.eventDescriptors.getNext(it2));)
+               {
+                  if(d->getDescriptorTag() == SI::ShortEventDescriptorTag)
+                  {
+                     int LanguagePreferenceShort = -1;
+                     SI::ShortEventDescriptor *sed = (SI::ShortEventDescriptor *)d;
+                     if (I18nIsPreferredLanguage(Setup.EPGLanguages, sed->languageCode, LanguagePreferenceShort) || !ShortEventDescriptor)
+                     {
+                        delete ShortEventDescriptor;
+                        ShortEventDescriptor = sed;
+                        d = NULL; // so that it is not deleted
+                     }
+                  }
+                  else if(d->getDescriptorTag() == SI::ExtendedEventDescriptorTag)
+                  {
+                     int LanguagePreferenceExt = -1;
+                     bool UseExtendedEventDescriptor = false;
+                     SI::ExtendedEventDescriptor *eed = (SI::ExtendedEventDescriptor *)d;
+                     if (I18nIsPreferredLanguage(Setup.EPGLanguages, eed->languageCode, LanguagePreferenceExt) || !ExtendedEventDescriptors)
+                     {
+                        delete ExtendedEventDescriptors;
+                        ExtendedEventDescriptors = new SI::ExtendedEventDescriptors;
+                        UseExtendedEventDescriptor = true;
+                     }
+                     if (UseExtendedEventDescriptor)
+                     {
+                        ExtendedEventDescriptors->Add(eed);
+                        d = NULL; // so that it is not deleted
+                     }
+                     if (eed->getDescriptorNumber() == eed->getLastDescriptorNumber())
+                        UseExtendedEventDescriptor = false;
+                  }
+                  delete d;
+               }
+               if(pEvent)
+               {
+
+                  if(ShortEventDescriptor)
+                  {
+                     char buffer[256];
+                     if(ShortEventDescriptor->text.getText(buffer, sizeof(buffer)) && pEvent->ShortText() && (strlen(ShortEventDescriptor->text.getText(buffer, sizeof(buffer))) > strlen(pEvent->ShortText())))
+                     {
+                        pEvent->SetShortText(ShortEventDescriptor->text.getText(buffer, sizeof(buffer)));
+                        pEvent->FixEpgBugs();
+                     }
+                  }
+                  if(ExtendedEventDescriptors)
+                  {
+                     char buffer[ExtendedEventDescriptors->getMaximumTextLength(": ") + 1];
+                     //pEvent->SetDescription(ExtendedEventDescriptors->getText(buffer, sizeof(buffer), ": "));
+
+                     if(ExtendedEventDescriptors->getText(buffer, sizeof(buffer), ": ") && pEvent->Description() && (strlen(ExtendedEventDescriptors->getText(buffer, sizeof(buffer), ": ")) > strlen(pEvent->Description())))
+                     {
+                        pEvent->SetDescription(ExtendedEventDescriptors->getText(buffer, sizeof(buffer), ": "));
+                        pEvent->FixEpgBugs();
+                     }
+                  }
+               }
+               delete ExtendedEventDescriptors;
+               delete ShortEventDescriptor;
                continue;
+            }
+#else
+               continue;
+#endif /* DDEPGENTRY */
             HasExternalData = ExternalData = true;
             }
          // If the new event has a higher table ID, let's skip it.
@@ -134,7 +215,11 @@
       if (newEvent)
          pSchedule->AddEvent(newEvent);
       if (Tid == 0x4E) { // we trust only the present/following info on the actual TS
+#ifdef USE_DDEPGENTRY
+         if (Setup.DisableVPS == 0 && SiEitEvent.getRunningStatus() >= SI::RunningStatusNotRunning)
+#else
          if (SiEitEvent.getRunningStatus() >= SI::RunningStatusNotRunning)
+#endif /* DDEPGENTRY */
             pSchedule->SetRunningStatus(pEvent, SiEitEvent.getRunningStatus(), channel);
          }
       if (OnlyRunningStatus)
@@ -323,6 +408,82 @@
       if (LinkChannels)
          channel->SetLinkChannels(LinkChannels);
       Modified = true;
+
+#ifdef USE_DDEPGENTRY
+      //to avoid double epg-entrys from ext and int epg sources :EW
+      if (pEvent && pEvent->TableID() != 0x00)
+         {
+         cEvent *pPreviousEvent = (cEvent *)pSchedule->GetPreviousEvent(pEvent);
+
+         if (pPreviousEvent)
+            {
+            if(Setup.DoubleEpgAction == 0)
+               {
+               pPreviousEvent->SetStartTime(pEvent->StartTime());
+               pPreviousEvent->SetDuration(pEvent->Duration());
+
+               if(Setup.DisableVPS == 0)
+                  {
+                  if(channel)
+                     pPreviousEvent->SetRunningStatus(pEvent->RunningStatus(), channel);
+                  else
+                     pPreviousEvent->SetRunningStatus(pEvent->RunningStatus());
+                  }
+
+               // to use the info of the original epg, update the extern one,
+               // if it has less info
+               char buffer_short_intern[256];
+               char buffer_short_extern[256];
+               int len_short_intern = 0;
+               int len_short_extern = 0;
+
+               if (pEvent->ShortText())
+                  len_short_intern = snprintf (buffer_short_intern, sizeof(buffer_short_intern), "%s", pEvent->ShortText());
+
+               if (pPreviousEvent->ShortText())
+                  len_short_extern = snprintf (buffer_short_extern, sizeof(buffer_short_extern), "%s",pPreviousEvent->ShortText());
+
+               if(len_short_intern > 0)
+                  {
+                  if(len_short_extern < 1)
+                     pPreviousEvent->SetShortText(buffer_short_intern);
+                  else if (len_short_intern > len_short_extern)
+                     pPreviousEvent->SetShortText(buffer_short_intern);
+                  }
+
+               if(pEvent->Description())
+                  {
+                  char buffer_title_intern[4096];
+                  char buffer_title_extern[4096];
+                  int len_title_intern = 0;
+                  int len_title_extern = 0;
+
+                  if (pEvent->Description())
+                     len_title_intern = snprintf (buffer_title_intern, sizeof(buffer_title_intern), "%s", pEvent->Description());
+
+                  if (pPreviousEvent->Description())
+                     len_title_extern = snprintf (buffer_title_extern, sizeof(buffer_title_extern), "%s", pPreviousEvent->Description());
+
+                  if(len_title_intern > 0)
+                     {
+                     if(len_title_extern < 1)
+                        pPreviousEvent->SetDescription(buffer_title_intern);
+                     else if (len_title_intern > len_title_extern)
+                        pPreviousEvent->SetDescription(buffer_title_intern);
+                     }
+                  }
+
+               if(pPreviousEvent->Vps() == 0 && pEvent->Vps() != 0)
+                  pPreviousEvent->SetVps(pEvent->Vps());
+
+               pSchedule->DelEvent(pEvent);
+               pPreviousEvent->FixEpgBugs();
+               }
+            else
+               pSchedule->DelEvent(pPreviousEvent);
+            }
+         }
+#endif /* DDEPGENTRY */
       }
   if (Tid == 0x4E) {
      if (Empty && getSectionNumber() == 0)
Index: lirc.c
===================================================================
--- lirc.c	(revision 15412)
+++ lirc.c	(revision 15413)
@@ -12,7 +12,11 @@
 #include "lirc.h"
 #include <netinet/in.h>
 #include <sys/socket.h>
+#ifdef USE_LIRCSETTINGS
+#include "config.h"
+#endif /* LIRCSETTINGS */
 
+
 #define REPEATDELAY 350 // ms
 #define REPEATFREQ 100 // ms
 #define REPEATTIMEOUT 500 // ms
@@ -94,7 +98,11 @@
               continue;
               }
            if (count == 0) {
+#ifdef USE_LIRCSETTINGS
+              if (strcmp(KeyName, LastKeyName) == 0 && FirstTime.Elapsed() < (unsigned int)Setup.LircRepeatDelay)
+#else
               if (strcmp(KeyName, LastKeyName) == 0 && FirstTime.Elapsed() < REPEATDELAY)
+#endif /* LIRCSETTINGS */
                  continue; // skip keys coming in too fast
               if (repeat)
                  Put(LastKeyName, false, true);
@@ -104,18 +112,34 @@
               timeout = -1;
               }
            else {
+#ifdef USE_LIRCSETTINGS
+              if (LastTime.Elapsed() < (unsigned int)Setup.LircRepeatFreq)
+#else
               if (LastTime.Elapsed() < REPEATFREQ)
+#endif /* LIRCSETTINGS */
                  continue; // repeat function kicks in after a short delay (after last key instead of first key)
+#ifdef USE_LIRCSETTINGS
+              if (FirstTime.Elapsed() < (unsigned int)Setup.LircRepeatDelay)
+#else
               if (FirstTime.Elapsed() < REPEATDELAY)
+#endif /* LIRCSETTINGS */
                  continue; // skip keys coming in too fast (for count != 0 as well)
               repeat = true;
+#ifdef USE_LIRCSETTINGS
+              timeout = Setup.LircRepeatDelay;
+#else
               timeout = REPEATDELAY;
+#endif /* LIRCSETTINGS */
               }
            LastTime.Set();
            Put(KeyName, repeat);
            }
         else if (repeat) { // the last one was a repeat, so let's generate a release
+#ifdef USE_LIRCSETTINGS
+           if (LastTime.Elapsed() >= (unsigned int)Setup.LircRepeatTimeout) {
+#else
            if (LastTime.Elapsed() >= REPEATTIMEOUT) {
+#endif /* LIRCSETTINGS */
               Put(LastKeyName, false, true);
               repeat = false;
               *LastKeyName = 0;
Index: ci.c
===================================================================
--- ci.c	(revision 15412)
+++ ci.c	(revision 15413)
@@ -1911,6 +1911,10 @@
          AddPid(Channel->Sid(), *Apid, STREAM_TYPE_AUDIO);
      for (const int *Dpid = Channel->Dpids(); *Dpid; Dpid++)
          AddPid(Channel->Sid(), *Dpid, STREAM_TYPE_DOLBY);
+#ifdef USE_TTXTSUBS
+     if (Channel->Tpid() && Setup.SupportTeletext)
+        AddPid(Channel->Sid(), Channel->Tpid(), STREAM_TYPE_DOLBY);
+#endif /* TTXTSUBS */
      }
 }
 
@@ -1932,6 +1936,11 @@
          CaPmt.AddPid(*Apid, STREAM_TYPE_AUDIO);
      for (const int *Dpid = Channel->Dpids(); *Dpid; Dpid++)
          CaPmt.AddPid(*Dpid, STREAM_TYPE_DOLBY);
+#ifdef USE_TTXTSUBS
+     if (Channel->Tpid() && Setup.SupportTeletext) {
+        CaPmt.AddPid(Channel->Tpid(), STREAM_TYPE_DOLBY); // FIXME: STREAM_TYPE_DOLBY should probably be renamed STREAM_TYPE_PRIVATE
+        }
+#endif /* TTXTSUBS */
      cas->SendPMT(&CaPmt);
      cTimeMs Timeout(QUERY_REPLY_TIMEOUT);
      do {
Index: remux.c
===================================================================
--- remux.c	(revision 15412)
+++ remux.c	(revision 15413)
@@ -215,6 +215,32 @@
   return i;
 }
 
+#ifdef USE_TTXTSUBS
+int cPatPmtGenerator::MakeTeletextDescriptor(uchar *Target, const tTeletextSubtitlePage *pages, int pageCount)
+{
+  int i = 0, j = 0;
+  Target[i++] = SI::TeletextDescriptorTag;
+  int l = i;
+  Target[i++] = 0x00; // length
+  for (int n = 0; n < pageCount; n++) {
+      const char* Language = pages[n].ttxtLanguage;
+      Target[i++] = *Language++;
+      Target[i++] = *Language++;
+      Target[i++] = *Language++;
+      Target[i++] = (pages[n].ttxtType << 3) + pages[n].ttxtMagazine;
+      Target[i++] = pages[n].ttxtPage;
+      j++;
+      }
+  if (j > 0) {
+     Target[l] = j * 5; // update length
+     IncEsInfoLength(i);
+     return i;
+     }
+  return 0;
+}
+
+#endif /* TTXTSUBS */
+
 int cPatPmtGenerator::MakeLanguageDescriptor(uchar *Target, const char *Language)
 {
   int i = 0;
@@ -302,6 +328,9 @@
   if (Channel) {
      int Vpid = Channel->Vpid();
      int Ppid = Channel->Ppid();
+#ifdef USE_TTXTSUBS
+     int Tpid = Channel->Tpid();
+#endif /* TTXTSUBS */
      uchar *p = buf;
      int i = 0;
      p[i++] = 0x02; // table id
@@ -334,6 +363,12 @@
          i += MakeStream(buf + i, 0x06, Channel->Spid(n));
          i += MakeSubtitlingDescriptor(buf + i, Channel->Slang(n), Channel->SubtitlingType(n), Channel->CompositionPageId(n), Channel->AncillaryPageId(n));
          }
+#ifdef USE_TTXTSUBS
+     if (Tpid) {
+        i += MakeStream(buf + i, 0x06, Tpid);
+        i += MakeTeletextDescriptor(buf + i, Channel->TeletextSubtitlePages(), Channel->TotalTeletextSubtitlePages());
+        }
+#endif /* TTXTSUBS */
 
      int sl = i - SectionLength - 2 + 4; // -2 = SectionLength storage, +4 = length of CRC
      buf[SectionLength] |= (sl >> 8) & 0x0F;
@@ -407,6 +442,9 @@
   pmtPid = -1;
   vpid = vtype = 0;
   ppid = 0;
+#ifdef USE_TTXTSUBS
+  tpid = 0;
+#endif /* TTXTSUBS */
 }
 
 void cPatPmtParser::ParsePat(const uchar *Data, int Length)
@@ -492,11 +530,17 @@
      int NumSpids = 0;
      vpid = vtype = 0;
      ppid = 0;
+#ifdef USE_TTXTSUBS
+     tpid = 0;
+#endif /* TTXTSUBS */
      apids[0] = 0;
      dpids[0] = 0;
      spids[0] = 0;
      atypes[0] = 0;
      dtypes[0] = 0;
+#ifdef USE_TTXTSUBS
+     totalTtxtSubtitlePages = 0;
+#endif /* TTXTSUBS */
      SI::PMT::Stream stream;
      for (SI::Loop::Iterator it; Pmt.streamLoop.getNext(stream, it); ) {
          dbgpatpmt("     stream type = %02X, pid = %d", stream.getStreamType(), stream.getPid());
@@ -595,6 +639,30 @@
                                     spids[NumSpids]= 0;
                                     }
                                  break;
+#ifdef USE_TTXTSUBS
+                            case SI::TeletextDescriptorTag: {
+                                 dbgpatpmt(" teletext");
+                                 tpid = stream.getPid();
+                                 SI::TeletextDescriptor *sd = (SI::TeletextDescriptor *)d;
+                                 SI::TeletextDescriptor::Teletext ttxt;
+                                 if (totalTtxtSubtitlePages < MAXTXTPAGES) {
+                                    for (SI::Loop::Iterator it; sd->teletextLoop.getNext(ttxt, it); ) {
+                                        bool isSubtitlePage = (ttxt.getTeletextType() == 0x02) || (ttxt.getTeletextType() == 0x05);
+                                        if (isSubtitlePage && ttxt.languageCode[0]) {
+                                           dbgpatpmt(" '%s:%x.%x'", ttxt.languageCode, ttxt.getTeletextMagazineNumber(), ttxt.getTeletextPageNumber());
+                                           strn0cpy(teletextSubtitlePages[totalTtxtSubtitlePages].ttxtLanguage, I18nNormalizeLanguageCode(ttxt.languageCode), MAXLANGCODE1);
+                                           teletextSubtitlePages[totalTtxtSubtitlePages].ttxtPage = ttxt.getTeletextPageNumber();
+                                           teletextSubtitlePages[totalTtxtSubtitlePages].ttxtMagazine = ttxt.getTeletextMagazineNumber();
+                                           teletextSubtitlePages[totalTtxtSubtitlePages].ttxtType = ttxt.getTeletextType();
+                                           totalTtxtSubtitlePages++;
+                                           if (totalTtxtSubtitlePages >= MAXTXTPAGES)
+                                              break;
+                                           }
+                                        }
+                                    }
+                                 }
+                                 break;
+#endif /* TTXTSUBS */
                             case SI::ISO639LanguageDescriptorTag: {
                                  SI::ISO639LanguageDescriptor *ld = (SI::ISO639LanguageDescriptor *)d;
                                  dbgpatpmt(" '%s'", ld->languageCode);
Index: config.c
===================================================================
--- config.c	(revision 15412)
+++ config.c	(revision 15413)
@@ -393,6 +393,12 @@
   strcpy(OSDLanguage, ""); // default is taken from environment
   strcpy(OSDSkin, "sttng");
   strcpy(OSDTheme, "default");
+#ifdef USE_VALIDINPUT
+  ShowValidInput = 0;
+#endif /* VALIDINPUT */
+#ifdef USE_WAREAGLEICON
+  WarEagleIcons = 1;
+#endif /* WAREAGLEICON */
   PrimaryDVB = 1;
   ShowInfoOnChSwitch = 1;
   TimeoutRequChInfo = 1;
@@ -411,13 +417,27 @@
   TimeTransponder = 0;
   MarginStart = 2;
   MarginStop = 10;
+#ifdef USE_JUMPINGSECONDS
+  JumpSeconds = 60;
+  JumpSecondsSlow = 10;
+  JumpSecondsRepeat = 300;
+#endif /* JUMPINGSECONDS */
   AudioLanguages[0] = -1;
   DisplaySubtitles = 0;
+#ifdef USE_TTXTSUBS
+  SupportTeletext = 0;
+#endif /* TTXTSUBS */
   SubtitleLanguages[0] = -1;
   SubtitleOffset = 0;
   SubtitleFgTransparency = 0;
   SubtitleBgTransparency = 0;
   EPGLanguages[0] = -1;
+#ifdef USE_DDEPGENTRY
+  DoubleEpgTimeDelta = 15;
+  DoubleEpgAction = 0;
+  MixEpgAction = 0;
+  DisableVPS = 0;
+#endif /* DDEPGENTRY */
   EPGScanTimeout = 5;
   EPGBugfixLevel = 3;
   EPGLinger = 0;
@@ -439,6 +459,9 @@
   VideoDisplayFormat = 1;
   VideoFormat = 0;
   UpdateChannels = 5;
+#ifdef USE_CHANNELBIND
+  ChannelBindingByRid = 0;
+#endif /* CHANNELBIND */
   UseDolbyDigital = 1;
   ChannelInfoPos = 0;
   ChannelInfoTime = 5;
@@ -464,6 +487,10 @@
   FontSmlSize = 18;
   FontFixSize = 20;
   MaxVideoFileSize = MAXVIDEOFILESIZEDEFAULT;
+#ifdef USE_HARDLINKCUTTER
+  MaxRecordingSize = DEFAULTRECORDINGSIZE;
+  HardLinkCutter = 0;
+#endif /* HARDLINKCUTTER */
   SplitEditedFiles = 0;
   DelTimeshiftRec = 0;
   MinEventTimeout = 30;
@@ -472,17 +499,57 @@
   MultiSpeedMode = 0;
   ShowReplayMode = 0;
   ResumeID = 0;
+#ifdef USE_JUMPPLAY
+  JumpPlay = 0;
+  PlayJump = 0;
+  PauseLastMark = 0;
+  ReloadMarks = 0;
+#endif /* JUMPPLAY */
   CurrentChannel = -1;
   CurrentVolume = MAXVOLUME;
   CurrentDolby = 0;
+#ifdef USE_CHANNELPROVIDE
+  LocalChannelProvide = 1;
+#endif /* CHANNELPROVIDE */
   InitialChannel = 0;
   InitialVolume = -1;
+#ifdef USE_VOLCTRL
+  LRVolumeControl = 0;
+  LRChannelGroups = 1;
+  LRForwardRewind = 1;
+#endif /* VOLCTRL */
   ChannelsWrap = 0;
   EmergencyExit = 1;
+#ifdef USE_LIEMIEXT
+  ShowRecDate = 1;
+  ShowRecTime = 1;
+  ShowRecLength = 0;
+  ShowProgressBar = 0;
+  MenuCmdPosition = 0;
+#endif /* LIEMIEXT */
+#ifdef USE_LIRCSETTINGS
+  LircRepeatDelay = 350;
+  LircRepeatFreq = 100;
+  LircRepeatTimeout = 500;
+#endif /* LIRCSETTINGS */
+#ifdef USE_LNBSHARE
+  VerboseLNBlog = 0;
+  for (int i = 0; i < MAXDEVICES; i++) CardUsesLnbNr[i] = i + 1;
+#endif /* LNBSHARE */
 #ifdef USE_NOEPG
   noEPGMode = 0;
   noEPGList = NULL;
-#endif /* USE_NOEPG */
+#endif /* NOEPG */
+#ifdef USE_DVLVIDPREFER
+  UseVidPrefer = 0; // default = disabled
+  nVidPrefer = 1;
+  for (int zz = 1; zz < DVLVIDPREFER_MAX; zz++) {
+      VidPreferPrio[ zz ] = 50;
+      VidPreferSize[ zz ] = 100;
+      }
+  VidPreferSize[ 0 ] = 800;
+  VidPreferPrio[ 0 ] = 50;
+#endif /* DVLVIDPREFER */
 #ifdef REELVDR
   LiveBuffer = 0;
   LiveBufferSize = 30;
@@ -514,7 +581,7 @@
   if (noEPGList)
      free(noEPGList);
 }
-#endif /* USE_NOEPG */
+#endif /* NOEPG */
 
 cSetup& cSetup::operator= (const cSetup &s)
 {
@@ -526,7 +593,7 @@
      }
   if (s.noEPGList)
      noEPGList = strdup(s.noEPGList);
-#endif /* USE_NOEPG */
+#endif /* NOEPG */
   return *this;
 }
 
@@ -625,8 +692,38 @@
 bool cSetup::Parse(const char *Name, const char *Value)
 {
   if      (!strcasecmp(Name, "OSDLanguage"))       { strn0cpy(OSDLanguage, Value, sizeof(OSDLanguage)); I18nSetLocale(OSDLanguage); }
+#ifdef REELVDR
+  else if (!strcasecmp(Name, "LiveBuffer"))          LiveBuffer         = atoi(Value);
+  else if (!strcasecmp(Name, "LiveBufferSize"))      LiveBufferSize     = atoi(Value);
+  else if (!strcasecmp(Name, "LiveTvOnAvg"))         LiveTvOnAvg        = atoi(Value);
+  else if (!strcasecmp(Name, "ReceptionMode"))       ReceptionMode      = (eReceiverType)atoi(Value);
+  else if (!strcasecmp(Name, "NetServerName"))       Utf8Strn0Cpy(NetServerName, Value, MAXHOSTNAME);
+  else if (!strcasecmp(Name, "NetServerMAC"))        Utf8Strn0Cpy(NetServerMAC, Value, MACLENGTH);
+  else if (!strcasecmp(Name, "ExpertOptions"))       ExpertOptions      = atoi(Value);
+  else if (!strcasecmp(Name, "OSDRandom"))           OSDRandom          = atoi(Value);
+  else if (!strcasecmp(Name, "OSDRemainTime"))       OSDRemainTime      = atoi(Value);
+  else if (!strcasecmp(Name, "OSDUseSymbol"))        OSDUseSymbol       = atoi(Value);
+  else if (!strcasecmp(Name, "OSDScrollBarWidth"))   OSDScrollBarWidth  = atoi(Value);
+  else if (!strcasecmp(Name, "FontSizes"))           FontSizes          = atoi(Value);
+  else if (!strcasecmp(Name, "AddNewChannels"))      AddNewChannels     = atoi(Value);
+  else if (!strcasecmp(Name, "NetServerIP"))         Utf8Strn0Cpy(NetServerIP, Value, MAXHOSTIP);
+  else if (!strcasecmp(Name, "ReelboxMode"))         ReelboxMode        = (eReelboxMode)atoi(Value);
+  else if (!strcasecmp(Name, "RequestShutDownMode")) RequestShutDownMode= atoi(Value);
+  else if (!strcasecmp(Name, "StandbyOrQuickshutdown")) StandbyOrQuickshutdown  = atoi(Value);
+  else if (!strcasecmp(Name, "UseBouquetList"))      UseBouquetList     = atoi(Value);
+  else if (!strcasecmp(Name, "OnlyRadioChannels"))   OnlyRadioChannels  = atoi(Value);
+  else if (!strcasecmp(Name, "OnlyEncryptedChannels"))OnlyEncryptedChannels = atoi(Value);
+  else if (!strcasecmp(Name, "OnlyHDChannels"))      OnlyHDChannels       = atoi(Value);
+  else if (!strcasecmp(Name, "ExpertNavi"))          ExpertNavi         = atoi(Value);
+#endif /* REELVDR */
   else if (!strcasecmp(Name, "OSDSkin"))             Utf8Strn0Cpy(OSDSkin, Value, MaxSkinName);
   else if (!strcasecmp(Name, "OSDTheme"))            Utf8Strn0Cpy(OSDTheme, Value, MaxThemeName);
+#ifdef USE_VALIDINPUT
+  else if (!strcasecmp(Name, "ShowValidInput"))      ShowValidInput     = atoi(Value);
+#endif /* VALIDINPUT */
+#ifdef USE_WAREAGLEICON
+  else if (!strcasecmp(Name, "WarEagleIcons"))       WarEagleIcons      = atoi(Value);
+#endif /* WAREAGLEICON */
   else if (!strcasecmp(Name, "PrimaryDVB"))          PrimaryDVB         = atoi(Value);
   else if (!strcasecmp(Name, "ShowInfoOnChSwitch"))  ShowInfoOnChSwitch = atoi(Value);
   else if (!strcasecmp(Name, "TimeoutRequChInfo"))   TimeoutRequChInfo  = atoi(Value);
@@ -645,13 +742,27 @@
   else if (!strcasecmp(Name, "TimeTransponder"))     TimeTransponder    = atoi(Value);
   else if (!strcasecmp(Name, "MarginStart"))         MarginStart        = atoi(Value);
   else if (!strcasecmp(Name, "MarginStop"))          MarginStop         = atoi(Value);
+#ifdef USE_JUMPINGSECONDS
+  else if (!strcasecmp(Name, "JumpSeconds"))         JumpSeconds        = atoi(Value); 
+  else if (!strcasecmp(Name, "JumpSecondsSlow"))     JumpSecondsSlow    = atoi(Value);
+  else if (!strcasecmp(Name, "JumpSecondsRepeat"))   JumpSecondsRepeat  = atoi(Value);  
+#endif /* JUMPINGSECONDS */
   else if (!strcasecmp(Name, "AudioLanguages"))      return ParseLanguages(Value, AudioLanguages);
   else if (!strcasecmp(Name, "DisplaySubtitles"))    DisplaySubtitles   = atoi(Value);
+#ifdef USE_TTXTSUBS
+  else if (!strcasecmp(Name, "SupportTeletext"))     SupportTeletext    = atoi(Value);
+#endif /* TTXTSUBS */
   else if (!strcasecmp(Name, "SubtitleLanguages"))   return ParseLanguages(Value, SubtitleLanguages);
   else if (!strcasecmp(Name, "SubtitleOffset"))      SubtitleOffset     = atoi(Value);
   else if (!strcasecmp(Name, "SubtitleFgTransparency")) SubtitleFgTransparency = atoi(Value);
   else if (!strcasecmp(Name, "SubtitleBgTransparency")) SubtitleBgTransparency = atoi(Value);
   else if (!strcasecmp(Name, "EPGLanguages"))        return ParseLanguages(Value, EPGLanguages);
+#ifdef USE_DDEPGENTRY
+  else if (!strcasecmp(Name, "DoubleEpgTimeDelta"))  DoubleEpgTimeDelta = atoi(Value);
+  else if (!strcasecmp(Name, "DoubleEpgAction"))     DoubleEpgAction    = atoi(Value);
+  else if (!strcasecmp(Name, "MixEpgAction"))        MixEpgAction       = atoi(Value);
+  else if (!strcasecmp(Name, "DisableVPS"))          DisableVPS         = atoi(Value);
+#endif /* DDEPGENTRY */
   else if (!strcasecmp(Name, "EPGScanTimeout"))      EPGScanTimeout     = atoi(Value);
   else if (!strcasecmp(Name, "EPGBugfixLevel"))      EPGBugfixLevel     = atoi(Value);
   else if (!strcasecmp(Name, "EPGLinger"))           EPGLinger          = atoi(Value);
@@ -673,6 +784,9 @@
   else if (!strcasecmp(Name, "VideoDisplayFormat"))  VideoDisplayFormat = atoi(Value);
   else if (!strcasecmp(Name, "VideoFormat"))         VideoFormat        = atoi(Value);
   else if (!strcasecmp(Name, "UpdateChannels"))      UpdateChannels     = atoi(Value);
+#ifdef USE_CHANNELBIND
+  else if (!strcasecmp(Name, "ChannelBindingByRid")) ChannelBindingByRid= atoi(Value);
+#endif /* CHANNELBIND */
   else if (!strcasecmp(Name, "UseDolbyDigital"))     UseDolbyDigital    = atoi(Value);
   else if (!strcasecmp(Name, "ChannelInfoPos"))      ChannelInfoPos     = atoi(Value);
   else if (!strcasecmp(Name, "ChannelInfoTime"))     ChannelInfoTime    = atoi(Value);
@@ -698,6 +812,10 @@
   else if (!strcasecmp(Name, "FontSmlSize"))         FontSmlSize        = atoi(Value);
   else if (!strcasecmp(Name, "FontFixSize"))         FontFixSize        = atoi(Value);
   else if (!strcasecmp(Name, "MaxVideoFileSize"))    MaxVideoFileSize   = atoi(Value);
+#ifdef USE_HARDLINKCUTTER
+  else if (!strcasecmp(Name, "MaxRecordingSize"))    MaxRecordingSize   = atoi(Value);
+  else if (!strcasecmp(Name, "HardLinkCutter"))      HardLinkCutter     = atoi(Value);
+#endif /* HARDLINKCUTTER */
   else if (!strcasecmp(Name, "SplitEditedFiles"))    SplitEditedFiles   = atoi(Value);
   else if (!strcasecmp(Name, "DelTimeshiftRec"))     DelTimeshiftRec    = atoi(Value);
   else if (!strcasecmp(Name, "MinEventTimeout"))     MinEventTimeout    = atoi(Value);
@@ -706,46 +824,92 @@
   else if (!strcasecmp(Name, "MultiSpeedMode"))      MultiSpeedMode     = atoi(Value);
   else if (!strcasecmp(Name, "ShowReplayMode"))      ShowReplayMode     = atoi(Value);
   else if (!strcasecmp(Name, "ResumeID"))            ResumeID           = atoi(Value);
+#ifdef USE_JUMPPLAY
+  else if (!strcasecmp(Name, "JumpPlay"))            JumpPlay           = atoi(Value);
+  else if (!strcasecmp(Name, "PlayJump"))            PlayJump           = atoi(Value);
+  else if (!strcasecmp(Name, "PauseLastMark"))       PauseLastMark      = atoi(Value);
+  else if (!strcasecmp(Name, "ReloadMarks"))         ReloadMarks        = atoi(Value);
+#endif /* JUMPPLAY */
   else if (!strcasecmp(Name, "CurrentChannel"))      CurrentChannel     = atoi(Value);
   else if (!strcasecmp(Name, "CurrentVolume"))       CurrentVolume      = atoi(Value);
   else if (!strcasecmp(Name, "CurrentDolby"))        CurrentDolby       = atoi(Value);
+#ifdef USE_CHANNELPROVIDE
+  else if (!strcasecmp(Name, "LocalChannelProvide")) LocalChannelProvide = atoi(Value);
+#endif /* CHANNELPROVIDE */
   else if (!strcasecmp(Name, "InitialChannel"))      InitialChannel     = atoi(Value);
   else if (!strcasecmp(Name, "InitialVolume"))       InitialVolume      = atoi(Value);
+#ifdef USE_VOLCTRL
+  else if (!strcasecmp(Name, "LRVolumeControl"))     LRVolumeControl    = atoi(Value);
+  else if (!strcasecmp(Name, "LRChannelGroups"))     LRChannelGroups    = atoi(Value);
+  else if (!strcasecmp(Name, "LRForwardRewind"))     LRForwardRewind    = atoi(Value);
+#endif /* VOLCTRL */
   else if (!strcasecmp(Name, "ChannelsWrap"))        ChannelsWrap       = atoi(Value);
   else if (!strcasecmp(Name, "EmergencyExit"))       EmergencyExit      = atoi(Value);
+#ifdef USE_LIEMIEXT
+  else if (!strcasecmp(Name, "ShowRecDate"))         ShowRecDate        = atoi(Value);
+  else if (!strcasecmp(Name, "ShowRecTime"))         ShowRecTime        = atoi(Value);
+  else if (!strcasecmp(Name, "ShowRecLength"))       ShowRecLength      = atoi(Value);
+  else if (!strcasecmp(Name, "ShowProgressBar"))     ShowProgressBar    = atoi(Value);
+  else if (!strcasecmp(Name, "MenuCmdPosition"))     MenuCmdPosition    = atoi(Value);
+#endif /* LIEMIEXT */
+#ifdef USE_LIRCSETTINGS
+  else if (!strcasecmp(Name, "LircRepeatDelay"))     LircRepeatDelay    = atoi(Value);
+  else if (!strcasecmp(Name, "LircRepeatFreq"))      LircRepeatFreq     = atoi(Value);
+  else if (!strcasecmp(Name, "LircRepeatTimeout"))   LircRepeatTimeout  = atoi(Value);
+#endif /* LIRCSETTINGS */
 #ifdef USE_NOEPG
   else if (!strcasecmp(Name, "noEPGMode"))           noEPGMode          = atoi(Value);
   else if (!strcasecmp(Name, "noEPGList")) {
      free(noEPGList);
      noEPGList = Value ? strdup(Value) : NULL;
      }
-#endif /* USE_NOEPG */
-#ifdef REELVDR
-  else if (!strcasecmp(Name, "LiveBuffer"))          LiveBuffer         = atoi(Value);
-  else if (!strcasecmp(Name, "LiveBufferSize"))      LiveBufferSize     = atoi(Value);
-  else if (!strcasecmp(Name, "LiveTvOnAvg"))         LiveTvOnAvg        = atoi(Value);
-  else if (!strcasecmp(Name, "ReceptionMode"))       ReceptionMode      = (eReceiverType)atoi(Value);
-  else if (!strcasecmp(Name, "NetServerName"))       Utf8Strn0Cpy(NetServerName, Value, MAXHOSTNAME);
-  else if (!strcasecmp(Name, "NetServerMAC"))        Utf8Strn0Cpy(NetServerMAC, Value, MACLENGTH);
-  else if (!strcasecmp(Name, "ExpertOptions"))       ExpertOptions      = atoi(Value);
-  else if (!strcasecmp(Name, "OSDRandom"))           OSDRandom          = atoi(Value);
-  else if (!strcasecmp(Name, "OSDRemainTime"))       OSDRemainTime      = atoi(Value);
-  else if (!strcasecmp(Name, "OSDUseSymbol"))        OSDUseSymbol       = atoi(Value);
-  else if (!strcasecmp(Name, "OSDScrollBarWidth"))   OSDScrollBarWidth  = atoi(Value);
-  else if (!strcasecmp(Name, "FontSizes"))           FontSizes          = atoi(Value);
-  else if (!strcasecmp(Name, "AddNewChannels"))      AddNewChannels     = atoi(Value);
-  else if (!strcasecmp(Name, "NetServerIP"))         Utf8Strn0Cpy(NetServerIP, Value, MAXHOSTIP);
-  else if (!strcasecmp(Name, "ReelboxMode"))         ReelboxMode        = (eReelboxMode)atoi(Value);
-  else if (!strcasecmp(Name, "RequestShutDownMode")) RequestShutDownMode= atoi(Value);
-  else if (!strcasecmp(Name, "StandbyOrQuickshutdown")) StandbyOrQuickshutdown  = atoi(Value);
-  else if (!strcasecmp(Name, "UseBouquetList"))      UseBouquetList     = atoi(Value);
-  else if (!strcasecmp(Name, "OnlyRadioChannels"))   OnlyRadioChannels  = atoi(Value);
-  else if (!strcasecmp(Name, "OnlyEncryptedChannels"))OnlyEncryptedChannels = atoi(Value);
-  else if (!strcasecmp(Name, "OnlyHDChannels"))      OnlyHDChannels       = atoi(Value);
-  else if (!strcasecmp(Name, "ExpertNavi"))          ExpertNavi         = atoi(Value);
-#endif /* REELVDR */
+#endif /* NOEPG */
+#ifdef USE_DVLVIDPREFER
+  else if (strcasecmp(Name, "UseVidPrefer") == 0)    UseVidPrefer       = atoi(Value);
+  else if (strcasecmp(Name, "nVidPrefer") == 0)      nVidPrefer         = atoi(Value);
+  else if (strstr(Name, "VidPrefer") == Name) {
+     char *x = (char *)&Name[ strlen(Name) - 1 ];
+     int vN;
+
+     if (isdigit(*x) != 0) {
+        while (isdigit(*x) != 0)
+              x--;
+        x++;
+        }
+
+     vN = atoi(x);
+     if (vN < DVLVIDPREFER_MAX) {
+        if (strstr(Name, "VidPreferPrio") == Name) {
+           VidPreferPrio[ vN ] = atoi(Value);
+           if (VidPreferPrio[ vN ] > 99)
+              VidPreferPrio[ vN ] = 99;
+           }
+        else if (strstr(Name, "VidPreferSize") == Name) {
+           VidPreferSize[ vN ] = atoi(Value);
+           }
+        else
+           return false;
+        }
+     }
+#endif /* DVLVIDPREFER */
   else
+#ifdef USE_LNBSHARE
+  if (!strcasecmp(Name, "VerboseLNBlog")) VerboseLNBlog = atoi(Value);
+  else {
+    char tmp[20];
+    bool result = false;
+    for (int i = 1; i <= MAXDEVICES; i++) {
+      sprintf(tmp, "Card%dusesLNBnr", i);
+      if (!strcasecmp(Name, tmp)) {
+        CardUsesLnbNr[i - 1] = atoi(Value);
+        result = true;
+      }
+    }  
+     return result;
+  }
+#else
      return false;
+#endif /* LNBSHARE */
   return true;
 }
 
@@ -754,6 +918,12 @@
   Store("OSDLanguage",        OSDLanguage);
   Store("OSDSkin",            OSDSkin);
   Store("OSDTheme",           OSDTheme);
+#ifdef USE_VALIDINPUT
+  Store("ShowValidInput",     ShowValidInput);
+#endif /* VALIDINPUT */
+#ifdef USE_WAREAGLEICON
+  Store("WarEagleIcons",      WarEagleIcons);
+#endif /* WAREAGLEICON */
   Store("PrimaryDVB",         PrimaryDVB);
   Store("ShowInfoOnChSwitch", ShowInfoOnChSwitch);
   Store("TimeoutRequChInfo",  TimeoutRequChInfo);
@@ -772,13 +942,27 @@
   Store("TimeTransponder",    TimeTransponder);
   Store("MarginStart",        MarginStart);
   Store("MarginStop",         MarginStop);
+#ifdef USE_JUMPINGSECONDS
+  Store("JumpSeconds",        JumpSeconds);
+  Store("JumpSecondsSlow",    JumpSecondsSlow);
+  Store("JumpSecondsRepeat",  JumpSecondsRepeat);
+#endif /* JUMPINGSECONDS */
   StoreLanguages("AudioLanguages", AudioLanguages);
   Store("DisplaySubtitles",   DisplaySubtitles);
+#ifdef USE_TTXTSUBS
+  Store("SupportTeletext",    SupportTeletext);
+#endif /* TTXTSUBS */
   StoreLanguages("SubtitleLanguages", SubtitleLanguages);
   Store("SubtitleOffset",     SubtitleOffset);
   Store("SubtitleFgTransparency", SubtitleFgTransparency);
   Store("SubtitleBgTransparency", SubtitleBgTransparency);
   StoreLanguages("EPGLanguages", EPGLanguages);
+#ifdef USE_DDEPGENTRY
+  Store("DoubleEpgTimeDelta", DoubleEpgTimeDelta);
+  Store("DoubleEpgAction",    DoubleEpgAction);
+  Store("MixEpgAction",       MixEpgAction);
+  Store("DisableVPS",         DisableVPS);
+#endif /* DDEPGENTRY */
   Store("EPGScanTimeout",     EPGScanTimeout);
   Store("EPGBugfixLevel",     EPGBugfixLevel);
   Store("EPGLinger",          EPGLinger);
@@ -800,6 +984,9 @@
   Store("VideoDisplayFormat", VideoDisplayFormat);
   Store("VideoFormat",        VideoFormat);
   Store("UpdateChannels",     UpdateChannels);
+#ifdef USE_CHANNELBIND
+  Store("ChannelBindingByRid",ChannelBindingByRid);
+#endif /* CHANNELBIND */
   Store("UseDolbyDigital",    UseDolbyDigital);
   Store("ChannelInfoPos",     ChannelInfoPos);
   Store("ChannelInfoTime",    ChannelInfoTime);
@@ -833,17 +1020,69 @@
   Store("MultiSpeedMode",     MultiSpeedMode);
   Store("ShowReplayMode",     ShowReplayMode);
   Store("ResumeID",           ResumeID);
+#ifdef USE_JUMPPLAY
+  Store("JumpPlay",           JumpPlay);
+  Store("PlayJump",           PlayJump);
+  Store("PauseLastMark",      PauseLastMark);
+  Store("ReloadMarks",        ReloadMarks);
+#endif /* JUMPPLAY */
   Store("CurrentChannel",     CurrentChannel);
   Store("CurrentVolume",      CurrentVolume);
   Store("CurrentDolby",       CurrentDolby);
+#ifdef USE_CHANNELPROVIDE
+  Store("LocalChannelProvide",LocalChannelProvide);
+#endif /* CHANNELPROVIDE */
+#ifdef USE_HARDLINKCUTTER
+  Store("MaxRecordingSize",   MaxRecordingSize);
+  Store("HardLinkCutter",     HardLinkCutter);
+#endif /* HARDLINKCUTTER */
   Store("InitialChannel",     InitialChannel);
   Store("InitialVolume",      InitialVolume);
+#ifdef USE_VOLCTRL
+  Store("LRVolumeControl",    LRVolumeControl);
+  Store("LRChannelGroups",    LRChannelGroups);
+  Store("LRForwardRewind",    LRForwardRewind);
+#endif /* VOLCTRL */
   Store("ChannelsWrap",       ChannelsWrap);
   Store("EmergencyExit",      EmergencyExit);
+#ifdef USE_LIEMIEXT
+  Store("ShowRecDate",        ShowRecDate);
+  Store("ShowRecTime",        ShowRecTime);
+  Store("ShowRecLength",      ShowRecLength);
+  Store("ShowProgressBar",    ShowProgressBar);
+  Store("MenuCmdPosition",    MenuCmdPosition);
+#endif /* LIEMIEXT */
+#ifdef USE_LIRCSETTINGS
+  Store("LircRepeatDelay",    LircRepeatDelay);
+  Store("LircRepeatFreq",     LircRepeatFreq);
+  Store("LircRepeatTimeout",  LircRepeatTimeout);
+#endif /* LIRCSETTINGS */
+#ifdef USE_LNBSHARE
+  Store("VerboseLNBlog",       VerboseLNBlog);
+  char tmp[20];
+  if (cDevice::NumDevices() > 1) {
+     for (int i = 1; i <= cDevice::NumDevices(); i++) {
+        sprintf(tmp, "Card%dusesLNBnr", i);
+        Store(tmp, CardUsesLnbNr[i - 1]);
+     }
+  }
+#endif /* LNBSHARE */
 #ifdef USE_NOEPG
   Store("noEPGMode",          noEPGMode);
   Store("noEPGList",          noEPGList ? noEPGList : "");
-#endif /* USE_NOEPG */
+#endif /* NOEPG */
+#ifdef USE_DVLVIDPREFER
+  Store ("UseVidPrefer",      UseVidPrefer);
+  Store ("nVidPrefer",        nVidPrefer);
+
+  char vidBuf[32];
+  for (int zz = 0; zz < nVidPrefer; zz++) {
+      sprintf(vidBuf, "VidPreferPrio%d", zz);
+      Store (vidBuf, VidPreferPrio[zz]);
+      sprintf(vidBuf, "VidPreferSize%d", zz);
+      Store (vidBuf, VidPreferSize[zz]);
+      }
+#endif /* DVLVIDPREFER */
 #ifdef REELVDR
   Store("LiveBuffer",         LiveBuffer);
   Store("LiveBufferSize",     LiveBufferSize);
@@ -867,7 +1106,7 @@
   Store("OnlyEncryptedChannels", OnlyEncryptedChannels);
   Store("OnlyHDChannels", OnlyHDChannels);
   Store("ExpertNavi",         ExpertNavi);
- #endif /* REELVDR */
+#endif /* REELVDR */
 
   Sort();
 
@@ -895,4 +1134,4 @@
     std::string command = std::string("CopytoTftpRoot.sh ") + p;
     SystemExec(command.c_str());
 }
-#endif /* REELVDR */
+#endif /* REELVDR */
\ No newline at end of file
Index: remux.h
===================================================================
--- remux.h	(revision 15412)
+++ remux.h	(revision 15413)
@@ -171,6 +171,9 @@
   int MakeStream(uchar *Target, uchar Type, int Pid);
   int MakeAC3Descriptor(uchar *Target, uchar Type);
   int MakeSubtitlingDescriptor(uchar *Target, const char *Language, uchar SubtitlingType, uint16_t CompositionPageId, uint16_t AncillaryPageId);
+#ifdef USE_TTXTSUBS
+  int MakeTeletextDescriptor(uchar *Target, const tTeletextSubtitlePage *pages, int pageCount);
+#endif /* TTXTSUBS */
   int MakeLanguageDescriptor(uchar *Target, const char *Language);
   int MakeCRC(uchar *Target, const uchar *Data, int Length);
   void GeneratePmtPid(const cChannel *Channel);
@@ -216,6 +219,9 @@
   int vpid;
   int ppid;
   int vtype;
+#ifdef USE_TTXTSUBS
+  int tpid;
+#endif /* TTXTSUBS */
   int apids[MAXAPIDS + 1]; // list is zero-terminated
   int atypes[MAXAPIDS + 1]; // list is zero-terminated
   char alangs[MAXAPIDS][MAXLANGCODE2];
@@ -228,6 +234,10 @@
   uint16_t compositionPageIds[MAXSPIDS];
   uint16_t ancillaryPageIds[MAXSPIDS];
   bool updatePrimaryDevice;
+#ifdef USE_TTXTSUBS
+  int totalTtxtSubtitlePages;
+  tTeletextSubtitlePage teletextSubtitlePages[MAXTXTPAGES];
+#endif /* TTXTSUBS */
 protected:
   int SectionLength(const uchar *Data, int Length) { return (Length >= 3) ? ((int(Data[1]) & 0x0F) << 8)| Data[2] : 0; }
 public:
@@ -260,6 +270,11 @@
   int Vtype(void) const { return vtype; }
        ///< Returns the video stream type as defined by the current PMT, or 0 if no video
        ///< stream type has been detected, yet.
+#ifdef USE_TTXTSUBS
+  int Tpid(void) { return tpid; }
+       ///< Returns the teletext pid as defined by the current PMT, or 0 if no teletext
+       ///< pid has been detected, yet.
+#endif /* TTXTSUBS */
   const int *Apids(void) const { return apids; }
   const int *Dpids(void) const { return dpids; }
   const int *Spids(void) const { return spids; }
@@ -274,6 +289,10 @@
   uchar SubtitlingType(int i) const { return (0 <= i && i < MAXSPIDS) ? subtitlingTypes[i] : uchar(0); }
   uint16_t CompositionPageId(int i) const { return (0 <= i && i < MAXSPIDS) ? compositionPageIds[i] : uint16_t(0); }
   uint16_t AncillaryPageId(int i) const { return (0 <= i && i < MAXSPIDS) ? ancillaryPageIds[i] : uint16_t(0); }
+#ifdef USE_TTXTSUBS
+  const tTeletextSubtitlePage *TeletextSubtitlePages() const { return teletextSubtitlePages; }
+  int TotalTeletextSubtitlePages() const { return totalTtxtSubtitlePages; }
+#endif /* TTXTSUBS */
   };
 
 // TS to PES converter:
Index: config.h
===================================================================
--- config.h	(revision 15412)
+++ config.h	(revision 15413)
@@ -14,10 +14,10 @@
 #include <stdio.h>
 #include <stdlib.h>
 #ifdef REELVDR
+#include <string.h>
+#else
 #include <string>
-#else
-#include <string.h>
-#endif
+#endif /*REELVDR*/
 #include <time.h>
 #include <unistd.h>
 #include "i18n.h"
@@ -34,15 +34,39 @@
 #define APIVERSION  "1.7.16"
 #define APIVERSNUM   10716  // Version * 10000 + Major * 100 + Minor
 
+#ifdef USE_YAEPG
+#define YAEPGHDVERSNUM 1
+#endif /* YAEPG */
+
 // When loading plugins, VDR searches them by their APIVERSION, which
 // may be smaller than VDRVERSION in case there have been no changes to
 // VDR header files since the last APIVERSION. This allows compiled
 // plugins to work with newer versions of the core VDR as long as no
 // VDR header files have changed.
 
+#ifdef USE_CHANNELBIND
+#define CHANNELBINDINGVERSNUM 2
+#endif /* CHANNELBIND */
+
+#ifdef USE_JUMPPLAY
+#define JUMPPLAYVERSNUM 100
+#endif /* JUMPPLAY */
+
+#ifdef USE_LIEMIEXT
+#define LIEMIKUUTIO  130
+#endif /* LIEMIEXT */
+
+#ifdef USE_MAINMENUHOOKS
+#define MAINMENUHOOKSVERSNUM 1.0
+#endif /* MAINMENUHOOKS */
+
 #define MAXPRIORITY 99
 #define MAXLIFETIME 99
 
+#ifdef USE_DVLVIDPREFER
+#define DVLVIDPREFER_MAX 12
+#endif /* DVLVIDPREFER */
+
 #define MINOSDWIDTH   480
 #define MAXOSDWIDTH  1920
 #define MINOSDHEIGHT  324
@@ -52,6 +76,7 @@
 #define MaxSkinName 16
 #define MaxThemeName 16
 
+
 typedef uint32_t in_addr_t; //XXX from /usr/include/netinet/in.h (apparently this is not defined on systems with glibc < 2.2)
 
 #ifdef REELVDR
@@ -236,6 +261,12 @@
   char OSDLanguage[I18N_MAX_LOCALE_LEN];
   char OSDSkin[MaxSkinName];
   char OSDTheme[MaxThemeName];
+#ifdef USE_VALIDINPUT
+  int ShowValidInput;
+#endif /* VALIDINPUT */
+#ifdef USE_WAREAGLEICON
+  int WarEagleIcons;
+#endif /* WAREAGLEICON */
   int PrimaryDVB;
   int ShowInfoOnChSwitch;
   int TimeoutRequChInfo;
@@ -253,12 +284,24 @@
   int TimeSource;
   int TimeTransponder;
   int MarginStart, MarginStop;
+#ifdef USE_JUMPINGSECONDS
+  int JumpSeconds, JumpSecondsSlow, JumpSecondsRepeat;
+#endif /* JUMPINGSECONDS */
   int AudioLanguages[I18N_MAX_LANGUAGES + 1];
   int DisplaySubtitles;
+#ifdef USE_TTXTSUBS
+  int SupportTeletext;
+#endif /* TTXTSUBS */
   int SubtitleLanguages[I18N_MAX_LANGUAGES + 1];
   int SubtitleOffset;
   int SubtitleFgTransparency, SubtitleBgTransparency;
   int EPGLanguages[I18N_MAX_LANGUAGES + 1];
+#ifdef USE_DDEPGENTRY
+  int DoubleEpgTimeDelta;
+  int DoubleEpgAction;
+  int MixEpgAction;
+  int DisableVPS;
+#endif /* DDEPPGENTRY */
   int EPGScanTimeout;
   int EPGBugfixLevel;
   int EPGLinger;
@@ -278,6 +321,9 @@
   int VideoDisplayFormat;
   int VideoFormat;
   int UpdateChannels;
+#ifdef USE_CHANNELBIND
+  int ChannelBindingByRid;
+#endif /* CHANNELBIND */
   int UseDolbyDigital;
   int ChannelInfoPos;
   int ChannelInfoTime;
@@ -297,6 +343,10 @@
   int FontSmlSize;
   int FontFixSize;
   int MaxVideoFileSize;
+#ifdef USE_HARDLINKCUTTER
+  int MaxRecordingSize;
+  int HardLinkCutter;
+#endif /* HARDLINKCUTTER */
   int SplitEditedFiles;
   int DelTimeshiftRec;
   int MinEventTimeout, MinUserInactivity;
@@ -304,16 +354,51 @@
   int MultiSpeedMode;
   int ShowReplayMode;
   int ResumeID;
+#ifdef USE_JUMPPLAY
+  int JumpPlay;
+  int PlayJump;
+  int PauseLastMark;
+  int ReloadMarks;
+#endif /* JUMPPLAY */
   int CurrentChannel;
   int CurrentVolume;
   int CurrentDolby;
+#ifdef USE_CHANNELPROVIDE
+  int LocalChannelProvide;
+#endif /* CHANNELPROVIDE */
   int InitialChannel;
   int InitialVolume;
+#ifdef USE_VOLCTRL
+  int LRVolumeControl;
+  int LRChannelGroups;
+  int LRForwardRewind;
+#endif /* VOLCTRL */
   int ChannelsWrap;
   int EmergencyExit;
+#ifdef USE_LIRCSETTINGS
+  int LircRepeatDelay;
+  int LircRepeatFreq;
+  int LircRepeatTimeout;
+#endif /* LIRCSETTINGS */
+#ifdef USE_LIEMIEXT
+  int ShowRecDate, ShowRecTime, ShowRecLength, ShowProgressBar, MenuCmdPosition;
+#endif /* LIEMIEXT */
+#ifdef USE_LNBSHARE
+  int VerboseLNBlog;
+  #define MAXDEVICES 16 // Since VDR 1.3.32 we can not #include "device.h" for MAXDEVICES anymore.
+                        // With this workaround a warning will be shown during compilation if
+                        // MAXDEVICES changes in device.h.
+  int CardUsesLnbNr[MAXDEVICES];
+#endif /* LNBSHARE */
 #ifdef USE_NOEPG
   int noEPGMode;
-#endif /* USE_NOEPG */
+#endif /* NOEPG */
+#ifdef USE_DVLVIDPREFER
+  int UseVidPrefer;  // 0 = VDR's default, 1 = use
+  int nVidPrefer;
+  int VidPreferPrio[DVLVIDPREFER_MAX];
+  int VidPreferSize[DVLVIDPREFER_MAX];
+#endif /* DVLVIDPREFER */
 #ifdef REELVDR
   int LiveBuffer;
   int LiveBufferSize;
@@ -342,11 +427,11 @@
   int __EndData__;
 #ifdef USE_NOEPG
   char *noEPGList; // pointer not to be flat-copied
-#endif /* USE_NOEPG */
+#endif /* NOEPG */
   cSetup(void);
 #ifdef USE_NOEPG
   ~cSetup();
-#endif /* USE_NOEPG */
+#endif /* NOEPG */
   cSetup& operator= (const cSetup &s);
   bool Load(const char *FileName);
   bool Save(void);
Index: vdr.c
===================================================================
--- vdr.c	(revision 15412)
+++ vdr.c	(revision 15413)
@@ -803,7 +803,12 @@
   RecordingCommands.Load(AddDirectory(ConfigDirectory, "reccmds.conf"));
   SVDRPhosts.Load(AddDirectory(ConfigDirectory, "svdrphosts.conf"), true);
   Keys.Load(AddDirectory(ConfigDirectory, "remote.conf"));
+#ifdef USE_ALTERNATECHANNEL
+  KeyMacros.Load(AddDirectory(ConfigDirectory, "keymacros.conf"), true) &&
+    Channels.LoadAlternativeChannels(AddDirectory(ConfigDirectory, "channel_alternative.conf"));
+#else
   KeyMacros.Load(AddDirectory(ConfigDirectory, "keymacros.conf"), true);
+#endif /* ALTERNATECHANNEL */
   Folders.Load(AddDirectory(ConfigDirectory, "folders.conf"));
 
   if (!*cFont::GetFontFileName(Setup.FontOsd)) {
@@ -1147,6 +1152,21 @@
            Recordings.Update();
            DeletedRecordings.Update();
            }
+#ifdef USE_MCLI
+        cPlugin *mcliPlugin = cPluginManager::GetPlugin("mcli");
+        if (mcliPlugin) {
+           if (!ShutdownHandler.countdown) { // if kPower has been pressed, cMenuShutdown takes precedence over other menus
+              cOsdObject *MyMenu = mcliPlugin->AltMenuAction();
+              if (MyMenu) { // is there any cam-menu waiting?
+                 DELETE_MENU;
+                 if (cControl::Control())
+                    cControl::Control()->Hide();
+                    Menu = MyMenu;
+                    Menu->Show();
+                 }
+              }
+           }
+#endif /* MCLI */
         // CAM control:
         if (!Menu && !cOsd::IsOpen())
            Menu = CamControl();
@@ -1157,6 +1177,9 @@
         cOsdObject *Interact = Menu ? Menu : cControl::Control();
         eKeys key = Interface->GetKey(!Interact || !Interact->NeedsFastResponse());
         if (ISREALKEY(key)) {
+#ifdef USE_PINPLUGIN
+           cStatus::MsgUserAction(key, Interact);
+#endif /* PINPLUGIN */
            EITScanner.Activity();
            // Cancel shutdown countdown:
            if (ShutdownHandler.countdown)
@@ -1249,10 +1272,16 @@
                      cControl::Control()->Hide();
                   cPlugin *plugin = cPluginManager::GetPlugin(PluginName);
                   if (plugin) {
+#ifdef USE_PINPLUGIN
+                  if (!cStatus::MsgPluginProtected(plugin)) {
+#endif /* PINPLUGIN */
                      Menu = plugin->MainMenuAction();
                      if (Menu)
                         Menu->Show();
                      }
+#ifdef USE_PINPLUGIN
+                     }
+#endif /* PINPLUGIN */
                   else
                      esyslog("ERROR: unknown plugin '%s'", PluginName);
                   }
@@ -1442,13 +1471,26 @@
                   Channels.SwitchTo(PreviousChannel[PreviousChannelIndex ^= 1]);
                   break;
                   }
+#ifdef USE_VOLCTRL
+             // Left/Right volume control
+#else
              // Direct Channel Select:
              case k1 ... k9:
              // Left/Right rotates through channel groups:
+#endif /* VOLCTRL */
              case kLeft|k_Repeat:
              case kLeft:
              case kRight|k_Repeat:
              case kRight:
+#ifdef USE_VOLCTRL
+                  if (Setup.LRVolumeControl && Setup.LRChannelGroups < 2) {
+                     cRemote::Put(NORMALKEY(key) == kLeft ? kVolDn : kVolUp, true);
+                     break;
+                     }
+                  // else fall through
+             // Direct Channel Select:
+             case k1 ... k9:
+#endif /* VOLCTRL */
              // Previous/Next rotates through channel groups:
              case kPrev|k_Repeat:
              case kPrev:
@@ -1466,9 +1508,15 @@
              // Instant resume of the last viewed recording:
              case kPlay:
                   if (cReplayControl::LastReplayed()) {
+#ifdef USE_PINPLUGIN
+                     if (cStatus::MsgReplayProtected(0, cReplayControl::LastReplayed(), 0, false) == false) {
+#endif /* PINPLUGIN */
                      cControl::Shutdown();
                      cControl::Launch(new cReplayControl);
                      }
+#ifdef USE_PINPLUGIN
+                     }
+#endif /* PINPLUGIN */
                   break;
              default:    break;
              }
Index: dvbdevice.c
===================================================================
--- dvbdevice.c	(revision 15412)
+++ dvbdevice.c	(revision 15413)
@@ -284,6 +284,9 @@
 class cDvbTuner : public cThread {
 private:
   enum eTunerStatus { tsIdle, tsSet, tsTuned, tsLocked };
+#ifdef USE_ROTOR
+ bool SendDiseqc;
+#endif /* ROTOR */
   int device;
   int fd_frontend;
   int adapter, frontend;
@@ -297,6 +300,9 @@
   cMutex mutex;
   cCondVar locked;
   cCondVar newSet;
+#ifdef USE_ROTOR
+  dvb_diseqc_master_cmd diseqc_cmd;
+#endif /* ROTOR */
   bool GetFrontendStatus(fe_status_t &Status, int TimeoutMs = 0);
   bool SetFrontend(void);
   virtual void Action(void);
@@ -306,6 +312,9 @@
   const cChannel *GetTransponder(void) const { return &channel; }
   bool IsTunedTo(const cChannel *Channel) const;
   void Set(const cChannel *Channel);
+#ifdef USE_ROTOR
+  bool SendDiseqcCmd(dvb_diseqc_master_cmd cmd);
+#endif /* ROTOR */
   bool Locked(int TimeoutMs = 0);
   };
 
@@ -313,6 +322,9 @@
 {
   device = Device;
   fd_frontend = Fd_Frontend;
+#ifdef USE_ROTOR
+  SendDiseqc=false;
+#endif /* ROTOR */
   adapter = Adapter;
   frontend = Frontend;
   frontendType = FrontendType;
@@ -367,6 +379,19 @@
   return tunerStatus >= tsLocked;
 }
 
+#ifdef USE_ROTOR
+bool cDvbTuner::SendDiseqcCmd(dvb_diseqc_master_cmd cmd)
+{
+  cMutexLock MutexLock(&mutex);
+  if ((frontendType!=SYS_DVBS2 && frontendType!=SYS_DVBS) || SendDiseqc)
+    return false;
+  diseqc_cmd=cmd;
+  SendDiseqc=true;
+  newSet.Broadcast();
+  return true;
+}
+#endif /* ROTOR */
+
 bool cDvbTuner::GetFrontendStatus(fe_status_t &Status, int TimeoutMs)
 {
   if (TimeoutMs) {
@@ -558,6 +583,12 @@
         if (GetFrontendStatus(NewStatus, 10))
            Status = NewStatus;
         cMutexLock MutexLock(&mutex);
+#ifdef USE_ROTOR
+        if (SendDiseqc) {
+           CHECK(ioctl(fd_frontend, FE_DISEQC_SEND_MASTER_CMD, &diseqc_cmd));
+           SendDiseqc=false;
+           }
+#endif /* ROTOR */
         switch (tunerStatus) {
           case tsIdle:
                break;
@@ -712,6 +743,12 @@
 
   fd_dvr = -1;
 
+#ifdef USE_LNBSHARE
+  lnbState = -1;
+  SetLnbNrFromSetup();
+  lnbSource = NULL;
+#endif /* LNBSHARE */
+
   // We only check the devices that must be present - the others will be checked before accessing them://XXX
 
   if (fd_frontend >= 0) {
@@ -960,10 +997,25 @@
 
 bool cDvbDevice::ProvidesChannel(const cChannel *Channel, int Priority, bool *NeedsDetachReceivers) const
 {
+#ifdef USE_CHANNELPROVIDE
+  if (Setup.LocalChannelProvide != 1)
+     return false;
+#endif /* CHANNELPROVIDE */
   bool result = false;
   bool hasPriority = Priority < 0 || Priority > this->Priority();
   bool needsDetachReceivers = false;
 
+#ifdef USE_CHANNELBIND
+  if (Setup.ChannelBindingByRid && Channel->Rid()) {
+    if (0 == ((unsigned) Channel->Rid() & (1<<(unsigned) CardIndex())) ) {
+      #if 0
+      printf("device %d doesn't provide channel %s", CardIndex(), *Channel->ToText());
+      #endif
+      return false;
+      }
+    }
+#endif /* CHANNELBIND */
+
   if (ProvidesTransponder(Channel)) {
      result = hasPriority;
      if (Priority >= 0 && Receiving(true)) {
@@ -987,6 +1039,9 @@
            needsDetachReceivers = true;
         }
      }
+#ifdef USE_LNBSHARE
+  if(Priority >= 0 && result && !(Receiving(true) && dvbTuner->IsTunedTo(Channel)) && GetMaxBadPriority(Channel) >= Priority) result = false;
+#endif /* LNBSHARE */
   if (NeedsDetachReceivers)
      *NeedsDetachReceivers = needsDetachReceivers;
   return result;
@@ -1010,6 +1065,17 @@
 bool cDvbDevice::SetChannelDevice(const cChannel *Channel, bool LiveView)
 {
   dvbTuner->Set(Channel);
+#ifdef USE_LNBSHARE
+  cDvbTransponderParameters dtp(Channel->Parameters());
+ 
+  if (Channel->Frequency() >= Setup.LnbSLOF) {
+     lnbState = 1;
+  } else {
+     lnbState = 0;
+  }
+  if (dtp.Polarization() == 'v' || dtp.Polarization() == 'V') lnbState += 2;
+  lnbSource = (int*) Diseqcs.Get(CardIndex() + 1, Channel->Source(), Channel->Frequency(), dtp.Polarization());
+#endif /* LNBSHARE */
   return true;
 }
 
@@ -1018,6 +1084,13 @@
   return dvbTuner ? dvbTuner->Locked(TimeoutMs) : false;
 }
 
+#ifdef USE_ROTOR
+bool cDvbDevice::SendDiseqcCmd(dvb_diseqc_master_cmd cmd)
+{
+  return dvbTuner->SendDiseqcCmd(cmd);
+}
+#endif /* ROTOR */
+
 void cDvbDevice::SetTransferModeForDolbyDigital(int Mode)
 {
   setTransferModeForDolbyDigital = Mode;
@@ -1051,6 +1124,45 @@
   return false;
 }
 
+#ifdef USE_LNBSHARE
+void cDvbDevice::SetLnbNrFromSetup(void)
+{
+  lnbNr = Setup.CardUsesLnbNr[CardIndex()];
+  isyslog("LNB-sharing: setting device %d to use LNB %d", CardIndex(), lnbNr);
+}
+
+bool cDvbDevice::IsShareLnb(const cDevice *Device)
+{ 
+  return this != Device && LnbNr() == Device->LnbNr();
+};
+
+
+bool cDvbDevice::IsLnbConflict(const cChannel *Channel)
+{
+  if(!cSource::IsSat(Channel->Source())) return false;  // no conflict if the new channel is not on sat
+  if(!ProvidesSource(cSource::stSat)) return false;     // no conflict if this device is not on sat
+//if(MaySwitchTransponder()) return false;              // no conflict if this transponder may be switched
+  cDvbTransponderParameters dtp(Channel->Parameters());
+  if (Setup.DiSEqC) {
+    cDiseqc *diseqc;
+    diseqc = Diseqcs.Get(CardIndex() + 1, Channel->Source(), Channel->Frequency(), dtp.Polarization() );
+    if (LnbSource() != (int*) diseqc) return true;
+    return false;
+  } else
+  {
+    char requiredState;
+    if (Channel->Frequency() >= Setup.LnbSLOF) {
+      requiredState = 1 ;
+    } else {
+      requiredState = 0;
+    }
+    if (dtp.Polarization() == 'v' || dtp.Polarization() == 'V') requiredState += 2;
+    if(lnbState != requiredState) return true;
+    return false;
+  }
+}
+#endif /* LNBSHARE */
+
 // --- cDvbDeviceProbe -------------------------------------------------------
 
 cList<cDvbDeviceProbe> DvbDeviceProbes;
Index: device.c
===================================================================
--- device.c	(revision 15412)
+++ device.c	(revision 15413)
@@ -18,6 +18,9 @@
 #include "receiver.h"
 #include "status.h"
 #include "transfer.h"
+#ifdef USE_TTXTSUBS
+#include "vdrttxtsubshooks.h"
+#endif /* TTXTSUBS */
 
 // --- cLiveSubtitle ---------------------------------------------------------
 
@@ -166,6 +169,15 @@
      useDevice |= (1 << n);
 }
 
+#ifdef USE_LNBSHARE
+void cDevice::SetLnbNr(void)
+{
+  for (int i = 0; i < numDevices; i++) {
+    device[i]->SetLnbNrFromSetup();
+  }
+}
+#endif /* LNBSHARE */
+
 int cDevice::NextCardIndex(int n)
 {
   if (n > 0) {
@@ -258,6 +270,9 @@
   int NumCamSlots = CamSlots.Count();
   int SlotPriority[NumCamSlots];
   int NumUsableSlots = 0;
+#ifdef USE_MCLI
+  bool InternalCamNeeded = false;
+#endif /* MCLI */
   if (Channel->Ca() >= CA_ENCRYPTED_MIN) {
      for (cCamSlot *CamSlot = CamSlots.First(); CamSlot; CamSlot = CamSlots.Next(CamSlot)) {
          SlotPriority[CamSlot->Index()] = MAXPRIORITY + 1; // assumes it can't be used
@@ -271,7 +286,11 @@
             }
          }
      if (!NumUsableSlots)
+#ifdef USE_MCLI
+        InternalCamNeeded = true; // no CAM is able to decrypt this channel
+#else
         return NULL; // no CAM is able to decrypt this channel
+#endif /* MCLI */
      }
 
   bool NeedsDetachReceivers = false;
@@ -287,11 +306,21 @@
              continue; // this device shall be temporarily avoided
           if (Channel->Ca() && Channel->Ca() <= CA_DVB_MAX && Channel->Ca() != device[i]->CardIndex() + 1)
              continue; // a specific card was requested, but not this one
+#ifdef USE_MCLI
+          if (InternalCamNeeded && !device[i]->HasInternalCam())
+             continue; // no CAM is able to decrypt this channel and the device uses vdr handled CAMs
+          if (NumUsableSlots && !device[i]->HasInternalCam() && !CamSlots.Get(j)->Assign(device[i], true))
+#else
           if (NumUsableSlots && !CamSlots.Get(j)->Assign(device[i], true))
+#endif /* MCLI */
              continue; // CAM slot can't be used with this device
           bool ndr;
           if (device[i]->ProvidesChannel(Channel, Priority, &ndr)) { // this device is basicly able to do the job
+#ifdef USE_MCLI
+             if (NumUsableSlots && !device[i]->HasInternalCam() && device[i]->CamSlot() && device[i]->CamSlot() != CamSlots.Get(j))
+#else
              if (NumUsableSlots && device[i]->CamSlot() && device[i]->CamSlot() != CamSlots.Get(j))
+#endif /* MCLI */
                 ndr = true; // using a different CAM slot requires detaching receivers
              // Put together an integer number that reflects the "impact" using
              // this device would have on the overall system. Each condition is represented
@@ -305,19 +334,48 @@
              imp <<= 1; imp |= device[i]->Receiving();                                                               // avoid devices that are receiving
              imp <<= 4; imp |= GetClippedNumProvidedSystems(4, device[i]) - 1;                                       // avoid cards which support multiple delivery systems
              imp <<= 1; imp |= device[i] == cTransferControl::ReceiverDevice();                                      // avoid the Transfer Mode receiver device
+#ifdef USE_LNBSHARE
+             int badPriority = device[i]->GetMaxBadPriority(Channel);
+             if (badPriority < 0 )                  // a device receiving with lower priority would need to be stopped
+             {
+                imp <<= 8; imp |= min(max(device[i]->Priority() + MAXPRIORITY, 0), 0xFF);                       // use the device with the lowest priority (+MAXPRIORITY to assure that values -99..99 can be used)
+             } else {
+                imp <<= 8; imp |= min(max(max(device[i]->Priority(), badPriority) + MAXPRIORITY, 0), 0xFF);          // use the device with the lowest priority (+MAXPRIORITY to assure that values -99..99 can be used)
+             }
+#else
              imp <<= 8; imp |= min(max(device[i]->Priority() + MAXPRIORITY, 0), 0xFF);                               // use the device with the lowest priority (+MAXPRIORITY to assure that values -99..99 can be used)
+#endif /* LNBSHARE */
+#ifdef USE_MCLI
+             imp <<= 8; imp |= min(max(((NumUsableSlots && !device[i]->HasInternalCam()) ? SlotPriority[j] : 0) + MAXPRIORITY, 0), 0xFF);              // use the CAM slot with the lowest priority (+MAXPRIORITY to assure that values -99..99 can be used)
+#else
              imp <<= 8; imp |= min(max((NumUsableSlots ? SlotPriority[j] : 0) + MAXPRIORITY, 0), 0xFF);              // use the CAM slot with the lowest priority (+MAXPRIORITY to assure that values -99..99 can be used)
+#endif /* MCLI */
              imp <<= 1; imp |= ndr;                                                                                  // avoid devices if we need to detach existing receivers
              imp <<= 1; imp |= device[i]->IsPrimaryDevice();                                                         // avoid the primary device
+#ifdef USE_LNBSHARE
+             imp |= (badPriority == -1);                                                                               // avoid cards where the actual device needs to be switched
+#endif /* LNBSHARE */
+#ifdef USE_MCLI
+             imp <<= 1; imp |= (NumUsableSlots || InternalCamNeeded) ? 0 : device[i]->HasCi();                       // avoid cards with Common Interface for FTA channels
+#else
              imp <<= 1; imp |= NumUsableSlots ? 0 : device[i]->HasCi();                                              // avoid cards with Common Interface for FTA channels
+#endif /* MCLI */
              imp <<= 1; imp |= device[i]->HasDecoder();                                                              // avoid full featured cards
+#ifdef USE_MCLI
+             imp <<= 1; imp |= (NumUsableSlots && !device[i]->HasInternalCam()) ? !ChannelCamRelations.CamDecrypt(Channel->GetChannelID(), j + 1) : 0; // prefer CAMs that are known to decrypt this channel
+#else
              imp <<= 1; imp |= NumUsableSlots ? !ChannelCamRelations.CamDecrypt(Channel->GetChannelID(), j + 1) : 0; // prefer CAMs that are known to decrypt this channel
+#endif /* MCLI */
              if (imp < Impact) {
                 // This device has less impact than any previous one, so we take it.
                 Impact = imp;
                 d = device[i];
                 NeedsDetachReceivers = ndr;
+#ifdef USE_MCLI
+                if (NumUsableSlots && !device[i]->HasInternalCam())
+#else
                 if (NumUsableSlots)
+#endif /* MCLI */
                    s = CamSlots.Get(j);
                 }
              }
@@ -583,6 +641,13 @@
   return -1;
 }
 
+#ifdef USE_MCLI
+int cDevice::ReadFilter(int Handle, void *Buffer, size_t Length)
+{
+  return safe_read(Handle, Buffer, Length);
+}
+#endif /* MCLI */
+
 void cDevice::CloseFilter(int Handle)
 {
   close(Handle);
@@ -624,7 +689,11 @@
 bool cDevice::ProvidesTransponderExclusively(const cChannel *Channel) const
 {
   for (int i = 0; i < numDevices; i++) {
+#ifdef USE_LNBSHARE
+      if (device[i] && device[i] != this && device[i]->ProvidesTransponder(Channel) && device[i]->IsShareLnb(this)  )
+#else
       if (device[i] && device[i] != this && device[i]->ProvidesTransponder(Channel))
+#endif /* LNBSHARE */
          return false;
       }
   return true;
@@ -657,6 +726,24 @@
 
 bool cDevice::SwitchChannel(const cChannel *Channel, bool LiveView)
 {
+
+#ifdef USE_LNBSHARE
+  cDevice *tmpDevice;
+       if (this->GetMaxBadPriority(Channel) >= 0) {
+               Skins.Message(mtInfo, tr("Channel locked by LNB!"));
+               return false;
+       }
+       while ((tmpDevice = GetBadDevice(Channel)) != NULL) {
+               if (tmpDevice->IsPrimaryDevice() && LiveView)
+                       tmpDevice->SwitchChannelForced(Channel, true);
+               else
+                       tmpDevice->SwitchChannelForced(Channel, false);
+       }
+    return SwitchChannelForced(Channel, LiveView);
+}
+bool cDevice::SwitchChannelForced(const cChannel *Channel, bool LiveView)
+{
+#endif /* LNBSHARE */
   if (LiveView) {
      isyslog("switching to channel %d", Channel->Number());
      cControl::Shutdown(); // prevents old channel from being shown too long if GetDevice() takes longer
@@ -687,6 +774,9 @@
      cChannel *channel;
      while ((channel = Channels.GetByNumber(n, Direction)) != NULL) {
            // try only channels which are currently available
+#ifdef USE_PINPLUGIN
+        if (cStatus::MsgChannelProtected(0, channel) == false)
+#endif /* PINPLUGIN */
            if (GetDevice(channel, 0, true))
               break;
            n = channel->Number() + Direction;
@@ -706,8 +796,53 @@
   return result;
 }
 
+#ifdef USE_LNBSHARE
+cDevice *cDevice::GetBadDevice(const cChannel *Channel)
+{
+  if(!cSource::IsSat(Channel->Source())) return NULL;  // no conflict if the new channel is not on sat
+  if(!ProvidesSource(cSource::stSat)) return NULL;     // no conflict if this device is not on sat
+  for (int i = 0; i < numDevices; i++) {
+    if (this != device[i] && device[i]->IsShareLnb(this) &&  device[i]->IsLnbConflict(Channel) ) {
+    	// there is a conflict between device[i] and 'this' if we tune this to Channel
+      if (Setup.VerboseLNBlog) {
+        isyslog("LNB %d: Device check for channel %d on device %d. LNB or DiSEq conflict with device %d", LnbNr(), Channel->Number(), this->DeviceNumber(), i);
+      }
+      return device[i];
+    }
+  }
+  if (Setup.VerboseLNBlog) { 
+    isyslog("LNB %d: Device check for for channel %d on device %d. OK", LnbNr(), Channel->Number(), this->DeviceNumber());
+  }
+  return NULL;
+}
+
+int cDevice::GetMaxBadPriority(const cChannel *Channel) const
+{                                
+  if(!cSource::IsSat(Channel->Source())) return -2;  // no conflict if the new channel is not on sat
+  if(!ProvidesSource(cSource::stSat)) return -2;     // no conflict if this device is not on sat
+
+  int maxBadPriority = -2;
+  for (int i = 0; i < numDevices; i++) {
+    if (this != device[i] && device[i]->IsShareLnb(this) && device[i]->IsLnbConflict(Channel) ) {
+    	// there is a conflict between device[i] and 'this' if we tune this to Channel
+      if (device[i]->Receiving() && device[i]->Priority() > maxBadPriority) maxBadPriority = device[i]->Priority();
+      if (i == ActualDevice()->CardIndex() && maxBadPriority < -1 ) maxBadPriority = -1;
+    }
+  }
+
+  if (Setup.VerboseLNBlog) { 
+    isyslog("LNB %d: Request for channel %d on device %d. MaxBadPriority is %d", LnbNr(), Channel->Number(), this->DeviceNumber(), maxBadPriority);
+  }
+  return maxBadPriority;
+}
+#endif /* LNBSHARE */
 eSetChannelResult cDevice::SetChannel(const cChannel *Channel, bool LiveView)
 {
+#ifdef USE_PINPLUGIN
+  if (LiveView && cStatus::MsgChannelProtected(this, Channel) == true)
+     return scrNotAvailable;
+#endif /* PINPLUGIN */
+
   if (LiveView) {
      StopReplay();
      DELETENULL(liveSubtitle);
@@ -719,6 +854,12 @@
   bool NeedsTransferMode = Device != this;
 
   eSetChannelResult Result = scrOk;
+  
+#ifdef USE_LNBSHARE
+  if (Setup.VerboseLNBlog) {
+    isyslog("LNB %d: Switching device %d to channel %d", LnbNr(), this->DeviceNumber(), Channel->Number());
+  }
+#endif /* LNBSHARE */
 
   // If this DVB card can't receive this channel, let's see if we can
   // use the card that actually can receive it and transfer data from there:
@@ -1034,6 +1175,10 @@
      int LanguagePreference = INT_MAX; // higher than the maximum possible value
      for (int i = ttSubtitleFirst; i <= ttSubtitleLast; i++) {
          const tTrackId *TrackId = GetTrack(eTrackType(i));
+#ifdef USE_LIEMIEXT
+         if (TrackId && TrackId->id && (I18nIsPreferredLanguage(Setup.SubtitleLanguages, TrackId->language, LanguagePreference) ||
+             ((i == ttSubtitleFirst + 8) && !(*TrackId->language) && (LanguagePreference == INT_MAX))))
+#endif /* LIEMIEXT */
          if (TrackId && TrackId->id && I18nIsPreferredLanguage(Setup.SubtitleLanguages, TrackId->language, LanguagePreference))
             PreferredTrack = eTrackType(i);
          }
@@ -1245,6 +1390,15 @@
                   }
                break;
           case 0xBD: { // private stream 1
+#ifdef USE_TTXTSUBS
+               // EBU Teletext data, ETSI EN 300 472
+               // if PES data header length = 24 and data_identifier = 0x10..0x1F (EBU Data)
+               if (Data[8] == 0x24 && Data[45] >= 0x10 && Data[45] < 0x20) {
+                  cVDRTtxtsubsHookListener::Hook()->PlayerTeletextData((uint8_t*)Data, Length);
+                  break;
+                  }
+#endif /* TTXTSUBS */
+
                int PayloadOffset = Data[8] + 9;
 
                // Compatibility mode for old subtitles plugin:
@@ -1404,6 +1558,9 @@
      tsToPesVideo.Reset();
      tsToPesAudio.Reset();
      tsToPesSubtitle.Reset();
+#ifdef USE_TTXTSUBS
+     tsToPesTeletext.Reset();
+#endif /* TTXTSUBS */
      }
   else if (Length < TS_SIZE) {
      esyslog("ERROR: skipped %d bytes of TS fragment", Length);
@@ -1449,6 +1606,19 @@
                     if (!VideoOnly || HasIBPTrickSpeed())
                        PlayTsSubtitle(Data, TS_SIZE);
                     }
+#ifdef USE_TTXTSUBS
+                 else if (Pid == patPmtParser.Tpid()) {
+                    if (!VideoOnly || HasIBPTrickSpeed()) {
+                       int l;
+                       tsToPesTeletext.PutTs(Data, Length);
+                       if (const uchar *p = tsToPesTeletext.GetPes(l)) {
+                          if ((l > 45) && (p[0] == 0x00) && (p[1] == 0x00) && (p[2] == 0x01) && (p[3] == 0xbd) && (p[8] == 0x24) && (p[45] >= 0x10) && (p[45] < 0x20))
+                             cVDRTtxtsubsHookListener::Hook()->PlayerTeletextData((uchar *)p, l, false, patPmtParser.TeletextSubtitlePages(), patPmtParser.TotalTeletextSubtitlePages());
+                          tsToPesTeletext.Reset();
+                          }
+                       }
+                    }
+#endif /* TTXTSUBS */
                  }
               }
            else if (Pid == patPmtParser.Ppid()) {
Index: dvbdevice.h
===================================================================
--- dvbdevice.h	(revision 15412)
+++ dvbdevice.h	(revision 15413)
@@ -130,6 +130,22 @@
   virtual ~cDvbDevice();
   virtual bool Ready(void);
 
+#ifdef USE_LNBSHARE
+private:
+  char lnbState;  // Current frequency band and polarization of the DVB-tuner
+  //  cDiseqc *lnbSource;  // can not #include "diseqc.h". A workaround follows:
+  int *lnbSource;  // [DiSEqC] DiSEqC-Source
+  int lnbNr;      // Number of LNB used
+public:
+  int *LnbSource(void) { return lnbSource; };
+  virtual int LnbNr(void) const { if(ProvidesSource(cSource::stSat)) return lnbNr; return CardIndex() * -1;};
+  virtual void SetLnbNrFromSetup(void);
+
+public:
+  virtual bool IsLnbConflict(const cChannel *Channel);
+  virtual bool IsShareLnb(const cDevice *Device);
+#endif /* LNBSHARE */
+
 // Common Interface facilities:
 
 private:
@@ -150,6 +166,9 @@
   virtual bool SetChannelDevice(const cChannel *Channel, bool LiveView);
 public:
   virtual bool HasLock(int TimeoutMs = 0);
+#ifdef USE_ROTOR
+  virtual bool SendDiseqcCmd(dvb_diseqc_master_cmd cmd);
+#endif /* ROTOR */
 
 // PID handle facilities
 
Index: device.h
===================================================================
--- device.h	(revision 15412)
+++ device.h	(revision 15413)
@@ -24,6 +24,9 @@
 #include "spu.h"
 #include "thread.h"
 #include "tools.h"
+#ifdef USE_ROTOR
+#include <linux/dvb/frontend.h>
+#endif /* ROTOR */
 
 #ifdef REELVDR
 bool AnyFreeTuners(); // returns true if a tuner without recording is found
@@ -163,6 +166,38 @@
   static void Shutdown(void);
          ///< Closes down all devices.
          ///< Must be called at the end of the program.
+#ifdef USE_LNBSHARE
+public:
+  static void SetLnbNr(void);
+		  ///< Called after changes in setup
+		  ///< call SetLNBNrFromSetup for each device
+  virtual void SetLnbNrFromSetup(void) {};
+         ///< Called after changes in setup
+         ///< Read Setup.CardUsesLNBnr, write value to member variable of this class
+         ///< Only implemented in dvbdevice, other devices don't use LNBs
+  virtual int LnbNr(void) const { return cardIndex * -1; };
+         ///< Number of LNB. This is -cardIndex for all non-DVB devices.
+         ///< So, there will be no LNB conflicts for non-DVB devices.
+  virtual bool IsShareLnb(const cDevice *Device) { return false; };
+		  ///< True if both devices differ (this != Device) and share the same LNB
+  virtual bool IsLnbConflict(const cChannel *Channel) { return false; };
+         ///< false if 'Channel' can be recieved with the same 
+         ///< LNB as 'this' device is using
+         ///< Otherwise, true
+  cDevice *GetBadDevice(const cChannel *Channel) ;
+         ///< Returns NULL if there is no device which uses the same LNB or if
+         ///< all of those devices are tuned to the same frequency band and
+         ///< polarization as of the requested channel.
+         ///< Otherwise returns the first device found.
+  int GetMaxBadPriority(const cChannel *Channel) const;
+         ///< Returns the highest priority of all receiving devices which use
+         ///< the same LNB and are tuned to a different frequency band or
+         ///< polarization as of the requested channel.
+         ///< Returns -1 if there are no such devices, but the 'actual' device
+         ///< (device recieving live view) would be affected by switching to the requested channel.
+         ///< Returns -2 if there are no such devices and the actual device
+         ///< would not be affected by switching to the requested channel.
+#endif /* LNBSHARE */
 private:
   static int nextCardIndex;
   int cardIndex;
@@ -268,6 +303,11 @@
   bool SwitchChannel(const cChannel *Channel, bool LiveView);
          ///< Switches the device to the given Channel, initiating transfer mode
          ///< if necessary.
+#ifdef USE_LNBSHARE
+  bool SwitchChannelForced(const cChannel *Channel, bool LiveView);
+         ///< Switches the device to the given channel, initiating transfer mode
+         ///< if necessary. Forces the switch without taking care of the LNB configuration.
+#endif /* LNBSHARE */
   static bool SwitchChannel(int Direction);
          ///< Switches the primary device to the next available channel in the given
          ///< Direction (only the sign of Direction is evaluated, positive values
@@ -282,12 +322,18 @@
 
 #endif
 private:
+#ifndef USE_YAEPG
   eSetChannelResult SetChannel(const cChannel *Channel, bool LiveView);
          ///< Sets the device to the given channel (general setup).
+#endif /* YAEPG */
 protected:
   virtual bool SetChannelDevice(const cChannel *Channel, bool LiveView);
          ///< Sets the device to the given channel (actual physical setup).
 public:
+#ifdef USE_YAEPG
+  eSetChannelResult SetChannel(const cChannel *Channel, bool LiveView);
+         ///< Sets the device to the given channel (general setup).
+#endif /* YAEPG */
   static int CurrentChannel(void) { return primaryDevice ? currentChannel : 0; }
          ///< Returns the number of the current channel on the primary device.
   static void SetCurrentChannel(const cChannel *Channel) { currentChannel = Channel ? Channel->Number() : 0; }
@@ -305,6 +351,9 @@
   virtual bool HasProgramme(void);
          ///< Returns true if the device is currently showing any programme to
          ///< the user, either through replaying or live.
+#ifdef USE_ROTOR
+  virtual bool SendDiseqcCmd(dvb_diseqc_master_cmd cmd) {return false;}
+#endif /* ROTOR */
 
 // PID handle facilities
 
@@ -358,6 +407,12 @@
        ///< Opens a file handle for the given filter data.
        ///< A derived device that provides section data must
        ///< implement this function.
+#ifdef USE_MCLI
+  virtual int ReadFilter(int Handle, void *Buffer, size_t Length);
+       ///< Read from a handle for the given filter data.
+       ///< a derived class need not implement this function, because this
+       ///< is done by the default implementation.
+#endif /* MCLI */
   virtual void CloseFilter(int Handle);
        ///< Closes a file handle that has previously been opened
        ///< by OpenFilter(). If this is as simple as calling close(Handle),
@@ -376,6 +431,14 @@
 public:
   virtual bool HasCi(void);
          ///< Returns true if this device has a Common Interface.
+#ifdef USE_MCLI
+  virtual bool HasInternalCam(void) { return false; }
+         ///< Returns true if this device handles encrypted channels itself
+         ///< without VDR assistance. This can be e.g. when the device is a
+         ///< client that gets the stream from another VDR instance that has
+         ///< already decrypted the stream. In this case ProvidesChannel()
+         ///< shall check whether the channel can be decrypted.
+#endif /* MCLI */
   void SetCamSlot(cCamSlot *CamSlot);
          ///< Sets the given CamSlot to be used with this device.
   cCamSlot *CamSlot(void) const { return camSlot; }
@@ -535,6 +598,9 @@
   cTsToPes tsToPesVideo;
   cTsToPes tsToPesAudio;
   cTsToPes tsToPesSubtitle;
+#ifdef USE_TTXTSUBS
+  cTsToPes tsToPesTeletext;
+#endif /* TTXTSUBS */
   bool isPlayingVideo;
 protected:
   const cPatPmtParser *PatPmtParser(void) const { return &patPmtParser; }
Index: menuitems.c
===================================================================
--- menuitems.c	(revision 15412)
+++ menuitems.c	(revision 15413)
@@ -33,9 +33,21 @@
   free(name);
 }
 
+#ifdef USE_VALIDINPUT
+void cMenuEditItem::SetValue(const char *Value, bool HasPre, bool HasSucc)
+#else
 void cMenuEditItem::SetValue(const char *Value)
+#endif /* VALIDINPUT */
 {
   cString buffer = cString::sprintf("%s:\t%s", name, Value);
+#ifdef USE_VALIDINPUT
+  if (Setup.ShowValidInput) {
+     if (HasPre && HasSucc) buffer = cString::sprintf("%s:\t<%s>", name, Value);
+     else if (HasPre)       buffer = cString::sprintf("%s:\t<%s",  name, Value);
+     else if (HasSucc)      buffer = cString::sprintf("%s:\t%s>",  name, Value);
+     }
+#endif /* VALIDINPUT */
+
   SetText(buffer);
   cStatus::MsgOsdCurrentItem(buffer);
 }
@@ -127,7 +139,11 @@
 {
   char buf[16];
   snprintf(buf, sizeof(buf), "%s", *value ? trueString : falseString);
+#ifdef USE_VALIDINPUT
+  SetValue(buf, *value, !*value);
+#else
   SetValue(buf);
+#endif /* VALIDINPUT */
 }
 
 // --- cMenuEditBitItem ------------------------------------------------------
@@ -705,7 +721,11 @@
 
 void cMenuEditStraItem::Set(void)
 {
+#ifdef USE_VALIDINPUT
+  SetValue(strings[*value], (*value > min), (*value < max));
+#else
   SetValue(strings[*value]);
+#endif /* VALIDINPUT */
 }
 
 // --- cMenuEditChanItem -----------------------------------------------------
Index: epg.c
===================================================================
--- epg.c	(revision 15412)
+++ epg.c	(revision 15413)
@@ -930,6 +930,31 @@
   return pe;
 }
 
+#ifdef USE_DDEPGENTRY
+const cEvent *cSchedule::GetPreviousEvent(cEvent *Event) const
+{
+
+   if(!Event || Event->Duration() == 0 || Event->StartTime() == 0)
+      return NULL;
+   // Returns either the event info to the previous/following event to the given EventID or, if that one can't be found NULL :EW
+   cEvent *pt = NULL;
+   int epgTimeDelta = Setup.DoubleEpgTimeDelta * 60 + 1;
+   for (pt = events.First(); pt; pt = events.Next(pt))
+      if(pt && pt->TableID() == 0x00)
+         if ((Event->StartTime() - pt->StartTime()) > -  epgTimeDelta && (Event->StartTime() - pt->StartTime()) < epgTimeDelta)
+         {
+            if((pt->Duration() + (pt->Duration()/ 5) + 1) > Event->Duration() && (pt->Duration() - (pt->Duration()/ 5) - 1) < Event->Duration())
+               return pt;
+            else if (pt->Title() && Event->Title() && (strcmp(pt->Title(), ".") != 0 && strcmp(Event->Title(), ".") != 0))
+            {
+               if (strstr(pt->Title(), Event->Title()) != NULL || strstr(Event->Title(), pt->Title()) != NULL)
+                  return pt;
+            }
+         }
+   return NULL;
+}
+#endif /* DDEPGENTRY */
+
 void cSchedule::SetRunningStatus(cEvent *Event, int RunningStatus, cChannel *Channel)
 {
   hasRunning = false;
Index: menuitems.h
===================================================================
--- menuitems.h	(revision 15412)
+++ menuitems.h	(revision 15413)
@@ -22,7 +22,11 @@
 public:
   cMenuEditItem(const char *Name);
   ~cMenuEditItem();
+#ifdef USE_VALIDINPUT
+  void SetValue(const char *Value, bool HasPre=false, bool HasSucc=false);
+#else
   void SetValue(const char *Value);
+#endif /* VALIDINPUT */
   };
 
 class cMenuEditIntItem : public cMenuEditItem {
@@ -202,6 +206,9 @@
   cMenuSetupPage(void);
   virtual eOSState ProcessKey(eKeys Key);
   void SetPlugin(cPlugin *Plugin);
+#ifdef USE_GRAPHTFT
+  const char* MenuKind() { return "MenuSetupPage"; }
+#endif /* GRAPHTFT */
   };
 
 #endif //__MENUITEMS_H
Index: recording.c
===================================================================
--- recording.c	(revision 15412)
+++ recording.c	(revision 15413)
@@ -8,6 +8,9 @@
  */
 
 #include "recording.h"
+#ifdef USE_WAREAGLEICON
+#include "iconpatch.h"
+#endif /* WAREAGLEICON */
 #include <ctype.h>
 #include <dirent.h>
 #include <errno.h>
@@ -63,6 +66,9 @@
 #define MAX_LINK_LEVEL  6
 
 bool VfatFileSystem = false;
+#ifdef USE_LIEMIEXT
+bool DirOrderState = false;
+#endif /* LIEMIEXT */
 int InstanceId = 0;
 
 cRecordings DeletedRecordings(true);
@@ -823,6 +829,10 @@
 int cRecording::Compare(const cListObject &ListObject) const
 {
   cRecording *r = (cRecording *)&ListObject;
+#ifdef USE_LIEMIEXT
+  if (DirOrderState)
+     return strcasecmp(FileName(), r->FileName());
+#endif /* LIEMIEXT */
   return strcasecmp(SortName(), r->SortName());
 }
 
@@ -841,9 +851,17 @@
   return fileName;
 }
 
+#ifdef USE_LIEMIEXT
+const char *cRecording::Title(char Delimiter, bool NewIndicator, int Level, bool Original) const
+#else
 const char *cRecording::Title(char Delimiter, bool NewIndicator, int Level) const
+#endif /* LIEMIEXT */
 {
+#ifdef USE_WAREAGLEICON
+  const char *New = NewIndicator && IsNew() ? Setup.WarEagleIcons ? IsLangUtf8() ? ICON_NEW_UTF8 : ICON_NEW : "*" : " ";
+#else
   char New = NewIndicator && IsNew() ? '*' : ' ';
+#endif /* WAREAGLEICON */
   free(titleBuffer);
   titleBuffer = NULL;
   if (Level < 0 || Level == HierarchyLevels()) {
@@ -854,7 +872,14 @@
         s++;
      else
         s = name;
+#ifdef USE_LIEMIEXT
+     if (Original) {
+#endif /* LIEMIEXT */
+#ifdef USE_WAREAGLEICON
+     titleBuffer = strdup(cString::sprintf("%02d.%02d.%02d%c%02d:%02d%s%c%s",
+#else
      titleBuffer = strdup(cString::sprintf("%02d.%02d.%02d%c%02d:%02d%c%c%s",
+#endif /* WAREAGLEICON */
                             t->tm_mday,
                             t->tm_mon + 1,
                             t->tm_year % 100,
@@ -864,6 +889,33 @@
                             New,
                             Delimiter,
                             s));
+#ifdef USE_LIEMIEXT
+        }
+     else {
+        cString RecLength("---");
+        if (Setup.ShowRecLength && FileName()) {
+           int length = cIndexFile::Length(FileName(), IsPesRecording());
+           if (length >= 0)
+              RecLength = cString::sprintf("%d'", length / SecondsToFrames(60, framesPerSecond));
+           }
+        cString RecDate = cString::sprintf("%02d.%02d.%02d", t->tm_mday, t->tm_mon + 1, t->tm_year % 100);
+        cString RecTime = cString::sprintf("%02d:%02d", t->tm_hour, t->tm_min);
+        cString RecDelimiter = cString::sprintf("%c", Delimiter);
+#ifdef USE_WAREAGLEICON
+        titleBuffer = strdup(cString::sprintf("%s%s%s%s%s%s%s%s",
+#else
+        titleBuffer = strdup(cString::sprintf("%s%s%s%c%s%s%s%s",
+#endif /* WAREAGLEICON */
+                               (Setup.ShowRecDate ? *RecDate        : ""),
+                               (Setup.ShowRecDate && Setup.ShowRecTime ? *RecDelimiter : ""),
+                               (Setup.ShowRecTime ? *RecTime        : ""),
+                               New,
+                               (Setup.ShowRecTime || Setup.ShowRecDate ? *RecDelimiter : ""),
+                               (Setup.ShowRecLength ? *RecLength    : ""),
+                               (Setup.ShowRecLength ? *RecDelimiter : ""),
+                               s));
+        }
+#endif /* LIEMIEXT */
      // let's not display a trailing FOLDERDELIMCHAR:
      if (!NewIndicator)
         stripspace(titleBuffer);
@@ -892,6 +944,17 @@
   return titleBuffer;
 }
 
+#ifdef USE_CUTTIME
+void cRecording::SetStartTime(time_t Start)
+{
+  start=Start;
+  if (fileName) {
+           free(fileName);
+           fileName = NULL;
+           }
+}
+#endif /* CUTTIME */
+
 const char *cRecording::PrefixFileName(char Prefix)
 {
   cString p = PrefixVideoFileName(FileName(), Prefix);
@@ -1000,6 +1063,45 @@
   resume = RESUME_NOT_INITIALIZED;
 }
 
+#ifdef USE_LIEMIEXT
+bool cRecording::Rename(const char *newName)
+{
+  bool result = false;
+  struct tm tm_r;
+  struct tm *t = localtime_r(&start, &tm_r);
+  char *localNewName = ExchangeChars(strdup(newName), true);
+  const char *fmt = isPesRecording ? NAMEFORMATPES : NAMEFORMATTS;
+  int ch = isPesRecording ? priority : channel;
+  int ri = isPesRecording ? lifetime : instanceId;
+  char *newFileName = strdup(cString::sprintf(fmt, VideoDirectory, localNewName, t->tm_year + 1900, t->tm_mon + 1, t->tm_mday, t->tm_hour, t->tm_min, ch, ri));
+  free(localNewName);
+  if (strcmp(FileName(), newFileName)) {
+     if (access(newFileName, F_OK) == 0) {
+        isyslog("recording %s already exists", newFileName);
+        }
+     else {
+        isyslog("renaming recording %s to %s", FileName(), newFileName);
+        result = MakeDirs(newFileName, true);
+        if (result)
+           result = RenameVideoFile(FileName(), newFileName);
+        if (result) {
+           free(fileName);
+           fileName = strdup(newFileName);
+           free(name);
+           name = strdup(newName);
+           free(sortBuffer);
+           sortBuffer = NULL;
+           free(titleBuffer);
+           titleBuffer = NULL;
+           }
+        }
+     }
+  free(newFileName);
+  return result;
+}
+
+#endif /* LIEMIEXT */
+
 // --- cRecordings -----------------------------------------------------------
 
 cRecordings Recordings;
@@ -1298,14 +1400,74 @@
   return NULL;
 }
 
+#ifdef USE_JUMPPLAY
+// --- cMarksReload ----------------------------------------------------------
+
+#define MARKS_RELOAD_MS 10000
+
+time_t cMarksReload::lastsavetime = 0;
+
+cMarksReload::cMarksReload(const char *RecordingFileName)
+:recDir(RecordingFileName)
+{
+  struct stat sbuf;
+  cRecording rec(recDir);
+  if (Load(recDir, rec.FramesPerSecond(), rec.IsPesRecording()) &&
+      stat(FileName(), &sbuf) == 0)
+     lastmodtime = sbuf.st_mtime;
+  else
+     lastmodtime = 0;
+  nextreload.Set(MARKS_RELOAD_MS - cTimeMs::Now() % MARKS_RELOAD_MS);
+}
+
+bool cMarksReload::Reload(void)
+{
+  // Check the timestamp of marks.vdr in 10 seconds intervals
+  // Independent but synchronized reloading of marks in two threads
+  if ((Setup.ReloadMarks && nextreload.TimedOut()) ||
+      lastsavetime > lastmodtime) {
+     nextreload.Set(MARKS_RELOAD_MS - cTimeMs::Now() % MARKS_RELOAD_MS);
+     struct stat sbuf;
+     if (stat(FileName(), &sbuf) == 0 && sbuf.st_mtime != lastmodtime) {
+        lastmodtime = sbuf.st_mtime;
+        cRecording rec(recDir);
+        if (Load(recDir, rec.FramesPerSecond(), rec.IsPesRecording()))
+           return true;
+        }
+     }
+  return false;
+}
+
+bool cMarksReload::Save(void)
+{
+  bool ok = cMarks::Save();
+  struct stat sbuf;
+  if (ok && stat(FileName(), &sbuf) == 0)
+     lastsavetime = lastmodtime = sbuf.st_mtime;
+  return ok;
+}
+#endif /* JUMPPLAY */
+
 // --- cRecordingUserCommand -------------------------------------------------
 
 const char *cRecordingUserCommand::command = NULL;
 
+#ifdef USE_DVLRECSCRIPTADDON
+void cRecordingUserCommand::InvokeCommand(const char *State, const char *RecordingFileName, char *chanName)
+#else
 void cRecordingUserCommand::InvokeCommand(const char *State, const char *RecordingFileName)
+#endif /* DVLRECSCRIPTADDON */
 {
   if (command) {
+#ifdef USE_DVLRECSCRIPTADDON
+     cString cmd;
+     if (chanName != NULL)
+        cmd = cString::sprintf("%s %s \"%s\" \"%s\"", command, State, *strescape(RecordingFileName, "\\\"$"), chanName);
+     else
+        cmd = cString::sprintf("%s %s \"%s\"", command, State, *strescape(RecordingFileName, "\\\"$"));
+#else
      cString cmd = cString::sprintf("%s %s \"%s\"", command, State, *strescape(RecordingFileName, "\\\"$"));
+#endif /* DVLRECSCRIPTADDON */
      isyslog("executing '%s'", *cmd);
      SystemExec(cmd);
      }
@@ -1777,6 +1939,18 @@
   return false;
 }
 
+#ifdef USE_LIEMIEXT
+int cIndexFile::Length(const char *FileName, bool IsPesRecording)
+{
+  struct stat buf;
+  cString fullname = cString::sprintf("%s%s", FileName, IsPesRecording ? INDEXFILESUFFIX ".vdr" : INDEXFILESUFFIX);
+  if (FileName && *fullname && access(fullname, R_OK) == 0 && stat(fullname, &buf) == 0)
+     return buf.st_size ? (buf.st_size - 1) / sizeof(tIndexTs) + 1 : 0;
+  return -1;
+}
+
+#endif /* LIEMIEXT */
+
 // --- cFileName -------------------------------------------------------------
 
 #define MAXFILESPERRECORDINGPES 255
@@ -1935,6 +2109,22 @@
   return NULL;
 }
 
+#ifdef USE_HARDLINKCUTTER
+off_t cFileName::MaxFileSize() {
+  const int maxVideoFileSize = isPesRecording ? MAXVIDEOFILESIZEPES : MAXVIDEOFILESIZETS;
+  const int setupMaxVideoFileSize = min(maxVideoFileSize, Setup.MaxVideoFileSize);
+  const int maxFileNumber = isPesRecording ? 255 : 65535;
+
+  const off_t smallFiles = (maxFileNumber * off_t(maxVideoFileSize) - 1024 * Setup.MaxRecordingSize)
+                           / max(maxVideoFileSize - setupMaxVideoFileSize, 1);
+
+  if (fileNumber <= smallFiles)
+     return MEGABYTE(off_t(setupMaxVideoFileSize));
+
+  return MEGABYTE(off_t(maxVideoFileSize));
+}
+#endif /* HARDLINKCUTTER */
+
 cUnbufferedFile *cFileName::NextFile(void)
 {
   return SetOffset(fileNumber + 1);
Index: epg.h
===================================================================
--- epg.h	(revision 15412)
+++ epg.h	(revision 15413)
@@ -163,6 +163,9 @@
   void DropOutdated(time_t SegmentStart, time_t SegmentEnd, uchar TableID, uchar Version);
   void Cleanup(time_t Time);
   void Cleanup(void);
+#ifdef USE_DDEPGENTRY
+  const cEvent *GetPreviousEvent(cEvent *Event) const; //:EW
+#endif /* DDEPGENTRY */
   cEvent *AddEvent(cEvent *Event);
   void DelEvent(cEvent *Event);
   void HashEvent(cEvent *Event);
Index: recording.h
===================================================================
--- recording.h	(revision 15412)
+++ recording.h	(revision 15413)
@@ -23,6 +23,9 @@
 #define TIMERMACRO_EPISODE  "EPISODE"
 
 extern bool VfatFileSystem;
+#ifdef USE_LIEMIEXT
+extern bool DirOrderState;
+#endif /* LIEMIEXT */
 extern int InstanceId;
 
 void RemoveDeletedRecordings(void);
@@ -67,6 +70,9 @@
   const cEvent *GetEvent(void) const { return event; }
   const char *Title(void) const { return event->Title(); }
   const char *ShortText(void) const { return event->ShortText(); }
+#ifdef USE_GRAPHTFT
+  tEventID EventID(void) const { return event->EventID(); }
+#endif /* GRAPHTFT */
   const char *Description(void) const { return event->Description(); }
   const cComponents *Components(void) const { return event->Components(); }
   const char *Aux(void) const { return aux; }
@@ -108,8 +114,15 @@
   virtual int Compare(const cListObject &ListObject) const;
   const char *Name(void) const { return name; }
   const char *FileName(void) const;
+#ifdef USE_LIEMIEXT
+  const char *Title(char Delimiter = ' ', bool NewIndicator = false, int Level = -1, bool Original = true) const;
+#else
   const char *Title(char Delimiter = ' ', bool NewIndicator = false, int Level = -1) const;
+#endif /* LIEMIEXT */
   const cRecordingInfo *Info(void) const { return info; }
+#ifdef USE_CUTTIME
+  void SetStartTime(time_t Start);
+#endif /* CUTTIME */
   const char *PrefixFileName(char Prefix);
   int HierarchyLevels(void) const;
   void ResetResume(void) const;
@@ -128,6 +141,11 @@
        // Changes the file name so that it will be visible in the "Recordings" menu again and
        // not processed by cRemoveDeletedRecordingsThread.
        // Returns false in case of error
+#ifdef USE_LIEMIEXT
+  bool Rename(const char *newName);
+       // Changes the file name
+       // Returns false in case of error
+#endif /* LIEMIEXT */
   };
 
 class cRecordings : public cList<cRecording>, public cThread {
@@ -198,6 +216,21 @@
   cMark *GetNext(int Position);
   };
 
+#ifdef USE_JUMPPLAY
+class cMarksReload : public cMarks {
+private:
+  cString recDir;
+  cTimeMs nextreload;
+  time_t lastmodtime;
+  static time_t lastsavetime;
+public:
+  cMarksReload(const char *RecordingFileName);
+  bool Reload(void);
+  bool Save(void);
+  };
+
+#endif /* JUMPPLAY */
+
 #define RUC_BEFORERECORDING "before"
 #define RUC_AFTERRECORDING  "after"
 #define RUC_EDITEDRECORDING "edited"
@@ -207,7 +240,11 @@
   static const char *command;
 public:
   static void SetCommand(const char *Command) { command = Command; }
+#ifdef USE_DVLRECSCRIPTADDON
+  static void InvokeCommand(const char *State, const char *RecordingFileName, char *chanName = NULL);
+#else
   static void InvokeCommand(const char *State, const char *RecordingFileName);
+#endif /* DVLRECSCRIPTADDON */
   };
 
 // The maximum size of a single frame (up to HDTV 1920x1080):
@@ -220,9 +257,23 @@
 // before the next independent frame, to have a complete Group Of Pictures):
 #define MAXVIDEOFILESIZETS  1048570 // MB
 #define MAXVIDEOFILESIZEPES    2000 // MB
+#ifdef USE_HARDLINKCUTTER
+#define MINVIDEOFILESIZE          1 // MB
+#else
 #define MINVIDEOFILESIZE        100 // MB
+#endif /* HARDLINKCUTTER */
 #define MAXVIDEOFILESIZEDEFAULT MAXVIDEOFILESIZEPES
 
+#ifdef USE_HARDLINKCUTTER
+#define MINRECORDINGSIZE      25 // GB
+#define MAXRECORDINGSIZE     500 // GB
+#define DEFAULTRECORDINGSIZE 100 // GB
+// Dynamic recording size:
+// Keep recording file size at Setup.MaxVideoFileSize for as long as possible,
+// but switch to MAXVIDEOFILESIZE early enough, so that Setup.MaxRecordingSize
+// will be reached, before recording to file 65535.vdr
+#endif /* HARDLINKCUTTER */
+
 struct tIndexTs;
 class cIndexFileGenerator;
 
@@ -252,6 +303,10 @@
   bool StoreResume(int Index) { return resumeFile.Save(Index); }
   bool IsStillRecording(void);
   void Delete(void);
+#ifdef USE_LIEMIEXT
+  static int Length(const char *FileName, bool IsPesRecording = false);
+       ///< Calculates the recording length without reading the index.
+#endif /* LIEMIEXT */
   };
 
 class cFileName {
@@ -271,6 +326,10 @@
   cUnbufferedFile *Open(void);
   void Close(void);
   cUnbufferedFile *SetOffset(int Number, off_t Offset = 0); // yes, Number is int for easier internal calculating
+#ifdef USE_HARDLINKCUTTER
+  off_t MaxFileSize();
+      // Dynamic file size for this file
+#endif /* HARDLINKCUTTER */
   cUnbufferedFile *NextFile(void);
   };
 
Index: status.c
===================================================================
--- status.c	(revision 15412)
+++ status.c	(revision 15413)
@@ -124,3 +124,88 @@
   for (cStatus *sm = statusMonitors.First(); sm; sm = statusMonitors.Next(sm))
       sm->OsdProgramme(PresentTime, PresentTitle, PresentSubtitle, FollowingTime, FollowingTitle, FollowingSubtitle);
 }
+#ifdef USE_GRAPHTFT
+
+void cStatus::MsgOsdSetEvent(const cEvent* event)
+{
+  for (cStatus *sm = statusMonitors.First(); sm; sm = statusMonitors.Next(sm))
+      sm->OsdSetEvent(event);
+}
+
+void cStatus::MsgOsdSetRecording(const cRecording* recording)
+{
+  for (cStatus *sm = statusMonitors.First(); sm; sm = statusMonitors.Next(sm))
+      sm->OsdSetRecording(recording);
+}
+
+void cStatus::MsgOsdMenuDisplay(const char* kind)
+{
+  for (cStatus *sm = statusMonitors.First(); sm; sm = statusMonitors.Next(sm))
+      sm->OsdMenuDisplay(kind);
+}
+
+void cStatus::MsgOsdMenuDestroy()
+{
+  for (cStatus *sm = statusMonitors.First(); sm; sm = statusMonitors.Next(sm))
+      sm->OsdMenuDestroy();
+}
+void cStatus::MsgOsdEventItem(const cEvent* Event, const char *Text, int Index, int Count)
+{
+  for (cStatus *sm = statusMonitors.First(); sm; sm = statusMonitors.Next(sm))
+     sm->OsdEventItem(Event, Text, Index, Count);
+}
+#endif /* GRAPHTFT */
+#ifdef USE_PINPLUGIN
+
+bool cStatus::MsgChannelProtected(const cDevice* Device, const cChannel* Channel)
+{
+  for (cStatus *sm = statusMonitors.First(); sm; sm = statusMonitors.Next(sm))
+      if (sm->ChannelProtected(Device, Channel) == true)
+          return true;
+
+  return false;
+}
+
+bool cStatus::MsgReplayProtected(const cRecording* Recording, const char* Name, 
+                                 const char* Base, bool isDirectory, int menuView)
+{
+  for (cStatus *sm = statusMonitors.First(); sm; sm = statusMonitors.Next(sm))
+     if (sm->ReplayProtected(Recording, Name, Base, isDirectory, menuView) == true)
+         return true;
+     return false;
+}
+
+void cStatus::MsgRecordingFile(const char* FileName)
+{
+  for (cStatus *sm = statusMonitors.First(); sm; sm = statusMonitors.Next(sm))
+      sm->RecordingFile(FileName);
+}
+
+void cStatus::MsgTimerCreation(cTimer* Timer, const cEvent *Event)
+{
+  for (cStatus *sm = statusMonitors.First(); sm; sm = statusMonitors.Next(sm))
+     sm->TimerCreation(Timer, Event);
+}
+
+bool cStatus::MsgPluginProtected(cPlugin* Plugin, int menuView)
+{
+  for (cStatus *sm = statusMonitors.First(); sm; sm = statusMonitors.Next(sm))
+     if (sm->PluginProtected(Plugin, menuView) == true)
+         return true;
+     return false;
+}
+
+void cStatus::MsgUserAction(const eKeys key, const cOsdObject* Interact)
+{
+  for (cStatus *sm = statusMonitors.First(); sm; sm = statusMonitors.Next(sm))
+     sm->UserAction(key, Interact);
+}
+
+bool cStatus::MsgMenuItemProtected(const char* Name, int menuView)
+{
+  for (cStatus *sm = statusMonitors.First(); sm; sm = statusMonitors.Next(sm))
+     if (sm->MenuItemProtected(Name, menuView) == true)
+         return true;
+     return false;
+}
+#endif /* PINPLUGIN */
Index: sections.c
===================================================================
--- sections.c	(revision 15412)
+++ sections.c	(revision 15413)
@@ -198,7 +198,11 @@
                   if (fh) {
                      // Read section data:
                      unsigned char buf[4096]; // max. allowed size for any EIT section
+#ifdef USE_MCLI
+                     int r = device->ReadFilter(fh->handle, buf, sizeof(buf));
+#else
                      int r = safe_read(fh->handle, buf, sizeof(buf));
+#endif /* MCLI */
                      if (!DeviceHasLock)
                         continue; // we do the read anyway, to flush any data that might have come from a different transponder
                      if (r > 3) { // minimum number of bytes necessary to get section length
Index: status.h
===================================================================
--- status.h	(revision 15412)
+++ status.h	(revision 15413)
@@ -14,6 +14,9 @@
 #include "device.h"
 #include "player.h"
 #include "tools.h"
+#ifdef USE_PINPLUGIN
+#include "plugin.h"
+#endif
 
 enum eTimerChange { tcMod, tcAdd, tcDel };
 
@@ -80,6 +83,38 @@
                // The OSD displays the single line Text with the current channel information.
   virtual void OsdProgramme(time_t PresentTime, const char *PresentTitle, const char *PresentSubtitle, time_t FollowingTime, const char *FollowingTitle, const char *FollowingSubtitle) {}
                // The OSD displays the given programme information.
+#ifdef USE_GRAPHTFT
+  virtual void OsdSetRecording(const cRecording* recording) {}
+               // The OSD displays the recording information.
+  virtual void OsdSetEvent(const cEvent* event) {}
+               // The OSD displays the event information.
+  virtual void OsdMenuDisplay(const char* kind) {}
+               // report menu creation
+  virtual void OsdMenuDestroy() {}
+               // report menu destruvtion
+  virtual void OsdEventItem(const cEvent* Event, const char *Text, int Index, int Count) {}
+               // The OSD displays the given single line Event as menu item at Index.
+#endif /* GRAPHTFT */
+#ifdef USE_PINPLUGIN
+  virtual bool ChannelProtected(const cDevice *Device, const cChannel* Channel)  { return false; }
+               // Checks if a channel is protected.
+  virtual bool ReplayProtected(const cRecording* Recording, const char* Name,
+                               const char* Base, bool isDirectory, int menuView = false) { return false; }
+               // Checks if a recording is protected.
+  virtual void RecordingFile(const char* FileName) {}
+               // The given DVB device has started recording to FileName. FileName is the name of the
+               // recording directory
+  virtual void TimerCreation(cTimer* Timer, const cEvent *Event) {}
+               // The given timer is created
+  virtual bool PluginProtected(cPlugin* Plugin, int menuView = false)  { return false; }
+               // Checks if a plugin is protected.
+  virtual void UserAction(const eKeys key, const cOsdObject* Interact) {}
+               // report user action
+  virtual bool MenuItemProtected(const char* Name, int menuView = false)  { return false; }
+               // Checks if a menu entry is protected.
+#endif /* PINPLUGIn */
+
+
 public:
   cStatus(void);
   virtual ~cStatus();
@@ -101,6 +136,23 @@
   static void MsgOsdTextItem(const char *Text,  bool Scroll = false);
   static void MsgOsdChannel(const char *Text);
   static void MsgOsdProgramme(time_t PresentTime, const char *PresentTitle, const char *PresentSubtitle, time_t FollowingTime, const char *FollowingTitle, const char *FollowingSubtitle);
+#ifdef USE_GRAPHTFT
+  static void MsgOsdSetEvent(const cEvent* event);
+  static void MsgOsdSetRecording(const cRecording* recording);
+  static void MsgOsdMenuDisplay(const char* kind);
+  static void MsgOsdMenuDestroy();
+  static void MsgOsdEventItem(const cEvent* Event, const char *Text, int Index, int Count);
+#endif /* GRAPHTFT */
+#ifdef USE_PINPLUGIN
+  static bool MsgChannelProtected(const cDevice* Device, const cChannel* Channel);
+  static bool MsgReplayProtected(const cRecording* Recording, const char* Name,
+                                 const char* Base, bool isDirectory, int menuView = false);
+  static void MsgRecordingFile(const char* FileName);
+  static void MsgTimerCreation(cTimer* Timer, const cEvent *Event);
+  static bool MsgPluginProtected(cPlugin* Plugin, int menuView = false);
+  static void MsgUserAction(const eKeys key, const cOsdObject* Interact);
+  static bool MsgMenuItemProtected(const char* Name, int menuView = false);
+#endif /* PINPLUGIN */
   };
 
 #endif //__STATUS_H
Index: channels.c
===================================================================
--- channels.c	(revision 15412)
+++ channels.c	(revision 15413)
@@ -13,11 +13,13 @@
 #include "epg.h"
 #include "libsi/si.h"
 #include "timers.h"
+#ifdef USE_ALTERNATECHANNEL
+#include "tools.h"
+#endif /* ALTERNATECHANNEL */
 #ifdef REELVDR
 #include <vector>
 #endif /*REELVDR*/
 
-
 // IMPORTANT NOTE: in the 'sscanf()' calls there is a blank after the '%d'
 // format characters in order to allow any number of blanks after a numeric
 // value!
@@ -259,6 +261,14 @@
      }
 }
 
+#ifdef USE_ALTERNATECHANNEL
+void cChannel::SetAlternativeChannelID(const char *AlternativeChannelID)
+{
+  if (!isempty(AlternativeChannelID))
+    alternativeChannelID = tChannelID::FromString(AlternativeChannelID);
+}
+#endif /* ALTERNATECHANNEL */
+
 #define STRDIFF 0x01
 #define VALDIFF 0x02
 
@@ -380,6 +390,29 @@
      }
 }
 
+#ifdef USE_TTXTSUBS
+void cChannel::SetTeletextSubtitlePages(tTeletextSubtitlePage pages[], int numberOfPages)
+{
+  int mod = CHANNELMOD_NONE;
+  if (totalTtxtSubtitlePages != (fixedTtxtSubtitlePages + numberOfPages))
+     mod |= CHANNELMOD_PIDS;
+  totalTtxtSubtitlePages = fixedTtxtSubtitlePages;
+  for (int i = 0; (i < numberOfPages) && (totalTtxtSubtitlePages < MAXTXTPAGES); i++) {
+      if (teletextSubtitlePages[totalTtxtSubtitlePages].ttxtMagazine != pages[i].ttxtMagazine ||
+          teletextSubtitlePages[totalTtxtSubtitlePages].ttxtPage != pages[i].ttxtPage ||
+          teletextSubtitlePages[totalTtxtSubtitlePages].ttxtType != pages[i].ttxtType ||
+          strcmp(teletextSubtitlePages[totalTtxtSubtitlePages].ttxtLanguage, pages[i].ttxtLanguage)) {
+         mod |= CHANNELMOD_PIDS;
+         teletextSubtitlePages[totalTtxtSubtitlePages] = pages[i];
+         }
+      totalTtxtSubtitlePages++;
+      }
+  modification |= mod;
+  Channels.SetModified();
+}
+
+#endif /* TTXTSUBS */
+
 void cChannel::SetCaIds(const int *CaIds)
 {
   if (caids[0] && caids[0] <= CA_USER_MAX)
@@ -508,11 +541,28 @@
         q += IntArrayToString(q, Channel->dpids, 10, Channel->dlangs, Channel->dtypes);
         }
      *q = 0;
+#ifdef USE_TTXTSUBS
+     const int TBufferSize = 5 + 1 + (MAXTXTPAGES * (3 + 1 + MAXLANGCODE1 + 1)) + 10; // '12345;150=deu,151=fin,...', +10: paranoia
+     char tpidbuf[TBufferSize];
+     q = tpidbuf;
+     q += snprintf(q, sizeof(tpidbuf), "%d", Channel->tpid);
+     if (Channel->fixedTtxtSubtitlePages > 0) {
+        q += snprintf(q, sizeof(tpidbuf) - (q - tpidbuf), ";");
+        for (int i = 0; i < Channel->fixedTtxtSubtitlePages; ++i) {
+            tTeletextSubtitlePage page = Channel->teletextSubtitlePages[i];
+            q += snprintf(q, sizeof(tpidbuf) - (q - tpidbuf), "%d=%s", page.PageNumber(), page.ttxtLanguage);
+            }
+        }
+#endif /* TTXTSUBS */
      char caidbuf[MAXCAIDS * 5 + 10]; // 5: 4 digits plus delimiting ',', 10: paranoia
      q = caidbuf;
      q += IntArrayToString(q, Channel->caids, 16);
      *q = 0;
+#ifdef USE_TTXTSUBS
+     buffer = cString::sprintf("%s:%d:%s:%s:%d:%s:%s:%s:%s:%d:%d:%d:%d\n", FullName, Channel->frequency, *Channel->parameters, *cSource::ToString(Channel->source), Channel->srate, vpidbuf, apidbuf, tpidbuf, caidbuf, Channel->sid, Channel->nid, Channel->tid, Channel->rid);
+#else
      buffer = cString::sprintf("%s:%d:%s:%s:%d:%s:%s:%d:%s:%d:%d:%d:%d\n", FullName, Channel->frequency, *Channel->parameters, *cSource::ToString(Channel->source), Channel->srate, vpidbuf, apidbuf, Channel->tpid, caidbuf, Channel->sid, Channel->nid, Channel->tid, Channel->rid);
+#endif /* TTXTSUBS */
      }
   return buffer;
 }
@@ -546,8 +596,15 @@
      char *parambuf = NULL;
      char *vpidbuf = NULL;
      char *apidbuf = NULL;
+#ifdef USE_TTXTSUBS
+     char *tpidbuf = NULL;
+#endif /* TTXTSUBS */
      char *caidbuf = NULL;
+#ifdef USE_TTXTSUBS
+     int fields = sscanf(s, "%a[^:]:%d :%a[^:]:%a[^:] :%d :%a[^:]:%a[^:]:%a[^:]:%a[^:]:%d :%d :%d :%d ", &namebuf, &frequency, &parambuf, &sourcebuf, &srate, &vpidbuf, &apidbuf, &tpidbuf, &caidbuf, &sid, &nid, &tid, &rid);
+#else
      int fields = sscanf(s, "%a[^:]:%d :%a[^:]:%a[^:] :%d :%a[^:]:%a[^:]:%d :%a[^:]:%d :%d :%d :%d ", &namebuf, &frequency, &parambuf, &sourcebuf, &srate, &vpidbuf, &apidbuf, &tpid, &caidbuf, &sid, &nid, &tid, &rid);
+#endif /* TTXTSUBS */
      if (fields >= 9) {
         if (fields == 9) {
            // allow reading of old format
@@ -647,6 +704,39 @@
               dtypes[NumDpids] = 0;
               }
 
+#ifdef USE_TTXTSUBS
+           if (tpidbuf) {
+              char *p;
+              fixedTtxtSubtitlePages = 0;
+              // 2001;150=deu,151=fin
+              if ((p = strchr(tpidbuf, ';')) != NULL) {
+                 char *q, *strtok_next;
+                 *p++ = 0;
+                 while ((q = strtok_r(p, ",", &strtok_next)) != NULL) {
+                       if (fixedTtxtSubtitlePages < MAXTXTPAGES) {
+                          int page;
+                          char *l = strchr(q, '=');
+                          if (l)
+                             *l++ = 0;
+                          if (sscanf(q, "%d", &page) == 1) {
+                             teletextSubtitlePages[fixedTtxtSubtitlePages] = tTeletextSubtitlePage(page);
+                             if (l)
+                                strn0cpy(teletextSubtitlePages[fixedTtxtSubtitlePages].ttxtLanguage, l, MAXLANGCODE1);
+                             fixedTtxtSubtitlePages++;
+                             }
+                          else
+                             esyslog("ERROR: invalid Teletext page!"); // no need to set ok to 'false'
+                          }
+                       else
+                          esyslog("ERROR: too many Teletext pages!"); // no need to set ok to 'false'
+                       p = NULL;
+                       }
+                 totalTtxtSubtitlePages = fixedTtxtSubtitlePages;
+                 }
+              if (sscanf(tpidbuf, "%d", &tpid) != 1)
+                 return false;
+              }
+#endif /* TTXTSUBS */
            if (caidbuf) {
               char *p = caidbuf;
               char *q;
@@ -683,6 +773,9 @@
         free(sourcebuf);
         free(vpidbuf);
         free(apidbuf);
+#ifdef USE_TTXTSUBS
+        free(tpidbuf);
+#endif /* TTXTSUBS */
         free(caidbuf);
         free(namebuf);
         if (!GetChannelID().Valid()) {
@@ -759,52 +852,105 @@
 #ifdef REELVDR
 bool cChannels::Reload(const char *FileName, bool AllowComments, bool MustExist)
 {
+
   Timers.Save();
+
   std::vector<tChannelID> channelIDs; //TB: remember the channelIDs of the timers, they don't survive loading the channellist
+
   for (int i = 0; i<Timers.Count(); i++) {
-    cTimer *timer = Timers.Get(i);
-    if(timer->Channel())
-      channelIDs.push_back(timer->Channel()->GetChannelID());
-    //printf("timer: \"%s\" on channel nr %i: \"%s\"\n", timer->Event() ? timer->Event()->Title() : "(NULL)", timer->Channel() ? timer->Channel()->Number() : -1, timer->Channel() ? timer->Channel()->Name() : "(NULL)");
+      cTimer *timer = Timers.Get(i);
+      if(timer->Channel())
+        channelIDs.push_back(timer->Channel()->GetChannelID());
+      //printf("timer: \"%s\" on channel nr %i: \"%s\"\n", timer->Event() ? timer->Event()->Title() : "(NULL)", timer->Channel() ? timer->Channel()->Number() : -1, timer->Channel() ? timer->Channel()->Name() : "(NULL)");
   }
+
   cChannel *channel = new cChannel;
   channel->Parse("VDR:1:H:0:27500:0:0:0:0:1:0:0:0");
+
   cDevice::PrimaryDevice()->SwitchChannel(channel, true);
+
   if (cConfig<cChannel>::Load(FileName, false, true)) {
-    DeleteDuplicateChannels();
-    ReNumber();
-    if (Count()) {
-      cDevice::PrimaryDevice()->SwitchChannel(1);
-      //CheckTimers(tmpTimers);
-      if(Setup.ReelboxModeTemp == eModeStandalone)
+     DeleteDuplicateChannels();
+     ReNumber();
+     if (Count()) {
+        cDevice::PrimaryDevice()->SwitchChannel(1);
+        //CheckTimers(tmpTimers);
+        if(Setup.ReelboxModeTemp == eModeStandalone)
         //    Timers.Load(); // XXX Deletes all
         for (int i = 0; i<Timers.Count(); i++) {
-          cTimer *timer = Timers.Get(i);
-          cChannel *chan = Channels.GetByChannelID(channelIDs.at(i));
-          if (chan) {
-            timer->SetChannel(chan);
-          } else {
-            chan = Channels.GetByChannelID(channelIDs.at(i), true);
+            cTimer *timer = Timers.Get(i);
+            cChannel *chan = Channels.GetByChannelID(channelIDs.at(i));
             if (chan) {
-              timer->SetChannel(chan);
-            } else if(Setup.ReelboxMode != eModeClient) { //TB: do not delete the timer in client-mode, it could have a valid channel on the "AVG-server"
-              Timers.Del(timer);
+                timer->SetChannel(chan);
+            } else {
+                chan = Channels.GetByChannelID(channelIDs.at(i), true);
+                if (chan) {
+                    timer->SetChannel(chan);
+                } else if(Setup.ReelboxMode != eModeClient) { //TB: do not delete the timer in client-mode, it could have a valid channel on the "AVG-server"
+                    Timers.Del(timer);
+                }
             }
-          }
-          //printf("timer: \"%s\" on channel nr %i: \"%s\"\n", timer->Event() ? timer->Event()->Title() : "(NULL)", timer->Channel() ? timer->Channel()->Number() : -1, timer->Channel() ? timer->Channel()->Name() : "(NULL)");
+            //printf("timer: \"%s\" on channel nr %i: \"%s\"\n", timer->Event() ? timer->Event()->Title() : "(NULL)", timer->Channel() ? timer->Channel()->Number() : -1, timer->Channel() ? timer->Channel()->Name() : "(NULL)");
         }
 #ifdef NOEPG_CHANNELSCONF
-      // build path to noepgchannels.conf from channels.conf path
-      std::string sPath=FileName; int nPos = sPath.rfind('/'); sPath.erase(nPos + 1); sPath += NOEPG_CHANNELSCONF;
-      SyncNoEPGChannels(sPath.c_str());       // After reading channels.conf synchronize nepg list
+        // build path to noepgchannels.conf from channels.conf path
+        std::string sPath=FileName; int nPos = sPath.rfind('/'); sPath.erase(nPos + 1); sPath += NOEPG_CHANNELSCONF;
+        SyncNoEPGChannels(sPath.c_str());       // After reading channels.conf synchronize nepg list
 #endif /* NOEPG_CHANNELSCONF */
-      return true;
-    }
-  }
+
+        return true;
+        }
+     }
+
   return false;
+
 }
 #endif /*REELVDR*/
 
+#ifdef USE_ALTERNATECHANNEL
+bool cChannels::LoadAlternativeChannels(const char *FileName)
+{
+  FILE *fp;
+  char *line;
+  cReadLine ReadLine;
+  cChannel *origChannel;
+  tChannelID channelID;
+  if ((fp = fopen(FileName,"r"))==NULL)
+  {
+    esyslog("Can't open Alternative Channels-File <%s>",FileName);
+    return false;
+  }
+  while ((line = ReadLine.Read(fp)) != NULL)
+  {
+    if (line[0] != '#')
+    {
+      line=strtok(line, ";");
+      if (line != NULL)
+      {
+        channelID = tChannelID::FromString(line);
+        if (channelID == tChannelID::InvalidID)
+          dsyslog("Skipping invalid channel ID <%s>",line);
+        else {
+          origChannel = Channels.GetByChannelID(channelID);
+          if (!origChannel)
+            dsyslog("Skipping unknown channel ID <%s>",line);
+          else {
+            line=strtok(NULL, ";");
+            channelID = tChannelID::FromString(line);
+            if (channelID == tChannelID::InvalidID || !Channels.GetByChannelID(channelID))
+              dsyslog("Skipping invalid/unknown alternative channel ID <%s>",line);
+            else
+              origChannel->SetAlternativeChannelID(line);
+          }
+        }
+      }
+    }
+  } while (line != NULL);
+  fclose(fp);
+  return true;
+}
+#endif /* ALTERNATECHANNEL */
+
 void cChannels::HashChannel(cChannel *Channel)
 {
   channelsHashSid.Add(Channel, Channel->Sid());
Index: channels.h
===================================================================
--- channels.h	(revision 15412)
+++ channels.h	(revision 15413)
@@ -39,6 +39,9 @@
 #else
 #define MAXCAIDS  8 // conditional access
 #endif /*REELVDR*/
+#ifdef USE_TTXTSUBS
+#define MAXTXTPAGES 8 // teletext pages
+#endif /* TTXTSUBS */
 
 #define MAXLANGCODE1 4 // a 3 letter language code, zero terminated
 #define MAXLANGCODE2 8 // up to two 3 letter language codes, separated by '+' and zero terminated
@@ -75,6 +78,18 @@
   static const tChannelID InvalidID;
   };
 
+#ifdef USE_TTXTSUBS
+struct tTeletextSubtitlePage {
+  tTeletextSubtitlePage(void) { ttxtPage = ttxtMagazine = 0; ttxtType = 0x02; strcpy(ttxtLanguage, "und"); }
+  tTeletextSubtitlePage(int page) { ttxtMagazine = (page / 100) & 0x7; ttxtPage = (((page % 100) / 10) << 4) + (page % 10); ttxtType = 0x02; strcpy(ttxtLanguage, "und"); }
+  char ttxtLanguage[MAXLANGCODE1];
+  uchar ttxtPage;
+  uchar ttxtMagazine;
+  uchar ttxtType;
+  int PageNumber(void) const { return BCDCHARTOINT(ttxtMagazine) * 100 + BCDCHARTOINT(ttxtPage); }
+  };
+#endif /* TTXTSUBS */
+
 class cChannel;
 
 class cLinkChannel : public cListObject {
@@ -100,6 +115,9 @@
   char *shortName;
   char *provider;
   char *portalName;
+#ifdef USE_ALTERNATECHANNEL
+  tChannelID alternativeChannelID;
+#endif /* ALTERNATECHANNEL */
   int __BeginData__;
   int frequency; // MHz
   int source;
@@ -119,6 +137,11 @@
   uint16_t compositionPageIds[MAXSPIDS];
   uint16_t ancillaryPageIds[MAXSPIDS];
   int tpid;
+#ifdef USE_TTXTSUBS
+  int fixedTtxtSubtitlePages;
+  int totalTtxtSubtitlePages;
+  tTeletextSubtitlePage teletextSubtitlePages[MAXTXTPAGES];
+#endif /* TTXTSUBS */
   int caids[MAXCAIDS + 1]; // list is zero-terminated
   int nid;
   int tid;
@@ -145,6 +168,9 @@
   const char *ShortName(bool OrName = false) const { return (OrName && isempty(shortName)) ? name : shortName; }
   const char *Provider(void) const { return provider; }
   const char *PortalName(void) const { return portalName; }
+#ifdef USE_ALTERNATECHANNEL
+  const tChannelID AlternativeChannelID(void) const { return alternativeChannelID; }
+#endif /* ALTERNATECHANNEL */
   int Frequency(void) const { return frequency; } ///< Returns the actual frequency, as given in 'channels.conf'
   int Transponder(void) const;                    ///< Returns the transponder frequency in MHz, plus the polarization in case of sat
   static int Transponder(int Frequency, char Polarization); ///< builds the transponder from the given Frequency and Polarization
@@ -168,6 +194,10 @@
   uint16_t CompositionPageId(int i) const { return (0 <= i && i < MAXSPIDS) ? compositionPageIds[i] : uint16_t(0); }
   uint16_t AncillaryPageId(int i) const { return (0 <= i && i < MAXSPIDS) ? ancillaryPageIds[i] : uint16_t(0); }
   int Tpid(void) const { return tpid; }
+#ifdef USE_TTXTSUBS
+  const tTeletextSubtitlePage *TeletextSubtitlePages() const { return teletextSubtitlePages; }
+  int TotalTeletextSubtitlePages() const { return totalTtxtSubtitlePages; }
+#endif /* TTXTSUBS */
   const int *Caids(void) const { return caids; }
   int Ca(int Index = 0) const { return Index < MAXCAIDS ? caids[Index] : 0; }
   int Nid(void) const { return nid; }
@@ -179,7 +209,7 @@
   bool GroupSep(void) const { return groupSep; }
 #ifdef REELVDR
   void SetGroupSep(bool GroupSep) { groupSep=GroupSep; }
-#endif
+#endif /*REELVDR*/
   const char *Parameters(void) const { return parameters; }
   const cLinkChannels* LinkChannels(void) const { return linkChannels; }
   const cChannel *RefChannel(void) const { return refChannel; }
@@ -196,7 +226,13 @@
   void SetId(int Nid, int Tid, int Sid, int Rid = 0);
   void SetName(const char *Name, const char *ShortName, const char *Provider);
   void SetPortalName(const char *PortalName);
+#ifdef USE_ALTERNATECHANNEL
+  void SetAlternativeChannelID(const char *AlternativeChannelID);
+#endif /* ALTERNATECHANNEL */
   void SetPids(int Vpid, int Ppid, int Vtype, int *Apids, int *Atypes, char ALangs[][MAXLANGCODE2], int *Dpids, int *Dtypes, char DLangs[][MAXLANGCODE2], int *Spids, char SLangs[][MAXLANGCODE2], int Tpid);
+#ifdef USE_TTXTSUBS
+  void SetTeletextSubtitlePages(tTeletextSubtitlePage pages[], int numberOfPages);
+#endif /* TTXTSUBS */
   void SetCaIds(const int *CaIds); // list must be zero-terminated
   void SetCaDescriptors(int Level);
   void SetLinkChannels(cLinkChannels *LinkChannels);
@@ -216,7 +252,10 @@
   bool Load(const char *FileName, bool AllowComments = false, bool MustExist = false);
 #ifdef REELVDR
   bool Reload(const char *FileName, bool AllowComments = false, bool MustExist = false);
-#endif /*REELVDR*/
+#endif
+#ifdef USE_ALTERNATECHANNEL
+  bool LoadAlternativeChannels(const char *FileName);
+#endif /* ALTERNATECHANNEL */
   void HashChannel(cChannel *Channel);
   void UnhashChannel(cChannel *Channel);
   int GetNextGroup(int Idx);   // Get next channel group
Index: videodir.c
===================================================================
--- videodir.c	(revision 15412)
+++ videodir.c	(revision 15413)
@@ -39,6 +39,11 @@
   bool Next(void);
   void Store(void);
   const char *Adjust(const char *FileName);
+#ifdef USE_DVLVIDPREFER
+  char *GetVidPath(int nVid);
+  bool GetPreferedVideoDir(void);
+  bool IsVidDirOK(int nVid, int *freeMB = NULL);
+#endif /* DVLVIDPREFER */
   };
 
 cVideoDirectory::cVideoDirectory(void)
@@ -120,6 +125,9 @@
   if ((Flags & O_CREAT) != 0) {
      cVideoDirectory Dir;
      if (Dir.IsDistributed()) {
+#ifdef USE_DVLVIDPREFER
+        if (Setup.UseVidPrefer == 0) {
+#endif /* DVLVIDPREFER */
         // Find the directory with the most free space:
         int MaxFree = Dir.FreeMB();
         while (Dir.Next()) {
@@ -129,14 +137,24 @@
                  MaxFree = Free;
                  }
               }
+#ifdef USE_DVLVIDPREFER
+        }
+          else Dir.GetPreferedVideoDir();
+#endif /* DVLVIDPREFER */
         if (Dir.Stored()) {
            ActualFileName = Dir.Adjust(FileName);
            if (!MakeDirs(ActualFileName, false))
               return NULL; // errno has been set by MakeDirs()
+#ifdef USE_DVLVIDPREFER
+           if (strcmp(ActualFileName, FileName) != 0) {
+#endif /* DVLVIDPREFER */
            if (symlink(ActualFileName, FileName) < 0) {
               LOG_ERROR_STR(FileName);
               return NULL;
               }
+#ifdef USE_DVLVIDPREFER
+              }
+#endif /* DVLVIDPREFER */
            ActualFileName = strdup(ActualFileName); // must survive Dir!
            }
         }
@@ -171,6 +189,123 @@
   return RemoveFileOrDir(FileName, true);
 }
 
+#ifdef USE_HARDLINKCUTTER
+static bool StatNearestDir(const char *FileName, struct stat *Stat)
+{
+  cString Name(FileName);
+  char *p;
+  while ((p = strrchr((char*)(const char*)Name + 1, '/')) != NULL) {
+     *p = 0; // truncate at last '/'
+     if (stat(Name, Stat) == 0) {
+        isyslog("StatNearestDir: Stating %s", (const char*)Name);
+        return true;
+        }
+     }
+  return false;
+}
+
+bool HardLinkVideoFile(const char *OldName, const char *NewName)
+{
+  // Incoming name must be in base video directory:
+  if (strstr(OldName, VideoDirectory) != OldName) {
+     esyslog("ERROR: %s not in %s", OldName, VideoDirectory);
+     return false;
+     }
+  if (strstr(NewName, VideoDirectory) != NewName) {
+     esyslog("ERROR: %s not in %s", NewName, VideoDirectory);
+     return false;
+     }
+
+  const char *ActualNewName = NewName;
+  cString ActualOldName(ReadLink(OldName), true);
+
+  // Some safety checks:
+  struct stat StatOldName;
+  if (lstat(ActualOldName, &StatOldName) == 0) {
+     if (S_ISLNK(StatOldName.st_mode)) {
+        esyslog("HardLinkVideoFile: Failed to resolve symbolic link %s", (const char*)ActualOldName);
+        return false;
+        }
+     }
+  else {
+     esyslog("HardLinkVideoFile: lstat failed on %s", (const char*)ActualOldName);
+     return false;
+     }
+  isyslog("HardLinkVideoFile: %s is on %i", (const char*)ActualOldName, (int)StatOldName.st_dev);
+
+  // Find the video directory where ActualOldName is located
+
+  cVideoDirectory Dir;
+  struct stat StatDir;
+  if (!StatNearestDir(NewName, &StatDir)) {
+     esyslog("HardLinkVideoFile: stat failed on %s", NewName);
+     return false;
+     }
+
+  isyslog("HardLinkVideoFile: %s is on %i", NewName, (int)StatDir.st_dev);
+  if (StatDir.st_dev != StatOldName.st_dev) {
+     // Not yet found.
+
+     if (!Dir.IsDistributed()) {
+        esyslog("HardLinkVideoFile: No matching video folder to hard link %s", (const char*)ActualOldName);
+        return false;
+        }
+
+     // Search in video01 and upwards
+     bool found = false;
+     while (Dir.Next()) {
+        Dir.Store();
+        const char *TmpNewName = Dir.Adjust(NewName);
+        if (StatNearestDir(TmpNewName, &StatDir) && StatDir.st_dev == StatOldName.st_dev) {
+           isyslog("HardLinkVideoFile: %s is on %i (match)", TmpNewName, (int)StatDir.st_dev);
+           ActualNewName = TmpNewName;
+           found = true;
+           break;
+           }
+        isyslog("HardLinkVideoFile: %s is on %i", TmpNewName, (int)StatDir.st_dev);
+        }
+     if (ActualNewName == NewName) {
+        esyslog("HardLinkVideoFile: No matching video folder to hard link %s", (const char*)ActualOldName);
+        return false;
+        }
+
+     // Looking good, we have a match. Create necessary folders.
+     if (!MakeDirs(ActualNewName, false))
+        return false;
+     // There's no guarantee that the directory of ActualNewName
+     // is on the same device as the dir that StatNearestDir found.
+     // But worst case is that the link fails.
+     }
+
+#ifdef HARDLINK_TEST_ONLY
+  // Do the hard link to *.vdr_ for testing only
+  char *name = NULL;
+  asprintf(&name, "%s_",ActualNewName);
+  link(ActualOldName, name);
+  free(name);
+  return false;
+#endif // HARDLINK_TEST_ONLY
+
+  // Try creating the hard link
+  if (link(ActualOldName, ActualNewName) != 0) {
+     // Failed to hard link. Maybe not allowed on file system.
+     LOG_ERROR_STR(ActualNewName);
+     isyslog("HardLinkVideoFile: failed to hard link from %s to %s", (const char*)ActualOldName, ActualNewName);
+     return false;
+     }
+
+  if (ActualNewName != NewName) {
+     // video01 and up. Do the remaining symlink
+     if (symlink(ActualNewName, NewName) < 0) {
+        LOG_ERROR_STR(NewName);
+        return false;
+        }
+     }
+  return true;
+}
+
+#endif /* HARDLINKCUTTER */
+
 bool VideoFileSpaceAvailable(int SizeMB)
 {
   cVideoDirectory Dir;
@@ -235,6 +370,129 @@
      } while (Dir.Next());
 }
 
+#ifdef USE_DVLVIDPREFER
+// returns path to nVid'th video directory or NULL if not existing
+char *cVideoDirectory::GetVidPath(int nVid)
+{
+  char *b = strdup(VideoDirectory);
+  int l = strlen(b), di, n;
+
+  while (l-- > 0 && isdigit(b[ l ]));
+
+  l++;
+  di = strlen(b) - l;
+
+  // di == number of digits
+  n = atoi(&b[ l ]);
+  if (n != 0)
+     return NULL;
+
+  // add requested number to dir name
+  sprintf(&b[ l ], "%0*d", di, nVid);
+
+  if (DirectoryOk(b) == true)
+     return b;
+
+  free(b);
+  return NULL;
+}
+
+// checks if a video dir is 'valid'
+bool cVideoDirectory::IsVidDirOK(int nVid, int *freeMB)
+{
+  char *dn;
+  int fMB;
+
+  if (nVid >= Setup.nVidPrefer)
+     return false;
+
+  if (Setup.VidPreferSize[ nVid ] == -1)
+     return false;
+
+  dn = GetVidPath(nVid);
+  if (dn == NULL)
+     return false;
+
+  fMB = FreeDiskSpaceMB(dn, NULL);
+  if (freeMB != NULL)
+     *freeMB = fMB;
+
+  free(dn);
+
+  if (Setup.VidPreferSize[ nVid ] >= fMB)
+     return false;
+  return true;
+}
+
+
+// calculates which video dir to use
+bool cVideoDirectory::GetPreferedVideoDir(void)
+{
+  cVideoDirectory d;
+  int nDirs = 1,
+  vidUse = Setup.nVidPrefer;
+  int i, top, topFree, x;
+
+  if (name == NULL)
+     return(false);
+
+  // count available video dirs
+  while (d.Next() == true)
+        nDirs++;
+
+  if (vidUse > nDirs)
+     vidUse = nDirs;
+
+  // check for prefered video dir
+  for (i = 0, top = -1, topFree = 0; i < vidUse; i++) {
+      if (IsVidDirOK(i, &x) == true) {
+         if (top == -1) {
+            // nothing set yet, use first 'ok' dir
+            top = i;
+            topFree = x;
+            }
+         else {
+            // check if we got a higher priority
+            if (Setup.VidPreferPrio[ i ] >= Setup.VidPreferPrio[ top ]) {
+               top = i;
+               topFree = x;
+               }
+            // check if we got same priority but more space
+            else if (Setup.VidPreferPrio[ i ] == Setup.VidPreferPrio[ top ] && x >= topFree) {
+               top = i;
+               topFree = x;
+               }
+            }
+         }
+      }
+
+  if (top == -1) {
+     isyslog("VidPrefer: no prefered video directory could be determined!");
+
+     // something went wrong here...
+     // let VDR determine the video directory
+     int MaxFree = FreeMB();
+
+     while (Next()) {
+           int Free = FreeDiskSpaceMB(Name());
+
+           if (Free > MaxFree) {
+              Store();
+              MaxFree = Free;
+              }
+           }
+     }
+  else {
+     isyslog("VidPrefer: prefered video directory '%d' set.", top);
+     if (stored != NULL)
+        free(stored);
+     stored = GetVidPath(top);
+     }
+
+  return true;
+}
+#endif /* DVLVIDPREFER */
+
 bool IsOnVideoDirectoryFileSystem(const char *FileName)
 {
   cVideoDirectory Dir;
Index: videodir.h
===================================================================
--- videodir.h	(revision 15412)
+++ videodir.h	(revision 15413)
@@ -22,6 +22,9 @@
 int CloseVideoFile(cUnbufferedFile *File);
 bool RenameVideoFile(const char *OldName, const char *NewName);
 bool RemoveVideoFile(const char *FileName);
+#ifdef USE_HARDLINKCUTTER
+bool HardLinkVideoFile(const char *OldName, const char *NewName);
+#endif /* HARDLINKCUTTER */
 bool VideoFileSpaceAvailable(int SizeMB);
 int VideoDiskSpace(int *FreeMB = NULL, int *UsedMB = NULL); // returns the used disk space in percent
 cString PrefixVideoFileName(const char *FileName, char Prefix);
Index: osdbase.c
===================================================================
--- osdbase.c	(revision 15412)
+++ osdbase.c	(revision 15413)
@@ -15,7 +15,7 @@
 #include "status.h"
 #ifdef REELVDR
 #include "help.h"
-#endif /*REELVDR*/
+#endif
 
 // --- cOsdItem --------------------------------------------------------------
 
@@ -98,6 +98,9 @@
 {
   isMenu = true;
   digit = 0;
+#ifdef USE_LIEMIEXT
+  key_nr = -1;
+#endif /* LIEMIEXT */
   hasHotkeys = false;
   title = NULL;
   SetTitle(Title);
@@ -118,6 +121,9 @@
   free(status);
   displayMenu->Clear();
   cStatus::MsgOsdClear();
+#ifdef USE_GRAPHTFT
+  cStatus::MsgOsdMenuDestroy();
+#endif /* GRAPHTFT */
   if (!--displayMenuCount)
      DELETENULL(displayMenu);
 }
@@ -140,7 +146,11 @@
         digit = -1; // prevents automatic hotkeys - input already has them
      if (digit >= 0) {
         digit++;
+#ifdef USE_LIEMIEXT
+        buffer = cString::sprintf(" %2d%s %s", digit, (digit > 9) ? "" : " ", s);
+#else
         buffer = cString::sprintf(" %c %s", (digit < 10) ? '0' + digit : ' ' , s);
+#endif /* LIEMIEXT */
         s = buffer;
         }
      }
@@ -322,6 +332,9 @@
   displayMenu->SetMessage(mtStatus, NULL);
   displayMenu->Clear();
   cStatus::MsgOsdClear();
+#ifdef USE_GRAPHTFT
+  cStatus::MsgOsdMenuDisplay(MenuKind());
+#endif /* GRAPHTFT */
   displayMenu->SetTabs(cols[0], cols[1], cols[2], cols[3], cols[4]);//XXX
   displayMenu->SetTitle(title);
   cStatus::MsgOsdTitle(title);
@@ -569,20 +582,79 @@
      }
 }
 
+#ifdef USE_LIEMIEXT
+#define MENUKEY_TIMEOUT 1500
+#endif /* LIEMIEXT */
+
 eOSState cOsdMenu::HotKey(eKeys Key)
 {
+#ifdef USE_LIEMIEXT
+  bool match = false;
+  bool highlight = false;
+  int  item_nr;
+  int  i;
+
+  if (Key == kNone) {
+     if (lastActivity.TimedOut())
+        Key = kOk;
+     else
+        return osContinue;
+     }
+  else {
+     lastActivity.Set(MENUKEY_TIMEOUT);
+     }
+  for (cOsdItem *item = Last(); item; item = Prev(item)) {
+#else
   for (cOsdItem *item = First(); item; item = Next(item)) {
+#endif /* LIEMIEXT */
       const char *s = item->Text();
+#ifdef USE_LIEMIEXT
+      i = 0;
+      item_nr = 0;
+      if (s && (s = skipspace(s)) != '\0' && '0' <= s[i] && s[i] <= '9') {
+         do {
+            item_nr = item_nr * 10 + (s[i] - '0');
+            }
+         while ( !((s[++i] == '\t')||(s[i] == ' ')) && (s[i] != '\0') && ('0' <= s[i]) && (s[i] <= '9'));
+         if ((Key == kOk) && (item_nr == key_nr)) {
+#else
       if (s && (s = skipspace(s)) != NULL) {
          if (*s == Key - k1 + '1') {
+#endif /* LIEMIEXT */
             current = item->Index();
             RefreshCurrent();
             Display();
             cRemote::Put(kOk, true);
+#ifdef USE_LIEMIEXT
+            key_nr = -1;
+#endif /* LIEMIEXT */
             break;
             }
+#ifdef USE_LIEMIEXT
+         else if (Key != kOk) {
+            if (!highlight && (item_nr == (Key - k0))) {
+               highlight = true;
+               current = item->Index();
+               }
+            if (!match && (key_nr == -1) && ((item_nr / 10) == (Key - k0))) {
+               match = true;
+               key_nr = (Key - k0);
+               }
+            else if (((key_nr == -1) && (item_nr == (Key - k0))) || (!match && (key_nr >= 0) && (item_nr == (10 * key_nr + Key - k0)))) {
+               current = item->Index();
+               cRemote::Put(kOk, true);
+               key_nr = -1;
+               break;
+               }
+            }
+#endif /* LIEMIEXT */
          }
       }
+#ifdef USE_LIEMIEXT
+  if ((!match) && (Key != kNone)) {
+     key_nr = -1;
+     }
+#endif /* LIEMIEXT */
   return osContinue;
 }
 
@@ -658,8 +730,13 @@
         }
      }
   switch (Key) {
+#ifdef USE_LIEMIEXT
+    case kNone:
+    case k0...k9: return hasHotkeys ? HotKey(Key) : osUnknown;
+#else
     case k0:      return osUnknown;
     case k1...k9: return hasHotkeys ? HotKey(Key) : osUnknown;
+#endif /* LIEMIEXT */
     case kUp|k_Repeat:
     case kUp:   CursorUp();   break;
     case kDown|k_Repeat:
Index: pat.c
===================================================================
--- pat.c	(revision 15412)
+++ pat.c	(revision 15413)
@@ -13,6 +13,9 @@
 #include "libsi/section.h"
 #include "libsi/descriptor.h"
 #include "thread.h"
+#ifdef USE_TTXTSUBS
+#include "vdrttxtsubshooks.h"
+#endif /* TTXTSUBS */
 
 #define PMT_SCAN_TIMEOUT  10 // seconds
 
@@ -343,6 +346,10 @@
         char DLangs[MAXDPIDS][MAXLANGCODE2] = { "" };
         char SLangs[MAXSPIDS][MAXLANGCODE2] = { "" };
         int Tpid = 0;
+#ifdef USE_TTXTSUBS
+        tTeletextSubtitlePage TeletextSubtitlePages[MAXTXTPAGES];
+        int NumTPages = 0;
+#endif /* TTXTSUBS */
         int NumApids = 0;
         int NumDpids = 0;
         int NumSpids = 0;
@@ -434,8 +441,27 @@
                                     NumSpids++;
                                     }
                                  break;
+#ifdef USE_TTXTSUBS
+                            case SI::TeletextDescriptorTag: {
+#else
                             case SI::TeletextDescriptorTag:
+#endif /* TTXTSUBS */
                                  Tpid = esPid;
+#ifdef USE_TTXTSUBS
+                                 SI::TeletextDescriptor *sd = (SI::TeletextDescriptor *)d;
+                                 SI::TeletextDescriptor::Teletext ttxt;
+                                 for (SI::Loop::Iterator it; sd->teletextLoop.getNext(ttxt, it); ) {
+                                     bool isSubtitlePage = (ttxt.getTeletextType() == 0x02) || (ttxt.getTeletextType() == 0x05);
+                                     if ((NumTPages < MAXTXTPAGES) && ttxt.languageCode[0] && isSubtitlePage) {
+                                        strn0cpy(TeletextSubtitlePages[NumTPages].ttxtLanguage, I18nNormalizeLanguageCode(ttxt.languageCode), MAXLANGCODE1);
+                                        TeletextSubtitlePages[NumTPages].ttxtPage = ttxt.getTeletextPageNumber();
+                                        TeletextSubtitlePages[NumTPages].ttxtMagazine = ttxt.getTeletextMagazineNumber();
+                                        TeletextSubtitlePages[NumTPages].ttxtType = ttxt.getTeletextType();
+                                        NumTPages++;
+                                        }
+                                     }
+                                 }
+#endif /* TTXTSUBS */
                                  break;
                             case SI::ISO639LanguageDescriptorTag: {
                                  SI::ISO639LanguageDescriptor *ld = (SI::ISO639LanguageDescriptor *)d;
@@ -491,7 +517,17 @@
             }
         if (Setup.UpdateChannels >= 2) {
            Channel->SetPids(Vpid, Ppid, Vtype, Apids, Atypes, ALangs, Dpids, Dtypes, DLangs, Spids, SLangs, Tpid);
+#ifdef USE_TTXTSUBS
+           if (NumTPages < MAXTXTPAGES) {
+	      int manualPageNumber = cVDRTtxtsubsHookListener::Hook()->ManualPageNumber(Channel);
+	      if (manualPageNumber)
+                 TeletextSubtitlePages[NumTPages++] = tTeletextSubtitlePage(manualPageNumber);
+              }
+           Channel->SetTeletextSubtitlePages(TeletextSubtitlePages, NumTPages);
+	   Channel->SetCaIds(CaDescriptors->CaIds());
+#else
            Channel->SetCaIds(CaDescriptors->CaIds());
+#endif /* TTXTSUBS */
            Channel->SetSubtitlingDescriptors(SubtitlingTypes, CompositionPageIds, AncillaryPageIds);
            }
         Channel->SetCaDescriptors(CaDescriptorHandler.AddCaDescriptors(CaDescriptors));
Index: osdbase.h
===================================================================
--- osdbase.h	(revision 15412)
+++ osdbase.h	(revision 15413)
@@ -14,6 +14,7 @@
 #include "osd.h"
 #include "skins.h"
 #include "tools.h"
+
 #if defined (USE_SETUP) && defined (USE_PINPLUGIN)
 #include "submenu.h"
 #endif /* SETUP & PINPLUGIN */
@@ -117,6 +118,10 @@
   char *status;
   int digit;
   bool hasHotkeys;
+#ifdef USE_LIEMIEXT
+  int key_nr;
+  cTimeMs lastActivity;
+#endif /* LIEMIEXT */
 protected:
   void SetDisplayMenu(void);
   cSkinDisplayMenu *DisplayMenu(void) { return displayMenu; }
@@ -160,6 +165,9 @@
 #endif /* REELVDR */
   virtual void Display(void);
   virtual eOSState ProcessKey(eKeys Key);
+#ifdef USE_GRAPHTFT
+  virtual const char* MenuKind() { return "MenuUnknown"; }
+#endif /* GRAPHTFT */
   };
 
 #endif //__OSDBASE_H
